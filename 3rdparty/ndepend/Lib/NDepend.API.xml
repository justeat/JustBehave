<?xml version="1.0"?>
<doc>
  <assembly>
    <name>NDepend.API</name>
  </assembly>
  <members>
    <member name="T:NDepend.Analysis.AnalysisException">
      <summary>
            The exception that is thrown when an analysis related operation fails.
            </summary>
      <remarks>
            Methods potentially throwing this exception are: <br />
            ExtensionMethodsProjectAnalysis.<see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysisAndBuildReport(NDepend.Project.IProject)" /><br />
            ExtensionMethodsProjectAnalysis.<see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysis(NDepend.Project.IProject)" /><br />
            ExtensionMethodsProjectAnalysis.<see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.GetAnalysisResultRefToCompareWith(NDepend.Project.IProjectBaseline)" /><br />
            IAnalysisResultRef.<see cref="M:NDepend.Analysis.IAnalysisResultRef.Load" /></remarks>
    </member>
    <member name="M:NDepend.Analysis.AnalysisException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NDepend.Analysis.AnalysisException" /> class with a specified error message.
            </summary>
      <param name="message">A message that describes the error.</param>
    </member>
    <member name="M:NDepend.Analysis.AnalysisException.#ctor(System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NDepend.Analysis.AnalysisException" /> class with a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException" /> parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
    </member>
    <member name="T:NDepend.Analysis.ExtensionMethodsProjectAnalysis">
      <summary>
            Provides a set of extension methods to run analysis (only available with a Build Machine license) and to collect existing analysis results references. 
            </summary>
    </member>
    <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.TryGetMostRecentAnalysisResultRef(NDepend.Project.IProject,NDepend.Analysis.IAnalysisResultRef@)">
      <summary>
            Gets a reference to the most recent analysis result available for this <paramref name="project" />.
            </summary>
      <returns>A value indicating if a most recent analysis result referece has been found for this <paramref name="project" />.</returns>
      <param name="project">This NDepend project.</param>
      <param name="mostRecentAnalysisResultRef">The reference to the most recent analysis result or <i>null</i> if the method call returned <i>false</i>.</param>
      <requires description="project must not be null" csharp="project != null" vb="project &lt;&gt; Nothing">project != null</requires>
    </member>
    <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.GetAvailableAnalysisResultsRefs(NDepend.Project.IProject)">
      <summary>
            Gets a collection of all analysis results available for this <paramref name="project" />.
            </summary>
      <param name="project">This NDepend project.</param>
      <remarks>
            If IProjectBaseline.<see cref="P:NDepend.Project.IProjectBaseline.KeepHistoric" /> is set to false for IProject.<see cref="P:NDepend.Project.IProject.BaselineDuringAnalysis" />, then the returned collection will contain the last analysis result available for this <paramref name="project" />, or nothing if no analysis result is available for this <paramref name="project" />.<br />
            On a NDepend project with many analysis results available for years, it is performant wise to prefer calling <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.GetAvailableAnalysisResultsRefsGroupedPerMonth(NDepend.Project.IProject)" /> instead of this method, because analysis results references are then lazy-resolved, per month.
            </remarks>
      <requires description="project must not be null" csharp="project != null" vb="project &lt;&gt; Nothing">project != null</requires>
      <ensures description="returned collection is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.GetAvailableAnalysisResultsRefsGroupedPerMonth(NDepend.Project.IProject)">
      <summary>
            Gets a collection of all analysis results available for this <paramref name="project" />, grouped per months.
            </summary>
      <param name="project">This NDepend project.</param>
      <remarks>
            If IProjectBaseline.<see cref="P:NDepend.Project.IProjectBaseline.KeepHistoric" /> is set to false for IProject.<see cref="P:NDepend.Project.IProject.BaselineDuringAnalysis" />, then the returned collection will contain the last analysis result available for this <paramref name="project" />, or nothing if no analysis result is available for this <paramref name="project" />.<br />
            On a NDepend project with many analysis results available for years, it is performant wise to call this method than calling <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.GetAvailableAnalysisResultsRefs(NDepend.Project.IProject)" />, because analysis results references are then lazy-resolved, per month.
            </remarks>
      <requires description="project must not be null" csharp="project != null" vb="project &lt;&gt; Nothing">project != null</requires>
      <ensures description="returned collection is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.GetAnalysisResultRefToCompareWith(NDepend.Project.IProjectBaseline)">
      <summary>
            Returns an analysis reference corresponding to this project baseline to compare with.
            </summary>
      <param name="projectBaseline">This NDepend project baseline, obtained from IProject.<see cref="P:NDepend.Project.IProject.BaselineDuringAnalysis" /> or IProject.<see cref="P:NDepend.Project.IProject.BaselineInUI" />.</param>
      <exception cref="T:NDepend.Analysis.AnalysisException">A problem occured while retrieving the analysis result reference.</exception>
      <requires description="projectBaseline must not be null" csharp="projectBaseline != null" vb="projectBaseline &lt;&gt; Nothing">projectBaseline != null</requires>
      <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysis(NDepend.Project.IProject)">
      <summary>
            Runs a full analysis on this project, in-process and synchronously. (Only available with a Build Machine license).
            </summary>
      <remarks>
            Calling this method will typically takes a few seconds, the time the analysis is performed.<br />
            The analysis result is persisted in the project.Properties.<see cref="P:NDepend.Project.IProjectProperties.OutputDir" /> directory.<br />
            So far, it is not possible to run several analysis simulteanously on several threads in the same AppDomain, but this situation might evolve in the future.
            </remarks>
      <param name="project">This NDepend project to analyze.</param>
      <returns>The analysis result.</returns>
      <exception cref="T:System.Exception">Cannot run analysis without a Build Machine license.</exception>
      <exception cref="T:NDepend.Analysis.AnalysisException">The analysis execution failed. The InnerException contains additional information concernig the failure.</exception>
      <requires description="project must not be null" csharp="project != null" vb="project &lt;&gt; Nothing">project != null</requires>
      <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysis(NDepend.Project.IProject,System.Action{NDepend.Analysis.IAnalysisLog},System.Action{NDepend.Analysis.IProgressLog})">
      <summary>
            Runs a full analysis on this project, in-process and synchronously. (Only available with a Build Machine license).
            </summary>
      <remarks>
            Calling this method will typically takes a few seconds, the time the analysis is performed.<br />
            The analysis result is persisted in the project.Properties.<see cref="P:NDepend.Project.IProjectProperties.OutputDir" /> directory.<br />
            So far, it is not possible to run several analysis simulteanously on several threads in the same AppDomain, but this situation might evolve in the future.
            </remarks>
      <param name="project">This NDepend project to analyze.</param>
      <returns>The analysis result.</returns>
      <exception cref="T:System.Exception">Cannot run analysis without a Build Machine license.</exception>
      <exception cref="T:NDepend.Analysis.AnalysisException">The analysis execution failed. The InnerException contains additional information concernig the failure.</exception>
      <param name="analysisLogHandler">A procedure delegate object invoked each time the current analysis run emits a new <see cref="T:NDepend.Analysis.IAnalysisLog" /> object.</param>
      <param name="progressLogHandler">A procedure delegate object invoked each time the current analysis run emits a new <see cref="T:NDepend.Analysis.IProgressLog" /> object.</param>
      <requires description="project must not be null" csharp="project != null" vb="project &lt;&gt; Nothing">project != null</requires>
      <requires description="analysisLogHandler must not be null" csharp="analysisLogHandler != null" vb="analysisLogHandler &lt;&gt; Nothing">analysisLogHandler != null</requires>
      <requires description="progressLogHandler must not be null" csharp="progressLogHandler != null" vb="progressLogHandler &lt;&gt; Nothing">progressLogHandler != null</requires>
      <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysisAndBuildReport(NDepend.Project.IProject)">
      <summary>
            Runs a full analysis on this project, in-process and synchronously, and then generate a HTML report. (Only available with a Build Machine license).
            </summary>
      <remarks>
            The report generated is available in project.Properties.<see cref="P:NDepend.Project.IProjectProperties.OutputDir" />, named "NDependReport.html".<br />
            Calling this method will typically takes a few seconds, the time the analysis is performed.<br />
            The analysis result is persisted in the project.Properties.<see cref="P:NDepend.Project.IProjectProperties.OutputDir" /> directory.<br />
            So far, it is not possible to run several analysis simulteanously on several threads in the same AppDomain, but this situation might evolve in the future.
            </remarks>
      <param name="project">This NDepend project to analyze.</param>
      <returns>The analysis result.</returns>
      <exception cref="T:System.Exception">Cannot run analysis without a Build Machine license.</exception>
      <exception cref="T:NDepend.Analysis.AnalysisException">The analysis execution failed. The InnerException contains additional information concernig the failure.</exception>
      <requires description="project must not be null" csharp="project != null" vb="project &lt;&gt; Nothing">project != null</requires>
      <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysisAndBuildReport(NDepend.Project.IProject,System.Action{NDepend.Analysis.IAnalysisLog},System.Action{NDepend.Analysis.IProgressLog})">
      <summary>
            Runs a full analysis on this project, in-process and synchronously, and then generate a HTML report. (Only available with a Build Machine license).
            </summary>
      <remarks>
            The report generated is available in project.Properties.<see cref="P:NDepend.Project.IProjectProperties.OutputDir" />, named "NDependReport.html".<br />
            Calling this method will typically takes a few seconds, the time the analysis is performed.<br />
            The analysis result is persisted in the project.Properties.<see cref="P:NDepend.Project.IProjectProperties.OutputDir" /> directory.<br />
            So far, it is not possible to run several analysis simulteanously on several threads in the same AppDomain, but this situation might evolve in the future.
            </remarks>
      <param name="project">This NDepend project to analyze.</param>
      <returns>The analysis result.</returns>
      <exception cref="T:System.Exception">Cannot run analysis without a Build Machine license.</exception>
      <exception cref="T:NDepend.Analysis.AnalysisException">The analysis execution failed. The InnerException contains additional information concernig the failure.</exception>
      <param name="analysisLogHandler">A procedure delegate object invoked each time the current analysis run emits a new <see cref="T:NDepend.Analysis.IAnalysisLog" /> object.</param>
      <param name="progressLogHandler">A procedure delegate object invoked each time the current analysis run emits a new <see cref="T:NDepend.Analysis.IProgressLog" /> object.</param>
      <requires description="project must not be null" csharp="project != null" vb="project &lt;&gt; Nothing">project != null</requires>
      <requires description="analysisLogHandler must not be null" csharp="analysisLogHandler != null" vb="analysisLogHandler &lt;&gt; Nothing">analysisLogHandler != null</requires>
      <requires description="progressLogHandler must not be null" csharp="progressLogHandler != null" vb="progressLogHandler &lt;&gt; Nothing">progressLogHandler != null</requires>
      <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.AnalyzeAssemblies(System.Collections.Generic.ICollection{System.String})">
      <summary>
            Analyze a set of assemblies, in-process and synchronously, and return a <see cref="T:NDepend.Analysis.IAnalysisResult" /> object. (Only available with a Build Machine license).
            </summary>
      <remarks>
            Calling this method will typically takes a few seconds, the time the analysis is performed.<br />
            Internally, this methods creates a temporary project with the method <see cref="M:NDepend.Project.IProjectManager.CreateTemporaryProject(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},NDepend.Project.TemporaryProjectMode)" /> and then call <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysis(NDepend.Project.IProject)" /> on this temporary project.
            So far, it is not possible to run several analysis simulteanously on several threads in the same AppDomain, but this situation might evolve in the future.
            </remarks>
      <param name="applicationAssembliesPath">A collection of string that contains assemblies file paths.</param>
      <returns>The analysis result.</returns>
      <exception cref="T:NDepend.Project.ProjectException">Problem with creating a temporary project.</exception>
      <exception cref="T:System.Exception">Cannot run analysis without a Build Machine license.</exception>
      <exception cref="T:NDepend.Analysis.AnalysisException">The analysis execution failed. The InnerException contains additional information concernig the failure.</exception>
      <exception cref="T:System.ArgumentNullException">One of the string in <paramref name="applicationAssembliesPath" /> is null.</exception>
      <exception cref="T:System.ArgumentException">One of the string in <paramref name="applicationAssembliesPath" /> is not a valid absolute file path.</exception>
      <exception cref="T:System.IO.FileNotFoundException">One absolute file path in <paramref name="applicationAssembliesPath" /> doesn't exist.</exception>
      <requires description="applicationAssembliesPath must not be null" csharp="applicationAssembliesPath != null" vb="applicationAssembliesPath &lt;&gt; Nothing">applicationAssembliesPath != null</requires>
      <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.AnalyzeAssemblies(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath})">
      <summary>
            Analyze a set of assemblies, in-process and synchronously, and return a <see cref="T:NDepend.Analysis.IAnalysisResult" /> object. (Only available with a Build Machine license).
            </summary>
      <remarks>
            Calling this method will typically takes a few seconds, the time the analysis is performed.<br />
            Internally, this methods creates a temporary project with the method <see cref="M:NDepend.Project.IProjectManager.CreateTemporaryProject(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},NDepend.Project.TemporaryProjectMode)" /> and then call <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.RunAnalysis(NDepend.Project.IProject)" /> on this temporary project.
            So far, it is not possible to run several analysis simulteanously on several threads in the same AppDomain, but this situation might evolve in the future.
            </remarks>
      <param name="applicationAssembliesPath">A collection of <see cref="T:NDepend.Path.IAbsoluteFilePath" /> object that contains assemblies file paths.</param>
      <returns>The analysis result.</returns>
      <exception cref="T:System.Exception">Cannot run analysis without a Build Machine license.</exception>
      <exception cref="T:NDepend.Project.ProjectException">Problem with creating a temporary project.</exception>
      <exception cref="T:NDepend.Analysis.AnalysisException">The analysis execution failed. The InnerException contains additional information concernig the failure.</exception>
      <requires description="applicationAssembliesPath must not be null" csharp="applicationAssembliesPath != null" vb="applicationAssembliesPath &lt;&gt; Nothing">applicationAssembliesPath != null</requires>
      <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:NDepend.Analysis.AnalysisLogCategory">
      <summary>
            Represents an analysis log category: Info / Warning / Error.
            </summary>
    </member>
    <member name="F:NDepend.Analysis.AnalysisLogCategory.Info">
      <summary>
            AnalysisLogCategory.Info
            </summary>
    </member>
    <member name="F:NDepend.Analysis.AnalysisLogCategory.Warning">
      <summary>
            AnalysisLogCategory.Warning
            </summary>
    </member>
    <member name="F:NDepend.Analysis.AnalysisLogCategory.Error">
      <summary>
            AnalysisLogCategory.Error
            </summary>
    </member>
    <member name="T:NDepend.Analysis.IAnalysisLog">
      <summary>
            Represents a log emitted at analysis execution time.
            </summary>
      <remarks>
        <see cref="T:NDepend.Analysis.IAnalysisLog" /> objects can be gathered by dedicated overloads of run analysis extension methods in <see cref="T:NDepend.Analysis.ExtensionMethodsProjectAnalysis" />.
            </remarks>
    </member>
    <member name="P:NDepend.Analysis.IAnalysisLog.Category">
      <summary>
            Gets this analysis log category.
            </summary>
    </member>
    <member name="P:NDepend.Analysis.IAnalysisLog.Description">
      <summary>
            Gets this analysis log description.
            </summary>
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.Analysis.IAnalysisManager">
      <summary>
            Exposes the unique ShowDialogBuildComparison method. A IAnalysisManager object can be obtained from the property <see cref="T:NDepend.NDependServicesProvider" />.<see cref="P:NDepend.NDependServicesProvider.AnalysisManager" />.
            </summary>
    </member>
    <member name="M:NDepend.Analysis.IAnalysisManager.ShowDialogBuildComparison(NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@,NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@)">
      <summary>
            Shows a dialog that lets the user select an older and newer, project or analysis result reference.
            </summary>
      <param name="projectOlder">Project older choosen, is null if <paramref name="analysisResultRefOlder" /> is not null.</param>
      <param name="analysisResultRefOlder">Anslysis Result older choosen, is null if <paramref name="projectOlder" /> is not null.</param>
      <param name="projectNewer">Project newer choosen, is null if <paramref name="analysisResultRefNewer" /> is not null.</param>
      <param name="analysisResultRefNewer">Anslysis Result newer choosen, is null if <paramref name="projectNewer" /> is not null.</param>
      <returns>True if the user clicked OK, False if the user clicked Cancel</returns>
      <exception cref="T:System.Threading.ThreadStateException">This operation needs the current thread to be a STA thread. To do so, just tag your Main() method with the [STAThread] attribute.</exception>
      <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
      <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
      <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogChooseAnExistingProject(NDepend.Project.IProject@)" />
      <seealso cref="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.ShowDialogSelectVisualStudioSolutionsOrProjects(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
    </member>
    <member name="T:NDepend.Analysis.IAnalysisResult">
      <summary>
            Represents an analysis result. 
            </summary>
    </member>
    <member name="P:NDepend.Analysis.IAnalysisResult.AnalysisResultRef">
      <summary>
            Gets a <see cref="T:NDepend.Analysis.IAnalysisResultRef" /> object corresponding to this analysis result.
            </summary>
      <getter>
        <ensures description="returned analysis result reference object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Analysis.IAnalysisResult.CodeBase">
      <summary>
            Gets a <see cref="T:NDepend.CodeModel.ICodeBase" /> object representing the code base snapshot for this analysis result.
            </summary>
      <getter>
        <ensures description="returned code base object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Analysis.IAnalysisResult.QueriesExtractedFromCode">
      <summary>
            Gets code rules and queries defined in the code base through the attribute <see cref="T:NDepend.Attributes.CodeRuleAttribute" />.
            </summary>
      <getter>
        <ensures description="returned group of groups object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.Analysis.IAnalysisResultRef">
      <summary>
            Represents a reference to a NDepend analysis result.
            </summary>
    </member>
    <member name="M:NDepend.Analysis.IAnalysisResultRef.Load">
      <summary>
            Loads the analysis result corresponding to this analysis result reference.
            </summary>
      <returns>The analysis result loaded.</returns>
      <exception cref="T:NDepend.Analysis.AnalysisException">If the analysis load fails, an AnalysisException with an informative message is thrown.</exception>
      <ensures description="returned analysis result object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Analysis.IAnalysisResultRef.Load(System.Action{NDepend.Analysis.IProgressLog})">
      <summary>
            Loads the analysis result corresponding to this analysis result reference.
            </summary>
      <returns>The analysis result loaded.</returns>
      <param name="progressLogHandler">A procedure delegate object that is invoked each time the current analysis load emits a new <see cref="T:NDepend.Analysis.IProgressLog" /> object.</param>
      <exception cref="T:NDepend.Analysis.AnalysisException">If the analysis load fails, an AnalysisException with an informative message is thrown.</exception>
      <requires description="progressLogHandler must not be null" csharp="progressLogHandler != null" vb="progressLogHandler &lt;&gt; Nothing">progressLogHandler != null</requires>
      <ensures description="returned analysis result object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:NDepend.Analysis.IAnalysisResultRef.Project">
      <summary>
            Gets the NDepend project from which the analysis has been done.
            </summary>
      <getter>
        <ensures description="returned project object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Analysis.IAnalysisResultRef.Date">
      <summary>
            Gets the date when the analysis has been executed.
            </summary>
    </member>
    <member name="P:NDepend.Analysis.IAnalysisResultRef.AnalysisResultFilePath">
      <summary>
            Gets the path to the analysis result data file.
            </summary>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Analysis.IAnalysisResultRef.ReportFilePath">
      <summary>
            Gets the path to the report file corresponding to the analysis result.
            </summary>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Analysis.IAnalysisResultRef.IsHistoric">
      <summary>
            Returns <i>true</i> if the analysis data is stored in a historic directory. Returns false if the analysis data is stored in the project output directory.
            </summary>
      <remarks>
            A historic directory is a sub-directory of the project output directory.
            </remarks>
    </member>
    <member name="T:NDepend.Analysis.IAnalysisResultsRefsForAMonth">
      <summary>
            Represents a collection of available analysis results references, done during a particular month.
            </summary>
      <remarks>
            A collection of <see cref="T:NDepend.Analysis.IAnalysisResultsRefsForAMonth" /> object can be obtained from a <see cref="T:NDepend.Project.IProject" /> object through the extension method <see cref="M:NDepend.Analysis.ExtensionMethodsProjectAnalysis.GetAvailableAnalysisResultsRefsGroupedPerMonth(NDepend.Project.IProject)" />.<br />
            The collection of analysis results references is lazy loaded when calling the property <see cref="P:NDepend.Analysis.IAnalysisResultsRefsForAMonth.AnalysisResultRefs" />. 
            </remarks>
    </member>
    <member name="P:NDepend.Analysis.IAnalysisResultsRefsForAMonth.MonthDate">
      <summary>
            Gets the month date.
            </summary>
    </member>
    <member name="P:NDepend.Analysis.IAnalysisResultsRefsForAMonth.AnalysisResultRefs">
      <summary>
            Gets the collection of analysis results' references available for the specified month.
            </summary>
      <remarks>
            The collection of analysis results references is lazy loaded when calling the property <see cref="P:NDepend.Analysis.IAnalysisResultsRefsForAMonth.AnalysisResultRefs" />. 
            </remarks>
      <getter>
        <ensures description="returned collection is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.Analysis.IProgressLog">
      <summary>
            Represents a progress log emitted at analysis execution time or existing analysis result load time.
            </summary>
    </member>
    <member name="P:NDepend.Analysis.IProgressLog.EstimatedPercentageDone">
      <summary>
            Gets this progress log estimated percentage done, between 0 and 100 included.
            </summary>
      <getter>
        <ensures description="returned percentage is lower or equal to 100" csharp="result &lt;= 100" vb="result &lt;= 100">result &lt;= 100</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Analysis.IProgressLog.Description">
      <summary>
            Gets this analysis log description.
            </summary>
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.Attributes.FullCoveredAttribute">
      <summary>
            This attribute can be used to declare that a code element is 100% covered by tests. 
            </summary>
      <remarks>
            The code metric ICodeContainer.<see cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" /> can be used to determine whether a code element is 100% covered by tests or not.<br />
            Having types 100% covered by tests is a good idea because the small portion of code hard to cover, is also the portion of code that is the most likely to contain bugs.<br />
            Usage of this attributes is checked with the two default code rules:
            <ul><li>Types tagged with FullCoveredAttribute should be 100% covered</li><li>Types 100% covered should be tagged with FullCoveredAttribute</li></ul>
            If you don't want to link <i>NDepend.API.dll</i>, you can use your own <i>FullCoveredAttribute</i> and adapt the rules.<br /></remarks>
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
      <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
    </member>
    <member name="M:NDepend.Attributes.FullCoveredAttribute.#ctor">
      <summary>
            Create a new instance of the <see cref="T:NDepend.Attributes.FullCoveredAttribute" /> class.
            </summary>
    </member>
    <member name="T:NDepend.Attributes.FullBranchCoveredAttribute">
      <summary>
            This attribute can be used to declare that a method is 100% branch covered by tests (branch coverage is only available with NCover). 
            </summary>
      <remarks>
            The branch coverage code metric is only available with NCover. <br />
            The code metric IMethod.<see cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" /> can be used to determine whether a method is 100% branch covered by tests or not.<br />
            A code rule is provided by default to continuously make sure that all method tagged with this attribute are indeed 100% branch covered by tests.<br />
            A code rule is provided by default to continuously make sure that all method 100% branch covered by tests are tagged with this attribute.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
      <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
    </member>
    <member name="M:NDepend.Attributes.FullBranchCoveredAttribute.#ctor">
      <summary>
            Create a new instance of the <see cref="T:NDepend.Attributes.FullBranchCoveredAttribute" /> class.
            </summary>
    </member>
    <member name="T:NDepend.Attributes.MoreThan95PercentCoveredAttribute">
      <summary>
            This attribute can be used to declare that a code element is more than 95% covered by tests. 
            </summary>
      <remarks>
            The code metric ICodeContainer.<see cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" /> can be used to determine whether a code element is more than 95% covered by test or not.<br />
            A code rule is provided by default to continuously make sure that all code elements tagged with this attribute are indeed more than 95% covered by tests.<br />
            A code rule is provided by default to continuously make sure that all code elements more than 95% covered by tests are tagged with this attribute.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
      <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
    </member>
    <member name="M:NDepend.Attributes.MoreThan95PercentCoveredAttribute.#ctor">
      <summary>
            Create a new instance of the <see cref="T:NDepend.Attributes.MoreThan95PercentCoveredAttribute" /> class.
            </summary>
    </member>
    <member name="T:NDepend.Attributes.UncoverableByTestAttribute">
      <summary>
            This attribute can be used to declare that a code element is not coverable by tests. 
            </summary>
      <remarks>
            This attribute is useful to keep a class deemed as 100% covered by tests, even if one of its methods is not coverable by tests (for example because it calls a blocking method such as MessageBox.Show()).<br />
            This attribute is typically defined through  <see cref="P:NDepend.Project.IProjectCoverage.UncoverableAttribute" />.
            </remarks>
      <seealso cref="P:NDepend.Project.IProjectCoverage.UncoverableAttribute" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
      <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
    </member>
    <member name="M:NDepend.Attributes.UncoverableByTestAttribute.#ctor">
      <summary>
            Create a new instance of the <see cref="T:NDepend.Attributes.UncoverableByTestAttribute" /> class.
            </summary>
    </member>
    <member name="T:NDepend.Attributes.CodeRuleAttribute">
      <summary>
            This attribute can be used to declare a code rule (or query) in your source code.
            </summary>
      <remarks>
            The code rule is a CQLinq or CQL string.<br />
            It is extracted automatically from assemblies analyzed at analysis time.<br />
            A code rule gathered from a <see cref="T:NDepend.Attributes.CodeRuleAttribute" /> appears under a group named: "Rules extracted from Source Code".<br />
            Under this rule, code rules are grouped under the parent namespaces of code elements tagged by <see cref="T:NDepend.Attributes.CodeRuleAttribute" />.<br />
            More information at <a href="http://www.ndepend.com/ConstraintsExtractedFromCode.aspx">Rules extracted from code</a></remarks>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
      <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeQuery.IQuery.IsExtractedFromCode" />
    </member>
    <member name="M:NDepend.Attributes.CodeRuleAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NDepend.Attributes.CodeRuleAttribute" /> class, from the specified <paramref name="codeRuleString" />.
            </summary>
      <remarks>
            When declaring a code rule in source file, you can use one of the tags $FullName$ or $Name$ to paste in the rule string the <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> of the code element tagged or the <see cref="P:NDepend.CodeModel.IMember.FullName" /> of the member (type/method/field) tagged.
            </remarks>
      <param name="codeRuleString">The string that contains the CQLinq or CQL code rule or query.</param>
    </member>
    <member name="M:NDepend.Attributes.CodeRuleAttribute.GetHashCode">
      <summary>
            System.Object.GetHashCode() is overriden for this class <see cref="T:NDepend.Attributes.CodeRuleAttribute" />.
            </summary>
    </member>
    <member name="M:NDepend.Attributes.CodeRuleAttribute.Equals(System.Object)">
      <summary>
            System.Object.GetHashCode() is overriden for this class <see cref="T:NDepend.Attributes.CodeRuleAttribute" />.
            </summary>
    </member>
    <member name="P:NDepend.Attributes.CodeRuleAttribute.CodeRuleString">
      <summary>
            Gets the CQLinq or CQL code rule string or query string.
            </summary>
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Attributes.CodeRuleAttribute.Active">
      <summary>
            Gets or sets a value that indicates whether the code rule is active.
            </summary>
      <remarks>
            The default value is true.
            </remarks>
    </member>
    <member name="P:NDepend.Attributes.CodeRuleAttribute.DisplayListInReport">
      <summary>
            Gets or sets a value that indicates whether if the code rule is violated, the code rule matched code elements are listed into the report.
            </summary>
      <remarks>
            The default value is true.
            </remarks>
    </member>
    <member name="P:NDepend.Attributes.CodeRuleAttribute.DisplayStatInReport">
      <summary>
            Gets or sets a value that indicates whether if the code rule is violated, the code rule matched code elements statistics are shown into the report.
            </summary>
      <remarks>
            The default value is true.
            </remarks>
    </member>
    <member name="P:NDepend.Attributes.CodeRuleAttribute.DisplaySelectionViewInReport">
      <summary>
            Gets or sets a value that indicates whether if the code rule is violated, the code rule matched code elements are shown in a treemap picture embedded into the report.
            </summary>
      <remarks>
            The default value is false.
            </remarks>
    </member>
    <member name="P:NDepend.Attributes.CodeRuleAttribute.IsCriticalRule">
      <summary>
            Gets or sets a value that indicates whether the code rule is critical or not.
            </summary>
      <remarks>
            The default value is false.<br />
            A critical code rule is useful to break the build process once the rule is violated.<br />
            More information at: <a href="http://www.ndepend.com/Doc_CI_CriticalRule.aspx">Critical Rules and Build Failure</a></remarks>
    </member>
    <member name="T:NDepend.Attributes.ImmutableAttribute">
      <summary>
            This attribute can be used to declare a type as immutable. 
            </summary>
      <remarks>
            A class or structure is immutable if its instance object's state, cannot be modified after it is created. This is in contrast to a mutable object, which can be modified after it is created.<br />
            The property IType.<see cref="P:NDepend.CodeModel.IType.IsImmutable" /> can be used to determine whether a type is immutable or not.<br />
            A code rule is provided by default to continuously make sure that all types tagged with this attribute are indeed immutable.<br />
            A code rule is provided by default to continuously make sure that all immutable types are tagged with this attribute.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.IsImmutable" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
      <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
    </member>
    <member name="M:NDepend.Attributes.ImmutableAttribute.#ctor">
      <summary>
            Create a new instance of the <see cref="T:NDepend.Attributes.PureAttribute" /> class.
            </summary>
    </member>
    <member name="T:NDepend.Attributes.PureAttribute">
      <summary>
            This attribute can be used to declare a method as pure. 
            </summary>
      <remarks>
            A method is pure if it cannot be called in a way to provoque a side-effect.<br />
            The properties IMethod.<see cref="P:NDepend.CodeModel.IMethod.ChangesObjectState" /> and IMethod.<see cref="P:NDepend.CodeModel.IMethod.ChangesTypeState" /> can be used to determine whether a method is pure or not.<br />
            A code rule is provided by default to continuously make sure that all methods tagged with this attribute are pure.<br />
            A code rule is provided by default to continuously make sure that all pure methods are tagged with this attribute.<br />
            Since .NET v4, you can also use the attribute type System.Diagnostics.Contracts.PureAttribute declared in mscorlib.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.ChangesObjectState" />
      <seealso cref="P:NDepend.CodeModel.IMethod.ChangesTypeState" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
      <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
    </member>
    <member name="M:NDepend.Attributes.PureAttribute.#ctor">
      <summary>
            Create a new instance of the <see cref="T:NDepend.Attributes.PureAttribute" /> class.
            </summary>
    </member>
    <member name="T:NDepend.Attributes.CannotDecreaseVisibilityAttribute">
      <summary>
            This attribute can be used to signify that despite a member could have a lower visibility without provoking any syntax error, your intention is to not change this member visibility.
            </summary>
      <remarks>
            Default Visibility code rules take account of this attribute.<br />
            Compare IMember.<see cref="P:NDepend.CodeModel.IMember.Visibility" /> and IMember.<see cref="P:NDepend.CodeModel.IMember.OptimalVisibility" /> values to detect members whose visibility can be decreased.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMember.CouldBePrivate" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
      <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
    </member>
    <member name="M:NDepend.Attributes.CannotDecreaseVisibilityAttribute.#ctor">
      <summary>
            Create a new instance of the <see cref="T:NDepend.Attributes.CannotDecreaseVisibilityAttribute" /> class.
            </summary>
    </member>
    <member name="T:NDepend.Attributes.IsNotDeadCodeAttribute">
      <summary>
            This attribute can be used to signify that despite a member could be removed without provoking any syntax error (we also say it is dead code), your intention is to not remove this member.
            </summary>
      <remarks>
            Some code rules are provided by default to match dead types, methods and fields, except those tagged with this attribute.<br />
            Typically, this attribute is useful when the code element  :
            <ul><li>is only used by tests</li><li>is only used for debugging purposes</li><li>is only used by reflection or remoting, like for some serialization methods</li><li>is a class that contains only constants, hence it is never used in IL code, and it is never seen as used by NDepend</li><li>is a field whose only need is for LayoutKind.Sequential reasons</li></ul></remarks>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
      <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
    </member>
    <member name="M:NDepend.Attributes.IsNotDeadCodeAttribute.#ctor">
      <summary>
            Create a new instance of the <see cref="T:NDepend.Attributes.IsNotDeadCodeAttribute" /> class.
            </summary>
    </member>
    <member name="T:NDepend.CodeModel.ISimpleNamed">
      <summary>
            Represents a code element that has a simple name. This interface is implemented by <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> and <see cref="T:NDepend.CodeModel.INamespace" />.
            </summary>
      <remarks>
        <ul>
          <li>
            If a <see cref="T:NDepend.CodeModel.INamespace" />.<see cref="P:NDepend.CodeModel.ICodeElement.Name" /> is <i>"N1.N2.N3"</i>, its <see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" /> is <i>"N3"</i>.
            The default namespace has a <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> and <see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" /> equals to an empty string.
            </li>
          <li>
            If a nested generic <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.ICodeElement.Name" /> is <i>"OutterTypeName+MyType&lt;T1,T2&gt;"</i>, its <see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" /> is <i>"MyType"</i>.
            <see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" /> is equals to <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> for non-generic non-nested types.
            </li>
          <li>
            If a  generic <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.ICodeElement.Name" /> is <i>"MyMethod&lt;T1,T2&gt;(Object,String)"</i>, its <see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" /> is <i>"MyMethod"</i>.
            </li>
        </ul>
        <br />
      </remarks>
    </member>
    <member name="T:NDepend.CodeModel.ICodeElement">
      <summary>
            Represents a code element. This interface is implemented by <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IField" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.INamespace" /> and <see cref="T:NDepend.CodeModel.IAssembly" />.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.ICodeElement.Name">
      <summary>Gets a string representing the name of this code element.</summary>
      <remarks>
        <ul>
          <li>In case of a type the name is <i>TypeName&lt;T&gt;</i> not prefixed with the parent namespace name.</li>
          <li>In case of a nested type the name is <i>OutterTypeName+TypeName&lt;T&gt;</i> prefixed with the parent type name but not prefixed with the parent namespace name.</li>
          <li>In case of a method the name is <i>MethodName&lt;T&gt;(parameters types)</i> not prefixed with the parent namespace name or parent type name.</li>
          <li>In case of a field the name is <i>FieldName</i> not prefixed with the parent namespace name or parent type name.</li>
          <li>In case of a namespace the name is simply the  namespace name like <i>N1.N2.N3</i>.</li>
          <li>The anonymous namespace of an assembly has a <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> equals to the empty string.</li>
          <li>In case of an assembly the name is the assembly main module file name, without file extension.</li>
        </ul>
            This property getter has a constant time complexity.<br /></remarks>
      <returns>The name of this code element.</returns>
      <seealso cref="P:NDepend.CodeModel.IMember.FullName" />
      <seealso cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" />
      <seealso cref="T:NDepend.CodeModel.ISimpleNamed" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ICodeElement.ParentCodeBase">
      <summary>Gets the parent code base of this code element</summary>
      <remarks>
            Notice that an <see cref="T:NDepend.CodeModel.ICodeBase" /> is not an <see cref="T:NDepend.CodeModel.ICodeElement" />.<br />
            This property getter has a constant time complexity.
            </remarks>
      <returns>The parent code base of this code element.</returns>
      <getter>
        <ensures description="returned codeBase object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ICodeElement.IsThirdParty">
      <summary>Gets a value indicating whether this code element is an applicaton or a third-party code element.</summary>
      <remarks>This property getter has a constant time complexity.</remarks>
      <returns>true if this code element is declared in a third-party assembly, or is itself a third-party assembly.</returns>
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ExceptThirdParty``1(System.Collections.Generic.IEnumerable{``0})" />
    </member>
    <member name="P:NDepend.CodeModel.ICodeElement.SourceFileDeclAvailable">
      <summary>Gets a value indicating whether source file declaration(s) of this code element have been gathered at analysis time and i now available.</summary>
      <remarks>
            So far only C# code is parsed and also, source file declarations for abstract methods and fields are not retreived.
            This situation might changed in the future.
            </remarks>
      <returns>
            true if source file declaration(s) are available for this code element.
            </returns>
      <seealso cref="T:NDepend.Project.IProjectSourceFilesRebasing" />
      <seealso cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryOpenSource(NDepend.CodeModel.ICodeElement)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceFileLine,NDepend.CodeModel.ISourceFileLine)" />
    </member>
    <member name="P:NDepend.CodeModel.ICodeElement.SourceDecls">
      <summary>
            Returns one or several source file declarations of this code element.
            Returns an empty sequence if not SourceFileDeclAvailable.
            </summary>
      <remarks>
            Assemblies, namespaces and types can have several source file declarations.
            Methods and fields can have at most one source file declaration.
            </remarks>
      <seealso cref="T:NDepend.Project.IProjectSourceFilesRebasing" />
      <seealso cref="P:NDepend.CodeModel.ICodeElement.SourceFileDeclAvailable" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryOpenSource(NDepend.CodeModel.ICodeElement)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceFileLine,NDepend.CodeModel.ISourceFileLine)" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ISimpleNamed.SimpleName">
      <summary>
            Gets this code element simple name, without its eventual parameters signature nor its eventual generic signature not prefixed by its parent type or namespace name.
            </summary>
      <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
      <seealso cref="P:NDepend.CodeModel.IMember.FullName" />
      <seealso cref="P:NDepend.CodeModel.IMethod.Overloads" />
      <seealso cref="P:NDepend.CodeModel.IMethod.IsOverloaded" />
      <seealso cref="P:NDepend.CodeModel.IMethod.NbOverloads" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToSimpleNameLikePredicate(System.String)" />
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeModel.Visibility">
      <summary>
            Represents the visibility of a <see cref="T:NDepend.CodeModel.IMember" /> object.
            </summary>
    </member>
    <member name="F:NDepend.CodeModel.Visibility.None">
      <summary>Visibility.None</summary>
    </member>
    <member name="F:NDepend.CodeModel.Visibility.Public">
      <summary>Visibility.Public</summary>
    </member>
    <member name="F:NDepend.CodeModel.Visibility.ProtectedAndInternal">
      <summary>Visibility.ProtectedAndInternal</summary>
    </member>
    <member name="F:NDepend.CodeModel.Visibility.ProtectedOrInternal">
      <summary>Visibility.ProtectedOrInternal</summary>
    </member>
    <member name="F:NDepend.CodeModel.Visibility.Internal">
      <summary>Visibility.Internal</summary>
    </member>
    <member name="F:NDepend.CodeModel.Visibility.Protected">
      <summary>Visibility.Protected</summary>
    </member>
    <member name="F:NDepend.CodeModel.Visibility.Private">
      <summary>Visibility.Private</summary>
    </member>
    <member name="T:NDepend.CodeQuery.ExtensionMethodsQuery">
      <summary>
            Exposes base operations concerning code query strings, compile and execute.
            </summary>
    </member>
    <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.CreateQueriesController(NDepend.CodeQuery.IGroupOfGroups)">
      <summary>
            Gets an instance of <see cref="T:NDepend.CodeQuery.IController" /> for this <paramref name="groupOfGroups" />.
            </summary>
      <param name="groupOfGroups">This group of groups for which a queries controller is created.</param>
      <exception cref="T:System.InvalidOperationException">
            To create a IController object, <paramref name="groupOfGroups" /> must be a top parent.
            <paramref name="groupOfGroups" />.<see cref="P:NDepend.CodeQuery.IGroupOfGroups.RootParent" /> is different that <paramref name="groupOfGroups" />.<br /></exception>
      <requires description="groupOfGroups must not be null" csharp="groupOfGroups != null" vb="groupOfGroups &lt;&gt; Nothing">groupOfGroups != null</requires>
      <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICodeBase)">
      <summary>
            Compile this code query string against a code base.
            </summary>
      <param name="queryString">This code query string.</param>
      <param name="codeBase">The code base against which to compile.</param>
      <remarks>
        <paramref name="codeBase" /> is needed because this code query might reference some code elements by name.</remarks>
      <returns>The code query compiled.</returns>
      <requires description="queryString must not be null" csharp="queryString != null" vb="queryString &lt;&gt; Nothing">queryString != null</requires>
      <requires description="codeBase must not be null" csharp="codeBase != null" vb="codeBase &lt;&gt; Nothing">codeBase != null</requires>
      <ensures description="returned query compiled is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)">
      <summary>
            Compile this code query string against a <see cref="T:NDepend.CodeModel.ICompareContext" /> object. This overload of <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICodeBase)" /> is required if the code query is meant to be executed in a comparison context.
            </summary>
      <param name="queryString">This code query string.</param>
      <param name="compareContext">The <see cref="T:NDepend.CodeModel.ICompareContext" /> object against which to compile.</param>
      <remarks>
            The <see cref="T:NDepend.CodeModel.ICompareContext" /> object is needed because the code query might reference some code elements by name.<br />
            In such situation, code elements are resolved by name agains the code base <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" />.<br />
            The property <see cref="T:NDepend.CodeQuery.IQueryCompiledSuccess" />.<see cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" /> is equal to true if a code query is meant to be executed in a comparison context.
            </remarks>
      <returns>This code query compiled.</returns>
      <seealso cref="T:NDepend.CodeModel.ICompareContext" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />
      <seealso cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare" />
      <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.ICollection{System.String},NDepend.CodeModel.ICompareContext)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceFileLine,NDepend.CodeModel.ISourceFileLine)" />
      <requires description="queryString must not be null" csharp="queryString != null" vb="queryString &lt;&gt; Nothing">queryString != null</requires>
      <requires description="compareContext must not be null" csharp="compareContext != null" vb="compareContext &lt;&gt; Nothing">compareContext != null</requires>
      <ensures description="returned query compiled is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.ICollection{System.String},NDepend.CodeModel.ICodeBase)">
      <summary>
            Compile against a code base, several code queries contained in this collection of string.
            </summary>
      <param name="queryStrings">This collection of code queries string.</param>
      <param name="codeBase">The code base against which to compile each query.</param>
      <remarks>
            The <paramref name="codeBase" /> is needed because a code query might reference some code elements by name.<br />
            To compile <i>N</i> CQLinq queries strings, calling once <i>CompileMany()</i> is much faster than calling <i>N</i> times <i>Compile()</i>.
            </remarks>
      <returns>A collection of code queries compiled, with a count equals to <paramref name="queryStrings" />.Count.</returns>
      <requires description="queryStrings must not be null" csharp="queryStrings != null" vb="queryStrings &lt;&gt; Nothing">queryStrings != null</requires>
      <requires description="codeBase must not be null" csharp="codeBase != null" vb="codeBase &lt;&gt; Nothing">codeBase != null</requires>
      <ensures description="returned collection of queries compiled is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures description="returned collection of queries compiled count is equal to queryStrings.Count" csharp="result.Count == queryStrings.Count" vb="result.Count = queryStrings.Count">result.Count == queryStrings.Count</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.ICollection{System.String},NDepend.CodeModel.ICompareContext)">
      <summary>
            Compile several code queries contained in this collection of string, against a <see cref="T:NDepend.CodeModel.ICompareContext" /> object. This overload of <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.ICollection{System.String},NDepend.CodeModel.ICodeBase)" /> is required if some code queries are meant to be executed in a comparison context.
            </summary>
      <param name="queryStrings">This collection of code queries string.</param>
      <param name="compareContext">The <see cref="T:NDepend.CodeModel.ICompareContext" /> object against which to compile.</param>
      <remarks>
            The <see cref="T:NDepend.CodeModel.ICompareContext" /> object is needed because some code queries might reference some code elements by name.<br />
            In such situation, code elements are resolved by name agains the code base ICompareContext.<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" />.<br />
            To compile <i>N</i> CQLinq queries strings, calling once <i>CompileMany()</i> is much faster than calling <i>N</i> times <i>Compile()</i>.<br />
            The property <see cref="T:NDepend.CodeQuery.IQueryCompiledSuccess" />.<see cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" /> is equal to true if a code query is meant to be executed in a comparison context.
            </remarks>
      <returns>A collection of code queries compiled, with a count equals to <paramref name="queryStrings" />.Count.</returns>
      <seealso cref="T:NDepend.CodeModel.ICompareContext" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />
      <seealso cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare" />
      <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceFileLine,NDepend.CodeModel.ISourceFileLine)" />
      <requires description="queryStrings must not be null" csharp="queryStrings != null" vb="queryStrings &lt;&gt; Nothing">queryStrings != null</requires>
      <requires description="compareContext must not be null" csharp="compareContext != null" vb="compareContext &lt;&gt; Nothing">compareContext != null</requires>
      <ensures description="returned collection of queries compiled is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures description="returned collection of queries compiled count is equal to queryStrings.Count" csharp="result.Count == queryStrings.Count" vb="result.Count = queryStrings.Count">result.Count == queryStrings.Count</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.Execute(NDepend.CodeQuery.IQueryCompiledSuccess)">
      <summary>
            Execute a code query compiled sucessfully.
            </summary>
      <remarks>
            The code base or the <see cref="T:NDepend.CodeModel.ICompareContext" /> object against which the query is executed, has been specified at compile time.<br />
            With this overload of <i>Execute</i>, just-my-code is the <see cref="T:NDepend.CodeModel.ICodeBase" />.<see cref="P:NDepend.CodeModel.ICodeBase.Application" /> specified at compile time.
            </remarks>
      <param name="queryCompiledSuccess">This code query compiled sucessfully.</param>
      <returns>The query execution result.</returns>
      <requires description="queryCompiledSuccess must not be null" csharp="queryCompiledSuccess != null" vb="queryCompiledSuccess &lt;&gt; Nothing">queryCompiledSuccess != null</requires>
      <ensures description="returned query execution result is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.Execute(NDepend.CodeQuery.IQueryCompiledSuccess,NDepend.CodeModel.ICodeBaseView)">
      <summary>
            Execute this code query compiled sucessfully, with <paramref name="justMyCode" /> defined.
            </summary>
      <remarks>
            The code base or the <see cref="T:NDepend.CodeModel.ICompareContext" /> object against which the query is executed, has been specified at compile time.
            </remarks>
      <param name="queryCompiledSuccess">This code query compiled sucessfully.</param>
      <param name="justMyCode">The code base view representing just-my-code, typically obtained through <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.ComputeJustMyCode(NDepend.CodeQuery.IGroupOfGroups,NDepend.CodeModel.ICodeBase)" />.</param>
      <returns>The query execution result.</returns>
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.ComputeJustMyCode(NDepend.CodeQuery.IGroupOfGroups,NDepend.CodeModel.ICodeBase)" />
      <requires description="queryCompiledSuccess must not be null" csharp="queryCompiledSuccess != null" vb="queryCompiledSuccess &lt;&gt; Nothing">queryCompiledSuccess != null</requires>
      <requires description="justMyCode must not be null" csharp="justMyCode != null" vb="justMyCode &lt;&gt; Nothing">justMyCode != null</requires>
      <requires description="for a CQLinq query, justMyCode.CodeBase must be equals to queryCompiledSuccess.CodeBaseOnWhichToExecute" csharp="queryCompiledSuccess.KindOfCodeQuerySyntax != (NDepend.CodeQuery.KindOfCodeQuerySyntax)1 || justMyCode.CodeBase == queryCompiledSuccess.CodeBaseOnWhichToExecute" vb="queryCompiledSuccess.KindOfCodeQuerySyntax &lt;&gt; ((NDepend.CodeQuery.KindOfCodeQuerySyntax)1) OrElse justMyCode.CodeBase = queryCompiledSuccess.CodeBaseOnWhichToExecute">queryCompiledSuccess.KindOfCodeQuerySyntax != (NDepend.CodeQuery.KindOfCodeQuerySyntax)1 || justMyCode.CodeBase == queryCompiledSuccess.CodeBaseOnWhichToExecute</requires>
      <ensures description="returned query execution result is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.Execute(NDepend.CodeQuery.IQueryCompiledSuccess,System.TimeSpan)">
      <summary>
            Execute his code query compiled sucessfully, with a time-out precised.
            </summary>
      <remarks>
            The code base or the <see cref="T:NDepend.CodeModel.ICompareContext" /> object against which the query is executed, has been specified at compile time.<br />
            With this overload of <i>Execute</i>, just-my-code is the <see cref="T:NDepend.CodeModel.ICodeBase" />.<see cref="P:NDepend.CodeModel.ICodeBase.Application" /> specified at compile time.
            </remarks>
      <param name="queryCompiledSuccess">This code query compiled sucessfully.</param>
      <param name="cqlinqQueryExecTimeOut">The time-out duration activated only for CQLinq queries, CQL queries being executed in a bounded short time.</param>
      <returns>The query execution result.</returns>
      <requires description="queryCompiledSuccess must not be null" csharp="queryCompiledSuccess != null" vb="queryCompiledSuccess &lt;&gt; Nothing">queryCompiledSuccess != null</requires>
      <requires description="cqlinqQueryExecTimeOut.Ticks must be greather than zero" csharp="cqlinqQueryExecTimeOut.Ticks &gt; (long)0" vb="cqlinqQueryExecTimeOut.Ticks &gt; ((Long )0)">cqlinqQueryExecTimeOut.Ticks &gt; (long)0</requires>
      <ensures description="returned query execution result is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.Execute(NDepend.CodeQuery.IQueryCompiledSuccess,NDepend.CodeModel.ICodeBaseView,System.TimeSpan)">
      <summary>
            Execute this code query compiled sucessfully, with <paramref name="justMyCode" /> defined and with a time out precised.
            </summary>
      <remarks>
            The code base or the <see cref="T:NDepend.CodeModel.ICompareContext" /> object against which the query is executed, has been specified at compile time.
            </remarks>
      <param name="queryCompiledSuccess">This code query compiled sucessfully.</param>
      <param name="justMyCode">The code base view representing just-my-code, typically obtained through <see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.ComputeJustMyCode(NDepend.CodeQuery.IGroupOfGroups,NDepend.CodeModel.ICodeBase)" />.</param>
      <param name="cqlinqQueryExecTimeOut">The time-out duration activated only for CQLinq queries, CQL queries being executed in a bounded short time.</param>
      <returns>The query execution result.</returns>
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.ComputeJustMyCode(NDepend.CodeQuery.IGroupOfGroups,NDepend.CodeModel.ICodeBase)" />
      <requires description="queryCompiledSuccess must not be null" csharp="queryCompiledSuccess != null" vb="queryCompiledSuccess &lt;&gt; Nothing">queryCompiledSuccess != null</requires>
      <requires description="justMyCode must not be null" csharp="justMyCode != null" vb="justMyCode &lt;&gt; Nothing">justMyCode != null</requires>
      <requires description="for a CQLinq query, justMyCode.CodeBase must be equals to queryCompiledSuccess.CodeBaseOnWhichToExecute" csharp="queryCompiledSuccess.KindOfCodeQuerySyntax != (NDepend.CodeQuery.KindOfCodeQuerySyntax)1 || justMyCode.CodeBase == queryCompiledSuccess.CodeBaseOnWhichToExecute" vb="queryCompiledSuccess.KindOfCodeQuerySyntax &lt;&gt; ((NDepend.CodeQuery.KindOfCodeQuerySyntax)1) OrElse justMyCode.CodeBase = queryCompiledSuccess.CodeBaseOnWhichToExecute">queryCompiledSuccess.KindOfCodeQuerySyntax != (NDepend.CodeQuery.KindOfCodeQuerySyntax)1 || justMyCode.CodeBase == queryCompiledSuccess.CodeBaseOnWhichToExecute</requires>
      <requires description="cqlinqQueryExecTimeOut.Ticks must be greather than zero" csharp="cqlinqQueryExecTimeOut.Ticks &gt; (long)0" vb="cqlinqQueryExecTimeOut.Ticks &gt; ((Long )0)">cqlinqQueryExecTimeOut.Ticks &gt; (long)0</requires>
      <ensures description="returned query execution result is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.ConvertToCQLinq(NDepend.CodeQuery.IQueryCompiledSuccess)">
      <summary>
            Convert this code query compiled sucessfully to a <i>CQLinq</i> query string. This method is useful to convert a query from the <i>CQL</i> syntax to the <i>CQLinq</i> syntax.
            </summary>
      <returns>
            A string containing the query converted to <i>CQLinq</i> syntax, if <paramref name="queryCompiledSuccess" /> is a <i>CQL</i> query compiled.<br /><paramref name="queryCompiledSuccess" />.<see cref="P:NDepend.CodeQuery.IQueryCompiled.OriginalQueryString" />, if <paramref name="queryCompiledSuccess" /> is a <i>CQLinq</i> query compiled.
            </returns>
      <param name="queryCompiledSuccess">This code query compiled sucessfully.</param>
      <requires description="queryCompiledSuccess must not be null" csharp="queryCompiledSuccess != null" vb="queryCompiledSuccess &lt;&gt; Nothing">queryCompiledSuccess != null</requires>
      <ensures description="returned code query string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.GetKindOfCodeQuerySyntax(System.String)">
      <summary>
            Determines this code query syntax, <i>CQLinq</i> or <i>CQL</i>, of a code query string.
            </summary>
      <remarks>
            An heuristic is used that determines the code query syntax of a code query string, even if the query is not compilable.
            </remarks>
      <param name="queryString">This code query string.</param>
      <returns>The code query syntax.</returns>
      <requires description="queryString must not be null" csharp="queryString != null" vb="queryString &lt;&gt; Nothing">queryString != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.ExtensionMethodsQuery.ComputeJustMyCode(NDepend.CodeQuery.IGroupOfGroups,NDepend.CodeModel.ICodeBase)">
      <summary>
            Computes and returns the set of <i>just-my-code</i> code elements from this <paramref name="groupOfGroups" /><i>CQLinq</i> queries with a <see cref="T:NDepend.CodeQuery.IQueryCompiled" />.<see cref="P:NDepend.CodeQuery.IQueryCompiled.KindOfCodeQueryExpression" /> equals to <see cref="F:NDepend.CodeQuery.KindOfCodeQueryExpression.NotMyCode" />.
            </summary>
      <param name="groupOfGroups">This set of code queries.</param>
      <param name="codeBase">The code base.</param>
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Execute(NDepend.CodeQuery.IQueryCompiledSuccess,NDepend.CodeModel.ICodeBaseView)" />
      <requires description="the groupOfGroups object must not be null" csharp="groupOfGroups != null" vb="groupOfGroups &lt;&gt; Nothing">groupOfGroups != null</requires>
      <requires description="the code base object must not be null" csharp="codeBase != null" vb="codeBase &lt;&gt; Nothing">codeBase != null</requires>
      <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:NDepend.CodeQuery.IQueryExecutionResult">
      <summary>
            Represents a code query execution result. To compile a code query string and then execute it, use a <see cref="T:NDepend.CodeQuery.ExtensionMethodsQuery" />.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryExecutionResult.Status">
      <summary>
            Gets a value indicating the status of this query execution result, <see cref="F:NDepend.CodeQuery.QueryExecutionStatus.Success" />, <see cref="F:NDepend.CodeQuery.QueryExecutionStatus.Exception" /> if an exception was thrown by the query execution, <see cref="F:NDepend.CodeQuery.QueryExecutionStatus.TimeOut" /> if the query execution timed out.
            </summary>
      <remarks>
            If <see cref="F:NDepend.CodeQuery.QueryExecutionStatus.Success" /> is returned then <see cref="P:NDepend.CodeQuery.IQueryExecutionResult.SuccessResult" /> is not <i>null</i> and <see cref="P:NDepend.CodeQuery.IQueryExecutionResult.Exception" /> is <i>null</i>.<br />
            If <see cref="F:NDepend.CodeQuery.QueryExecutionStatus.Exception" /> is returned then <see cref="P:NDepend.CodeQuery.IQueryExecutionResult.SuccessResult" /> is <i>null</i> and <see cref="P:NDepend.CodeQuery.IQueryExecutionResult.Exception" /> is not <i>null</i>.<br />
            If <see cref="F:NDepend.CodeQuery.QueryExecutionStatus.TimeOut" /> is returned then <see cref="P:NDepend.CodeQuery.IQueryExecutionResult.SuccessResult" /> and <see cref="P:NDepend.CodeQuery.IQueryExecutionResult.Exception" /> are both <i>null</i>.<br /></remarks>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryExecutionResult.SuccessResult">
      <summary>
            Gets the <see cref="T:NDepend.CodeQuery.IQueryExecutionSuccessResult" /> object if <see cref="P:NDepend.CodeQuery.IQueryExecutionResult.Status" /> is <i>true</i>, else gets <i>null</i>.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryExecutionResult.Exception">
      <summary>
            Gets the exception object thrown by the query execution if any, else gets <i>null</i>.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryExecutionResult.ExecutionDuration">
      <summary>
            Gets the query execution duration.
            </summary>
      <getter>
        <ensures description="returned time duration is positive or zero" csharp="result.Ticks &gt;= (long)0" vb="result.Ticks &gt;= ((Long )0)">result.Ticks &gt;= (long)0</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.QueryExecutionStatus">
      <summary>
            Define the <see cref="T:NDepend.CodeQuery.IQueryExecutionResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionResult.Status" />.
            </summary>
    </member>
    <member name="F:NDepend.CodeQuery.QueryExecutionStatus.Success">
      <summary>Success</summary>
    </member>
    <member name="F:NDepend.CodeQuery.QueryExecutionStatus.Exception">
      <summary>Exception</summary>
    </member>
    <member name="F:NDepend.CodeQuery.QueryExecutionStatus.TimeOut">
      <summary>TimeOut</summary>
    </member>
    <member name="T:NDepend.DotNet.DotNetProfile">
      <summary>
            Represents a .NET Framework profile.
            </summary>
    </member>
    <member name="F:NDepend.DotNet.DotNetProfile.DotNetFramework">
      <summary>DotNetFramework</summary>
    </member>
    <member name="F:NDepend.DotNet.DotNetProfile.WinRT">
      <summary>WinRT</summary>
    </member>
    <member name="F:NDepend.DotNet.DotNetProfile.Silverlight">
      <summary>Silverlight</summary>
    </member>
    <member name="F:NDepend.DotNet.DotNetProfile.AspNetMvc">
      <summary>AspNetMvc</summary>
    </member>
    <member name="T:NDepend.Helpers.ExtensionMethodsEnumerable">
      <summary>
            Provides a set of extension methods dedicated to enumerables. 
            </summary>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.ToEnumerable``1(``0)">
      <summary>
            Gets an enumerable object that contains only the single element <paramref name="element" />.
            </summary>
      <typeparam name="TElement">The type of <paramref name="element" />.</typeparam>
      <param name="element">The single element in the returned enumerable.</param>
      <ensures description="returned enumerable object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.ToMultiKeyLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Creates a <see cref="T:System.Linq.Lookup`2" /> from an <see cref="T:System.Collections.Generic.IEnumerable`1" /> according to a specified key selector function. <b>The funtion can return zero, one or several keys for an element.</b>.
            </summary>
      <remarks>
            The difference with <seealso cref="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" /> is that an element can have zero, one or several keys.<br />
            Hence an element can be contained in several groups, if it has several keys.
            </remarks>
      <typeparam name="T">The type of the elements of <paramref name="seq" />.</typeparam>
      <typeparam name="TKey">The type of the keys in the result <see cref="T:System.Linq.Lookup`2" />.</typeparam>
      <param name="seq">An <i>IEnumerable&lt;T&gt;</i> to create an hashset from.</param>
      <param name="func">A function to extract a sequence of keys from each element.</param>
      <returns>An hashset that contains the elements from the input sequence.</returns>
      <seealso cref="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="func must not be null" csharp="func != null" vb="func &lt;&gt; Nothing">func != null</requires>
      <ensures description="returned lookup object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.TryAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
      <summary>
            Add a pair of <paramref name="key" /> and <paramref name="value" /> to <paramref name="dico" />, only if <paramref name="dico" /> doesn't already contain the <paramref name="key" />.
            </summary>
      <returns>
        <i>false</i> if the <paramref name="dico" /> already contains the <paramref name="key" />. Else add the pair <paramref name="key" /> and <paramref name="value" /> and returns <i>true</i>.</returns>
      <param name="dico">This dictionary.</param>
      <param name="key">The key.</param>
      <param name="value">The value.</param>
      <requires description="dico must not be null" csharp="dico != null" vb="dico &lt;&gt; Nothing">dico != null</requires>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.Except``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            Produces the set <paramref name="seq" /> excluding <paramref name="elementExcluded" />. The equality test relies on the <i>Equals()</i> method.
            </summary>
      <typeparam name="T">The element type.</typeparam>
      <param name="seq">A sequence of elements.</param>
      <param name="elementExcluded">The element excluded.</param>
      <returns>A sequence that contains the set difference of the elements of <paramref name="seq" /> minus <paramref name="elementExcluded" />.</returns>
      <remarks>This extension method has a <i>constant</i> time complexity.</remarks>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            Append <paramref name="element" /> at the end of <paramref name="seq" />.
            </summary>
      <typeparam name="T">The element type.</typeparam>
      <param name="seq">A sequence of elements.</param>
      <param name="element">The element to append.</param>
      <remarks>This extension method has a <i>constant</i> time complexity.</remarks>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0,``0)">
      <summary>
            Append <paramref name="element1" /> and <paramref name="element1" /> at the end of <paramref name="seq" />.
            </summary>
      <typeparam name="T">The element type.</typeparam>
      <param name="seq">A sequence of elements.</param>
      <param name="element1">The element to append first.</param>
      <param name="element2">The element to append after <paramref name="element1" />.</param>
      <remarks>This extension method has a <i>constant</i> time complexity.</remarks>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0,``0,``0)">
      <summary>
            Append <paramref name="element1" />, <paramref name="element2" /> and <paramref name="element3" /> at the end of <paramref name="seq" />.
            </summary>
      <remarks>To append more than 3 elements to <paramref name="seq" />, use the <i>.Concat(new [] { a, b, c, d ... } )</i> syntax.</remarks>
      <typeparam name="T">The element type.</typeparam>
      <param name="seq">A sequence of elements.</param>
      <param name="element1">The element to append first.</param>
      <param name="element2">The element to append after <paramref name="element1" />.</param>
      <param name="element3">The element to append after <paramref name="element2" />.</param>
      <remarks>This extension method has a <i>constant</i> time complexity.</remarks>
    </member>
    <member name="T:NDepend.Helpers.ExtensionMethodsSet">
      <summary>
            Provides a set of extension methods to optimize enumerables operations on set.
            </summary>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsSet.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Creates an hashset from a <i>IEnumerable&lt;T&gt;</i>.
            </summary>
      <typeparam name="T">The type of the elements of <paramref name="seq" />.</typeparam>
      <param name="seq">An <i>IEnumerable&lt;T&gt;</i> to create an hashset from.</param>
      <returns>An hashset that contains the elements from the input sequence.</returns>
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <ensures description="returned hashset object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsSet.Intersect``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Produces the set of elements, intersection of this <paramref name="hashset" /> and <paramref name="seq" />. This method is an optimized version of <i>Enumerable.Intersect&lt;T&gt;</i>.
            </summary>
      <typeparam name="T">The code element type of the elements of the hashset and the sequence.</typeparam>
      <param name="hashset">An hashset of elements whose distinct elements that also appear in <paramref name="seq" /> will be returned.</param>
      <param name="seq">A sequence of elements whose distinct elements that also appear in <paramref name="hashset" /> will be returned.</param>
      <returns>A sequence that contains the elements that form the set intersection of the hashset and the sequence.</returns>
      <remarks>This extension method has a <i>O(<paramref name="seq" />.Count)</i> time complexity.</remarks>
      <requires description="hashset must not be null" csharp="hashset != null" vb="hashset &lt;&gt; Nothing">hashset != null</requires>
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsSet.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.HashSet{``0})">
      <summary>
            Produces the set of elements, intersection of this <paramref name="seq" /> and <paramref name="hashset" />. This method is an optimized version of <i>Enumerable.Intersect&lt;T&gt;</i>.
            </summary>
      <typeparam name="T">The code element type of the elements of the hashset and the sequence.</typeparam>
      <param name="hashset">An hashset of elements whose distinct elements that also appear in <paramref name="seq" /> will be returned.</param>
      <param name="seq">A sequence of elements whose distinct elements that also appear in <paramref name="hashset" /> will be returned.</param>
      <returns>A sequence that contains the elements that form the set intersection of the hashset and the sequence.</returns>
      <remarks>This extension method has a <i>O(<paramref name="seq" />.Count)</i> time complexity.</remarks>
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="hashset must not be null" csharp="hashset != null" vb="hashset &lt;&gt; Nothing">hashset != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsSet.Intersect``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.HashSet{``0})">
      <summary>
            Produces the set of elements, intersection of this <paramref name="hashset" /> and <paramref name="otherHashset" />. This method is an optimized version of <i>Enumerable.Intersect&lt;T&gt;</i>.
            </summary>
      <typeparam name="T">The code element type of the elements of the hashset and the sequence.</typeparam>
      <param name="hashset">An hashset of elements whose distinct elements that also appear in <paramref name="otherHashset" /> will be returned.</param>
      <param name="otherHashset">An hashset of elements whose distinct elements that also appear in <paramref name="hashset" /> will be returned.</param>
      <returns>A sequence that contains the elements that form the set intersection of both hashsets.</returns>
      <remarks>This extension method has a <i>O(<paramref name="otherHashset" />.Count)</i> time complexity.</remarks>
      <requires description="hashset must not be null" csharp="hashset != null" vb="hashset &lt;&gt; Nothing">hashset != null</requires>
      <requires description="otherHashset must not be null" csharp="otherHashset != null" vb="otherHashset &lt;&gt; Nothing">otherHashset != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsSet.Union``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Produces the set of elements, union of this <paramref name="hashset" /> and <paramref name="seq" />. This method is an optimized version of <i>Enumerable.Union&lt;T&gt;</i>.
            </summary>
      <typeparam name="T">The code element type of the elements of the hashset and the sequence.</typeparam>
      <param name="hashset">An hashset of elements whose distinct elements form the first set for the union.</param>
      <param name="seq">A sequence of elements whose distinct elements form the second set for the union.</param>
      <returns>A sequence that contains the elements that form the set union of the hashset and the sequence, excluding duplicates.</returns>
      <remarks>This extension method has a <i>O(<paramref name="seq" />.Count)</i> time complexity.</remarks>
      <requires description="hashset must not be null" csharp="hashset != null" vb="hashset &lt;&gt; Nothing">hashset != null</requires>
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsSet.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.HashSet{``0})">
      <summary>
            Produces the set of elements, union of this <paramref name="seq" /> and <paramref name="hashset" />. This method is an optimized version of <i>Enumerable.Union&lt;T&gt;</i>.
            </summary>
      <typeparam name="T">The code element type of the elements of the hashset and the sequence.</typeparam>
      <param name="hashset">An hashset of elements whose distinct elements form the first set for the union.</param>
      <param name="seq">A sequence of elements whose distinct elements form the second set for the union.</param>
      <returns>A sequence that contains the elements that form the set union of the sequence and the hashset, excluding duplicates.</returns>
      <remarks>This extension method has a <i>O(<paramref name="seq" />.Count)</i> time complexity.</remarks>
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="hashset must not be null" csharp="hashset != null" vb="hashset &lt;&gt; Nothing">hashset != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsSet.Union``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.HashSet{``0})">
      <summary>
            Produces the set of elements, union of this <paramref name="thisHashset" /> and <paramref name="otherHashset" />. This method is an optimized version of <i>Enumerable.Union&lt;T&gt;</i>.
            </summary>
      <typeparam name="T">The code element type of the elements of the hashset and the sequence.</typeparam>
      <param name="thisHashset">A sequence of elements whose distinct elements form the first set for the union.</param>
      <param name="otherHashset">An hashset of elements whose distinct elements form the second set for the union.</param>
      <returns>A sequence that contains the elements that form the set union of both hashsets, excluding duplicates.</returns>
      <remarks>This extension method has a <i>O(<paramref name="otherHashset" />.Count)</i> time complexity.</remarks>
      <requires description="hashset must not be null" csharp="thisHashset != null" vb="thisHashset &lt;&gt; Nothing">thisHashset != null</requires>
      <requires description="otherHashset must not be null" csharp="otherHashset != null" vb="otherHashset &lt;&gt; Nothing">otherHashset != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsSet.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.HashSet{``0})">
      <summary>
            Produces the set difference of this <paramref name="seq" /> and <paramref name="hashset" />. This method is an optimized version of <i>Enumerable.Except&lt;T&gt;</i>.
            </summary>
      <typeparam name="T">The element type of the elements of the hashset and the sequence.</typeparam>
      <param name="seq">A sequence of elements whose elements that are not also in <paramref name="hashset" /> will be returned.</param>
      <param name="hashset">An hashset of elements whose elements that also occur in <paramref name="seq" /> will cause those elements to be removed from the returned sequence.</param>
      <returns>A sequence that contains the set difference of the elements of <paramref name="seq" /> and <paramref name="hashset" />.</returns>
      <remarks>This extension method has a <i>O(<paramref name="seq" />.Count)</i> time complexity.</remarks>
    </member>
    <member name="T:NDepend.Helpers.ExtensionMethodsString">
      <summary>
            Provides a set of extension methods dedicated to strings. 
            </summary>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsString.EqualsAny(System.String,System.String,System.String)">
      <summary>Gets a value indicating whether this string is equal <i>case sensitive</i> to any of the strings specified.</summary>
      <param name="thisString">This string.</param>
      <param name="str0">One of the possible value for <paramref name="thisString" />.</param>
      <param name="str1">One of the possible value for <paramref name="thisString" />.</param>
      <requires description="str must not be null" csharp="thisString != null" vb="thisString &lt;&gt; Nothing">thisString != null</requires>
      <requires description="str0 must not be null" csharp="str0 != null" vb="str0 &lt;&gt; Nothing">str0 != null</requires>
      <requires description="str1 must not be null" csharp="str1 != null" vb="str1 &lt;&gt; Nothing">str1 != null</requires>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsString.EqualsAny(System.String,System.String,System.String,System.String)">
      <summary>Gets a value indicating whether this string is equal <i>case sensitive</i> to any of the strings specified.</summary>
      <param name="thisString">This string.</param>
      <param name="str0">One of the possible value for <paramref name="thisString" />.</param>
      <param name="str1">One of the possible value for <paramref name="thisString" />.</param>
      <param name="str2">One of the possible value for <paramref name="thisString" />.</param>
      <requires description="str must not be null" csharp="thisString != null" vb="thisString &lt;&gt; Nothing">thisString != null</requires>
      <requires description="str0 must not be null" csharp="str0 != null" vb="str0 &lt;&gt; Nothing">str0 != null</requires>
      <requires description="str1 must not be null" csharp="str1 != null" vb="str1 &lt;&gt; Nothing">str1 != null</requires>
      <requires description="str2 must not be null" csharp="str2 != null" vb="str2 &lt;&gt; Nothing">str2 != null</requires>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsString.EqualsAny(System.String,System.String,System.String,System.String,System.String)">
      <summary>Gets a value indicating whether this string is equal <i>case sensitive</i> to any of the strings specified.</summary>
      <param name="thisString">This string.</param>
      <param name="str0">One of the possible value for <paramref name="thisString" />.</param>
      <param name="str1">One of the possible value for <paramref name="thisString" />.</param>
      <param name="str2">One of the possible value for <paramref name="thisString" />.</param>
      <param name="str3">One of the possible value for <paramref name="thisString" />.</param>
      <requires description="str must not be null" csharp="thisString != null" vb="thisString &lt;&gt; Nothing">thisString != null</requires>
      <requires description="str0 must not be null" csharp="str0 != null" vb="str0 &lt;&gt; Nothing">str0 != null</requires>
      <requires description="str1 must not be null" csharp="str1 != null" vb="str1 &lt;&gt; Nothing">str1 != null</requires>
      <requires description="str2 must not be null" csharp="str2 != null" vb="str2 &lt;&gt; Nothing">str2 != null</requires>
      <requires description="str3 must not be null" csharp="str3 != null" vb="str3 &lt;&gt; Nothing">str3 != null</requires>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsString.EqualsAny(System.String,System.String,System.String,System.String,System.String,System.String)">
      <summary>Gets a value indicating whether this string is equal <i>case sensitive</i> to any of the strings specified.</summary>
      <param name="thisString">This string.</param>
      <param name="str0">One of the possible value for <paramref name="thisString" />.</param>
      <param name="str1">One of the possible value for <paramref name="thisString" />.</param>
      <param name="str2">One of the possible value for <paramref name="thisString" />.</param>
      <param name="str3">One of the possible value for <paramref name="thisString" />.</param>
      <param name="str4">One of the possible value for <paramref name="thisString" />.</param>
      <requires description="str must not be null" csharp="thisString != null" vb="thisString &lt;&gt; Nothing">thisString != null</requires>
      <requires description="str0 must not be null" csharp="str0 != null" vb="str0 &lt;&gt; Nothing">str0 != null</requires>
      <requires description="str1 must not be null" csharp="str1 != null" vb="str1 &lt;&gt; Nothing">str1 != null</requires>
      <requires description="str2 must not be null" csharp="str2 != null" vb="str2 &lt;&gt; Nothing">str2 != null</requires>
      <requires description="str3 must not be null" csharp="str3 != null" vb="str3 &lt;&gt; Nothing">str3 != null</requires>
      <requires description="str4 must not be null" csharp="str4 != null" vb="str4 &lt;&gt; Nothing">str4 != null</requires>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsString.EqualsAny(System.String,System.String,System.String,System.String,System.String,System.String,System.String[])">
      <summary>Gets a value indicating whether this string is equal <i>case sensitive</i> to any of the strings specified.</summary>
      <param name="thisString">This string.</param>
      <param name="str0">One of the possible value for <paramref name="thisString" />.</param>
      <param name="str1">One of the possible value for <paramref name="thisString" />.</param>
      <param name="str2">One of the possible value for <paramref name="thisString" />.</param>
      <param name="str3">One of the possible value for <paramref name="thisString" />.</param>
      <param name="str4">One of the possible value for <paramref name="thisString" />.</param>
      <param name="array">An array containing possible values for <paramref name="thisString" />.</param>
      <requires description="str must not be null" csharp="thisString != null" vb="thisString &lt;&gt; Nothing">thisString != null</requires>
      <requires description="str0 must not be null" csharp="str0 != null" vb="str0 &lt;&gt; Nothing">str0 != null</requires>
      <requires description="str1 must not be null" csharp="str1 != null" vb="str1 &lt;&gt; Nothing">str1 != null</requires>
      <requires description="str2 must not be null" csharp="str2 != null" vb="str2 &lt;&gt; Nothing">str2 != null</requires>
      <requires description="str3 must not be null" csharp="str3 != null" vb="str3 &lt;&gt; Nothing">str3 != null</requires>
      <requires description="str4 must not be null" csharp="str4 != null" vb="str4 &lt;&gt; Nothing">str4 != null</requires>
      <requires description="strs must not be null" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsString.EqualsAny(System.String,System.Collections.Generic.HashSet{System.String})">
      <summary>Gets a value indicating whether <paramref name="hashset" /> contains the string <paramref name="thisString" />.</summary>
      <remarks>This <see cref="M:NDepend.Helpers.ExtensionMethodsString.EqualsAny(System.String,System.String,System.String)" /> overload can be used to check the value of <paramref name="thisString" /> against a large number of strings, in a constant time.</remarks>
      <param name="thisString">This string.</param>
      <param name="hashset">An hashset containg possible values for this <paramref name="thisString" />.</param>
      <requires description="str must not be null" csharp="thisString != null" vb="thisString &lt;&gt; Nothing">thisString != null</requires>
      <requires description="hashset must not be null" csharp="hashset != null" vb="hashset &lt;&gt; Nothing">hashset != null</requires>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsString.StartsWithAny(System.String,System.String,System.String)">
      <summary>Gets a value indicating whether this string starts with <i>case sensitive</i> to any of the strings specified.</summary>
      <param name="thisString">This string.</param>
      <param name="str0">One of the possible start string for <paramref name="thisString" />.</param>
      <param name="str1">One of the possible start string for <paramref name="thisString" />.</param>
      <requires description="str must not be null" csharp="thisString != null" vb="thisString &lt;&gt; Nothing">thisString != null</requires>
      <requires description="str0 must not be null" csharp="str0 != null" vb="str0 &lt;&gt; Nothing">str0 != null</requires>
      <requires description="str1 must not be null" csharp="str1 != null" vb="str1 &lt;&gt; Nothing">str1 != null</requires>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsString.StartsWithAny(System.String,System.String,System.String,System.String)">
      <summary>Gets a value indicating whether this string starts with <i>case sensitive</i> to any of the strings specified.</summary>
      <param name="thisString">This string.</param>
      <param name="str0">One of the possible start string for <paramref name="thisString" />.</param>
      <param name="str1">One of the possible start string for <paramref name="thisString" />.</param>
      <param name="str2">One of the possible start string for <paramref name="thisString" />.</param>
      <requires description="str must not be null" csharp="thisString != null" vb="thisString &lt;&gt; Nothing">thisString != null</requires>
      <requires description="str0 must not be null" csharp="str0 != null" vb="str0 &lt;&gt; Nothing">str0 != null</requires>
      <requires description="str1 must not be null" csharp="str1 != null" vb="str1 &lt;&gt; Nothing">str1 != null</requires>
      <requires description="str2 must not be null" csharp="str2 != null" vb="str2 &lt;&gt; Nothing">str2 != null</requires>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsString.StartsWithAny(System.String,System.String,System.String,System.String,System.String)">
      <summary>Gets a value indicating whether this string starts with <i>case sensitive</i> to any of the strings specified.</summary>
      <param name="thisString">This string.</param>
      <param name="str0">One of the possible start string for <paramref name="thisString" />.</param>
      <param name="str1">One of the possible start string for <paramref name="thisString" />.</param>
      <param name="str2">One of the possible start string for <paramref name="thisString" />.</param>
      <param name="str3">One of the possible start string for <paramref name="thisString" />.</param>
      <requires description="str must not be null" csharp="thisString != null" vb="thisString &lt;&gt; Nothing">thisString != null</requires>
      <requires description="str0 must not be null" csharp="str0 != null" vb="str0 &lt;&gt; Nothing">str0 != null</requires>
      <requires description="str1 must not be null" csharp="str1 != null" vb="str1 &lt;&gt; Nothing">str1 != null</requires>
      <requires description="str2 must not be null" csharp="str2 != null" vb="str2 &lt;&gt; Nothing">str2 != null</requires>
      <requires description="str3 must not be null" csharp="str3 != null" vb="str3 &lt;&gt; Nothing">str3 != null</requires>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsString.StartsWithAny(System.String,System.String,System.String,System.String,System.String,System.String)">
      <summary>Gets a value indicating whether this string starts with <i>case sensitive</i> to any of the strings specified.</summary>
      <param name="thisString">This string.</param>
      <param name="str0">One of the possible start string for <paramref name="thisString" />.</param>
      <param name="str1">One of the possible start string for <paramref name="thisString" />.</param>
      <param name="str2">One of the possible start string for <paramref name="thisString" />.</param>
      <param name="str3">One of the possible start string for <paramref name="thisString" />.</param>
      <param name="str4">One of the possible start string for <paramref name="thisString" />.</param>
      <requires description="str must not be null" csharp="thisString != null" vb="thisString &lt;&gt; Nothing">thisString != null</requires>
      <requires description="str0 must not be null" csharp="str0 != null" vb="str0 &lt;&gt; Nothing">str0 != null</requires>
      <requires description="str1 must not be null" csharp="str1 != null" vb="str1 &lt;&gt; Nothing">str1 != null</requires>
      <requires description="str2 must not be null" csharp="str2 != null" vb="str2 &lt;&gt; Nothing">str2 != null</requires>
      <requires description="str3 must not be null" csharp="str3 != null" vb="str3 &lt;&gt; Nothing">str3 != null</requires>
      <requires description="str4 must not be null" csharp="str4 != null" vb="str4 &lt;&gt; Nothing">str4 != null</requires>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsString.StartsWithAny(System.String,System.String,System.String,System.String,System.String,System.String,System.String[])">
      <summary>Gets a value indicating whether this string starts with <i>case sensitive</i> to any of the strings specified.</summary>
      <param name="thisString">This string.</param>
      <param name="str0">One of the possible start string for <paramref name="thisString" />.</param>
      <param name="str1">One of the possible start string for <paramref name="thisString" />.</param>
      <param name="str2">One of the possible start string for <paramref name="thisString" />.</param>
      <param name="str3">One of the possible start string for <paramref name="thisString" />.</param>
      <param name="str4">One of the possible start string for <paramref name="thisString" />.</param>
      <param name="array">An array containing possible start strings for <paramref name="thisString" />.</param>
      <exception cref="T:System.NullReferenceException">null string reference in <paramref name="array" /> not accepted.</exception>
      <requires description="str must not be null" csharp="thisString != null" vb="thisString &lt;&gt; Nothing">thisString != null</requires>
      <requires description="str0 must not be null" csharp="str0 != null" vb="str0 &lt;&gt; Nothing">str0 != null</requires>
      <requires description="str1 must not be null" csharp="str1 != null" vb="str1 &lt;&gt; Nothing">str1 != null</requires>
      <requires description="str2 must not be null" csharp="str2 != null" vb="str2 &lt;&gt; Nothing">str2 != null</requires>
      <requires description="str3 must not be null" csharp="str3 != null" vb="str3 &lt;&gt; Nothing">str3 != null</requires>
      <requires description="str4 must not be null" csharp="str4 != null" vb="str4 &lt;&gt; Nothing">str4 != null</requires>
      <requires description="strs must not be null" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsString.EndsWithAny(System.String,System.String,System.String)">
      <summary>Gets a value indicating whether this string ends with <i>case sensitive</i> to any of the strings specified.</summary>
      <param name="thisString">This string.</param>
      <param name="str0">One of the possible end string for <paramref name="thisString" />.</param>
      <param name="str1">One of the possible end string for <paramref name="thisString" />.</param>
      <requires description="str must not be null" csharp="thisString != null" vb="thisString &lt;&gt; Nothing">thisString != null</requires>
      <requires description="str0 must not be null" csharp="str0 != null" vb="str0 &lt;&gt; Nothing">str0 != null</requires>
      <requires description="str1 must not be null" csharp="str1 != null" vb="str1 &lt;&gt; Nothing">str1 != null</requires>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsString.EndsWithAny(System.String,System.String,System.String,System.String)">
      <summary>Gets a value indicating whether this string ends with <i>case sensitive</i> to any of the strings specified.</summary>
      <param name="thisString">This string.</param>
      <param name="str0">One of the possible end string for <paramref name="thisString" />.</param>
      <param name="str1">One of the possible end string for <paramref name="thisString" />.</param>
      <param name="str2">One of the possible end string for <paramref name="thisString" />.</param>
      <requires description="str must not be null" csharp="thisString != null" vb="thisString &lt;&gt; Nothing">thisString != null</requires>
      <requires description="str0 must not be null" csharp="str0 != null" vb="str0 &lt;&gt; Nothing">str0 != null</requires>
      <requires description="str1 must not be null" csharp="str1 != null" vb="str1 &lt;&gt; Nothing">str1 != null</requires>
      <requires description="str2 must not be null" csharp="str2 != null" vb="str2 &lt;&gt; Nothing">str2 != null</requires>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsString.EndsWithAny(System.String,System.String,System.String,System.String,System.String)">
      <summary>Gets a value indicating whether this string ends with <i>case sensitive</i> to any of the strings specified.</summary>
      <param name="thisString">This string.</param>
      <param name="str0">One of the possible end string for <paramref name="thisString" />.</param>
      <param name="str1">One of the possible end string for <paramref name="thisString" />.</param>
      <param name="str2">One of the possible end string for <paramref name="thisString" />.</param>
      <param name="str3">One of the possible end string for <paramref name="thisString" />.</param>
      <requires description="str must not be null" csharp="thisString != null" vb="thisString &lt;&gt; Nothing">thisString != null</requires>
      <requires description="str0 must not be null" csharp="str0 != null" vb="str0 &lt;&gt; Nothing">str0 != null</requires>
      <requires description="str1 must not be null" csharp="str1 != null" vb="str1 &lt;&gt; Nothing">str1 != null</requires>
      <requires description="str2 must not be null" csharp="str2 != null" vb="str2 &lt;&gt; Nothing">str2 != null</requires>
      <requires description="str3 must not be null" csharp="str3 != null" vb="str3 &lt;&gt; Nothing">str3 != null</requires>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsString.EndsWithAny(System.String,System.String,System.String,System.String,System.String,System.String)">
      <summary>Gets a value indicating whether this string ends with <i>case sensitive</i> to any of the strings specified.</summary>
      <param name="thisString">This string.</param>
      <param name="str0">One of the possible end string for <paramref name="thisString" />.</param>
      <param name="str1">One of the possible end string for <paramref name="thisString" />.</param>
      <param name="str2">One of the possible end string for <paramref name="thisString" />.</param>
      <param name="str3">One of the possible end string for <paramref name="thisString" />.</param>
      <param name="str4">One of the possible end string for <paramref name="thisString" />.</param>
      <requires description="str must not be null" csharp="thisString != null" vb="thisString &lt;&gt; Nothing">thisString != null</requires>
      <requires description="str0 must not be null" csharp="str0 != null" vb="str0 &lt;&gt; Nothing">str0 != null</requires>
      <requires description="str1 must not be null" csharp="str1 != null" vb="str1 &lt;&gt; Nothing">str1 != null</requires>
      <requires description="str2 must not be null" csharp="str2 != null" vb="str2 &lt;&gt; Nothing">str2 != null</requires>
      <requires description="str3 must not be null" csharp="str3 != null" vb="str3 &lt;&gt; Nothing">str3 != null</requires>
      <requires description="str4 must not be null" csharp="str4 != null" vb="str4 &lt;&gt; Nothing">str4 != null</requires>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsString.EndsWithAny(System.String,System.String,System.String,System.String,System.String,System.String,System.String[])">
      <summary>Gets a value indicating whether this string ends with <i>case sensitive</i> to any of the strings specified.</summary>
      <param name="thisString">This string.</param>
      <param name="str0">One of the possible end string for <paramref name="thisString" />.</param>
      <param name="str1">One of the possible end string for <paramref name="thisString" />.</param>
      <param name="str2">One of the possible end string for <paramref name="thisString" />.</param>
      <param name="str3">One of the possible end string for <paramref name="thisString" />.</param>
      <param name="str4">One of the possible end string for <paramref name="thisString" />.</param>
      <param name="array">An array containing possible end strings for <paramref name="thisString" />.</param>
      <exception cref="T:System.NullReferenceException">null string reference in <paramref name="array" /> not accepted.</exception>
      <requires description="str must not be null" csharp="thisString != null" vb="thisString &lt;&gt; Nothing">thisString != null</requires>
      <requires description="str0 must not be null" csharp="str0 != null" vb="str0 &lt;&gt; Nothing">str0 != null</requires>
      <requires description="str1 must not be null" csharp="str1 != null" vb="str1 &lt;&gt; Nothing">str1 != null</requires>
      <requires description="str2 must not be null" csharp="str2 != null" vb="str2 &lt;&gt; Nothing">str2 != null</requires>
      <requires description="str3 must not be null" csharp="str3 != null" vb="str3 &lt;&gt; Nothing">str3 != null</requires>
      <requires description="str4 must not be null" csharp="str4 != null" vb="str4 &lt;&gt; Nothing">str4 != null</requires>
      <requires description="strs must not be null" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
    </member>
    <member name="T:NDepend.Reserved.Linq.CodeQueryProvider">
      <summary>This class is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="T:NDepend.Reserved.Linq.QueryProviderBase">
      <summary>This abstract class is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="M:NDepend.Reserved.Linq.QueryProviderBase.#ctor">
      <summary>This constructor is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="M:NDepend.Reserved.Linq.QueryProviderBase.GetQueryText(System.Linq.Expressions.Expression)">
      <summary>This method is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="M:NDepend.Reserved.Linq.QueryProviderBase.Execute(System.Linq.Expressions.Expression)">
      <summary>This method is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="M:NDepend.Reserved.Linq.CodeQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>This method is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
      <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Reserved.Linq.CodeQueryProvider.GetQueryText(System.Linq.Expressions.Expression)">
      <summary>This method is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.Linq.CodeQueryProvider.Instance">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare">
      <summary>
            Presents extension methods on code elements, that provide a syntax friendly way to specify diff actions in CQLinq rules queries.
            </summary>
      <remarks>
        <b>These extension methods exist for CQLinq friendly syntax reasons</b> and can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />.<br />
            Indeed they all rely on a hidden <see cref="T:NDepend.CodeModel.ICompareContext" /> object, hidden in CQLinq queries. This results in less syntax burden.<br />
            At CQLinq compilation time, the CQLinq compiler takes care of transforming calls to these extension methods into calls to methods of a <see cref="T:NDepend.CodeModel.ICompareContext" /> object.<br />
            Indeed each of these extension methods, has an equivalent method defined by <see cref="T:NDepend.CodeModel.ICompareContext" />, that can be called from a program that consumes NDepend.API.
            </remarks>
      <seealso cref="T:NDepend.CodeModel.ICompareContext" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />
      <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)" />
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.ICollection{System.String},NDepend.CodeModel.ICompareContext)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceFileLine,NDepend.CodeModel.ISourceFileLine)" />
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.NewerVersion``1(NDepend.CodeModel.ICodeNode{``0})">
      <summary>
            Returns the newer version of this <paramref name="codeNode" /> object. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(NDepend.CodeModel.ICodeNode{``0})" /> must be called instead.
            </summary>
      <remarks>
            If this code element is already the newer version, returns this code element.<br />
            If this code element has been removed and has no corresponding newer version, returns null.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.<br /></remarks>
      <typeparam name="T">
        <i>T</i> is the closed <see cref="T:NDepend.CodeModel.ICodeNode`1" /> generic type, like in <i>ICodeNode&lt;IMethod&gt;</i> or <i>ICodeNode&lt;ICodeBase&gt;</i> for example.</typeparam>
      <param name="codeNode">This <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object. A <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object.</param>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(NDepend.CodeModel.ICodeNode{``0})" /> must be called instead.</exception>
      <requires description="this codeNode object must not be null" csharp="codeNode != null" vb="codeNode &lt;&gt; Nothing">codeNode != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.OlderVersion``1(NDepend.CodeModel.ICodeNode{``0})">
      <summary>
            Returns the older version of this <paramref name="codeNode" /> object. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(NDepend.CodeModel.ICodeNode{``0})" /> must be called instead.
            </summary>
      <remarks>
            If this code element is already the older version, returns this code element.<br />
            If this code element has been added and has no corresponding older version, returns null.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.<br /></remarks>
      <typeparam name="T">
        <i>T</i> is the closed <see cref="T:NDepend.CodeModel.ICodeNode`1" /> generic type, like in <i>ICodeNode&lt;IMethod&gt;</i> or <i>ICodeNode&lt;ICodeBase&gt;</i> for example.</typeparam>
      <param name="codeNode">This <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object. A <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object. </param>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(NDepend.CodeModel.ICodeNode{``0})" /> must be called instead.</exception>
      <requires description="this codeNode object must not be null" csharp="codeNode != null" vb="codeNode &lt;&gt; Nothing">codeNode != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsInNewerBuild``1(NDepend.CodeModel.ICodeNode{``0})">
      <summary>
            Returns <i>true</i> if this <paramref name="codeNode" /> object is in the newer version of the code base. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsInNewerBuild``1(NDepend.CodeModel.ICodeNode{``0})" /> must be called instead.
            </summary>
      <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <typeparam name="T">
        <i>T</i> is the closed <see cref="T:NDepend.CodeModel.ICodeNode`1" /> generic type, like in <i>ICodeNode&lt;IMethod&gt;</i> or <i>ICodeNode&lt;ICodeBase&gt;</i> for example.</typeparam>
      <param name="codeNode">This <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object. A <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object. </param>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsInNewerBuild``1(NDepend.CodeModel.ICodeNode{``0})" /> must be called instead.</exception>
      <requires description="this codeNode object must not be null" csharp="codeNode != null" vb="codeNode &lt;&gt; Nothing">codeNode != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsInOlderBuild``1(NDepend.CodeModel.ICodeNode{``0})">
      <summary>
            Returns <i>true</i> if this <paramref name="codeNode" /> object is in the older version of the code base. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsInOlderBuild``1(NDepend.CodeModel.ICodeNode{``0})" /> must be called instead.
            </summary>
      <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <typeparam name="T">
        <i>T</i> is the closed <see cref="T:NDepend.CodeModel.ICodeNode`1" /> generic type, like in <i>ICodeNode&lt;IMethod&gt;</i> or <i>ICodeNode&lt;ICodeBase&gt;</i> for example.</typeparam>
      <param name="codeNode">This <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object. A <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object. </param>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsInOlderBuild``1(NDepend.CodeModel.ICodeNode{``0})" /> must be called instead.</exception>
      <requires description="this codeNode object must not be null" csharp="codeNode != null" vb="codeNode &lt;&gt; Nothing">codeNode != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsPresentInBothBuilds``1(NDepend.CodeModel.ICodeNode{``0})">
      <summary>
            Returns <i>true</i> if this <paramref name="codeNode" /> object is both in the newer and older versions of the code base. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsPresentInBothBuilds``1(NDepend.CodeModel.ICodeNode{``0})" /> must be called instead.
            </summary>
      <remarks>
            If this method returns true, this means that this code element has not been added nor removed.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <typeparam name="T">
        <i>T</i> is the closed <see cref="T:NDepend.CodeModel.ICodeNode`1" /> generic type, like in <i>ICodeNode&lt;IMethod&gt;</i> or <i>ICodeNode&lt;ICodeBase&gt;</i> for example.</typeparam>
      <param name="codeNode">This <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object. A <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object. </param>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsPresentInBothBuilds``1(NDepend.CodeModel.ICodeNode{``0})" /> must be called instead.</exception>
      <requires description="this codeNode object must not be null" csharp="codeNode != null" vb="codeNode &lt;&gt; Nothing">codeNode != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.WasChanged``1(NDepend.CodeModel.ICodeNode{``0})">
      <summary>
            Returns <i>true</i> if this <paramref name="codeNode" /> object was changed in any way (code change, comment change, visibility change...). This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.WasChanged``1(NDepend.CodeModel.ICodeNode{``0})" /> must be called instead.
            </summary>
      <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <typeparam name="T">
        <i>T</i> is the closed <see cref="T:NDepend.CodeModel.ICodeNode`1" /> generic type, like in <i>ICodeNode&lt;IMethod&gt;</i> or <i>ICodeNode&lt;ICodeBase&gt;</i> for example.</typeparam>
      <param name="codeNode">This <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object. A <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object. </param>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.WasChanged``1(NDepend.CodeModel.ICodeNode{``0})" /> must be called instead.</exception>
      <requires description="this codeNode object must not be null" csharp="codeNode != null" vb="codeNode &lt;&gt; Nothing">codeNode != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.CodeWasChanged(NDepend.CodeModel.ICodeContainer)">
      <summary>
            Returns <i>true</i> if the code of this <paramref name="codeContainer" /> object, has been modified. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.CodeWasChanged(NDepend.CodeModel.ICodeContainer)" /> must be called instead.
            </summary>
      <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <param name="codeContainer">This <see cref="T:NDepend.CodeModel.ICodeContainer" /> object. A <see cref="T:NDepend.CodeModel.ICodeContainer" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.CodeWasChanged(NDepend.CodeModel.ICodeContainer)" /> must be called instead.</exception>
      <requires description="this codeContainer object must not be null" csharp="codeContainer != null" vb="codeContainer &lt;&gt; Nothing">codeContainer != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.CommentsWereChanged(NDepend.CodeModel.ICodeContainer)">
      <summary>
            Returns <i>true</i> if comments of this <paramref name="codeContainer" /> object, have been modified. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.CommentsWereChanged(NDepend.CodeModel.ICodeContainer)" /> must be called instead.
            </summary>
      <remarks>
            So far, comments change is detected only when <see cref="T:NDepend.CodeModel.ICodeContainer" />.<see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfComment" /> has been changed.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <param name="codeContainer">This <see cref="T:NDepend.CodeModel.ICodeContainer" /> object. A <see cref="T:NDepend.CodeModel.ICodeContainer" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.CommentsWereChanged(NDepend.CodeModel.ICodeContainer)" /> must be called instead.</exception>
      <requires description="this codeContainer object must not be null" csharp="codeContainer != null" vb="codeContainer &lt;&gt; Nothing">codeContainer != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.WasAdded(NDepend.CodeModel.ICodeElement)">
      <summary>
            Returns <i>true</i> if this <paramref name="codeElement" /> object has been added and thus, is not present in the older version of the code base. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.WasAdded(NDepend.CodeModel.ICodeElement)" /> must be called instead.
            </summary>
      <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.WasAdded(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
      <requires description="this codeElement object must not be null" csharp="codeElement != null" vb="codeElement &lt;&gt; Nothing">codeElement != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.WasRemoved(NDepend.CodeModel.ICodeElement)">
      <summary>
            Returns <i>true</i> if this <paramref name="codeElement" /> object has been removed and thus, is not present in the newer version of the code base. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.WasRemoved(NDepend.CodeModel.ICodeElement)" /> must be called instead.
            </summary>
      <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.WasRemoved(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
      <requires description="this codeElement object must not be null" csharp="codeElement != null" vb="codeElement &lt;&gt; Nothing">codeElement != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsUsedRecently(NDepend.CodeModel.ICodeElement)">
      <summary>
            Returns <i>true</i> if this <paramref name="codeElement" /> object is in a third-party assembly (or is a third-party assembly itself), and if it is used by the newer version of the code base, but not by the older version. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsUsedRecently(NDepend.CodeModel.ICodeElement)" /> must be called instead.
            </summary>
      <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsUsedRecently(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
      <requires description="this codeElement object must not be null" csharp="codeElement != null" vb="codeElement &lt;&gt; Nothing">codeElement != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsNotUsedAnymore(NDepend.CodeModel.ICodeElement)">
      <summary>
            Returns <i>true</i> if this <paramref name="codeElement" /> object is in a third-party assembly (or is a third-party assembly itself), and if it is used by the older version of the code base, but not by the newer version. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsNotUsedAnymore(NDepend.CodeModel.ICodeElement)" /> must be called instead.
            </summary>
      <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsNotUsedAnymore(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
      <requires description="this codeElement object must not be null" csharp="codeElement != null" vb="codeElement &lt;&gt; Nothing">codeElement != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.VisibilityWasChanged(NDepend.CodeModel.IMember)">
      <summary>
            Returns <i>true</i> if the visibility of this <paramref name="member" /> has been changed. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.VisibilityWasChanged(NDepend.CodeModel.IMember)" /> must be called instead.
            </summary>
      <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <param name="member">This <see cref="T:NDepend.CodeModel.IMember" /> object. A <see cref="T:NDepend.CodeModel.IMember" /> object can be a <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.VisibilityWasChanged(NDepend.CodeModel.IMember)" /> must be called instead.</exception>
      <requires description="this member object must not be null" csharp="member != null" vb="member &lt;&gt; Nothing">member != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.BecameObsolete(NDepend.CodeModel.IMember)">
      <summary>
            Returns <i>true</i> if this <paramref name="member" /> is not tagged with <i>System.ObsoleteAttribute</i> in the older version of the code base, but is tagged as obsolete in the newer version of the code base. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.BecameObsolete(NDepend.CodeModel.IMember)" /> must be called instead.
            </summary>
      <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <param name="member">This <see cref="T:NDepend.CodeModel.IMember" /> object. A <see cref="T:NDepend.CodeModel.IMember" /> object can be a <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.BecameObsolete(NDepend.CodeModel.IMember)" /> must be called instead.</exception>
      <requires description="this member object must not be null" csharp="member != null" vb="member &lt;&gt; Nothing">member != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsUsedDifferently(NDepend.CodeModel.ICodeElementParent)">
      <summary>
            Returns <i>true</i> if this <paramref name="codeElementParent" /> is a namespace or a type in a third-party assembly (or is a third-party assembly itself) and if some of its children code elements are not used anymore by the newer version of the code base, or are used by the newer version of the code base, but are not used by the older version. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsUsedDifferently(NDepend.CodeModel.ICodeElementParent)" /> must be called instead.
            </summary>
      <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <param name="codeElementParent">This <see cref="T:NDepend.CodeModel.ICodeElementParent" /> object. A <see cref="T:NDepend.CodeModel.ICodeElementParent" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" /> or <see cref="T:NDepend.CodeModel.IType" /> object.</param>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.IsUsedDifferently(NDepend.CodeModel.ICodeElementParent)" /> must be called instead.</exception>
      <requires description="this codeElementParent object must not be null" csharp="codeElementParent != null" vb="codeElementParent &lt;&gt; Nothing">codeElementParent != null</requires>
    </member>
    <member name="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency">
      <summary>
            Presents extension methods on code elements, that provides a syntax friendly way to specify dependencies in CQLinq rules queries.
            </summary>
      <remarks>
        <b>These extension methods exist for CQLinq friendly syntax reasons</b> and can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />.<br />
            Indeed they all require a special resolving step prior to query execution, that resolves once for all code elements by name.<br />
            The user doesn't have to write this resolving code. This results in less syntax burden.<br />
            For each of these extension methods, there are one or several corresponding methods in <see cref="N:NDepend.CodeModel" />, that can be called to get the same action done.<br />
            This pre-resolving step is weaved at CQLinq compilation time, the CQLinq compiler takes care of transforming calls to these extension methods to calls to their <see cref="N:NDepend.CodeModel" /> equivalent.<br />
            These extension methods cannot be called from a program consuming NDepend.API, since it would provoke the resolving step to be invoked for all code elements.
            </remarks>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)">
      <summary>
            Append the prefix <i>"OPTIONAL:"</i> to <paramref name="codeElementName" /> to precise to a method such as <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" />, that takes a code element name string as argument, that if no code element is matched, no exception should be sent.
            </summary>
      <param name="codeElementName">The original code element name.</param>
      <returns>
        <paramref name="codeElementName" /> prefixed with <i>"OPTIONAL:"</i>.</returns>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
      <requires description="codeElementName must not be null" csharp="codeElementName != null" vb="codeElementName &lt;&gt; Nothing">codeElementName != null</requires>
      <ensures description="returned string reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)">
      <summary>
            Append the prefix <i>"ASSEMBLY:"</i> to <paramref name="assemblyName" /> to precise to a method such as <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" /> that takes a code element name string as argument, that only assemblies can be matched by name.
            </summary>
      <param name="assemblyName">The original code element name.</param>
      <returns>
        <paramref name="assemblyName" /> prefixed with <i>"ASSEMBLY:"</i>.</returns>
      <exception cref="T:System.InvalidOperationException">Two different code element kind prefixes cannot be inserted.</exception>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
      <requires description="assemblyName must not be null" csharp="assemblyName != null" vb="assemblyName &lt;&gt; Nothing">assemblyName != null</requires>
      <ensures description="returned string reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)">
      <summary>
            Append the prefix <i>"NAMESPACE:"</i> to <paramref name="namespaceName" /> to precise to a method such as <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" /> that takes a code element name string as argument, that only namespaces can be matched by name.
            </summary>
      <param name="namespaceName">The original code element name.</param>
      <returns>
        <paramref name="namespaceName" /> prefixed with <i>"NAMESPACE:"</i>.</returns>
      <exception cref="T:System.InvalidOperationException">Two different code element kind prefixes cannot be inserted.</exception>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
      <requires description="namespaceName must not be null" csharp="namespaceName != null" vb="namespaceName &lt;&gt; Nothing">namespaceName != null</requires>
      <ensures description="returned string reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)">
      <summary>
            Append the prefix <i>"TYPE:"</i> to <paramref name="typeFullName" /> to precise to a method such as <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" /> that takes a code element name string as argument, that only types can be matched by name.
            </summary>
      <param name="typeFullName">The original code element name.</param>
      <returns>
        <paramref name="typeFullName" /> prefixed with <i>"TYPE:"</i>.</returns>
      <exception cref="T:System.InvalidOperationException">Two different code element kind prefixes cannot be inserted.</exception>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
      <requires description="typeFullName must not be null" csharp="typeFullName != null" vb="typeFullName &lt;&gt; Nothing">typeFullName != null</requires>
      <ensures description="returned string reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)">
      <summary>
            Append the prefix <i>"METHOD:"</i> to <paramref name="methodFullName" /> to precise to a method such as <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" /> that takes a code element name string as argument, that only methods can be matched by name.
            </summary>
      <param name="methodFullName">The original code element name.</param>
      <returns>
        <paramref name="methodFullName" /> prefixed with <i>"METHOD:"</i>.</returns>
      <exception cref="T:System.InvalidOperationException">Two different code element kind prefixes cannot be inserted.</exception>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
      <requires description="methodFullName must not be null" csharp="methodFullName != null" vb="methodFullName &lt;&gt; Nothing">methodFullName != null</requires>
      <ensures description="returned string reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)">
      <summary>
            Append the prefix <i>"FIELD:"</i> to <paramref name="fieldFullName" /> to precise to a method such as <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" /> that takes a code element name string as argument, that only fields can be matched by name.
            </summary>
      <param name="fieldFullName">The original code element name.</param>
      <returns>
        <paramref name="fieldFullName" /> prefixed with <i>"FIELD:"</i>.</returns>
      <exception cref="T:System.InvalidOperationException">Two different code element kind prefixes cannot be inserted.</exception>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
      <requires description="fieldFullName must not be null" csharp="fieldFullName != null" vb="fieldFullName &lt;&gt; Nothing">fieldFullName != null</requires>
      <ensures description="returned string reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)">
      <summary>
            Returns true if this <paramref name="usedCodeElement" /> is directly used by a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> (or <see cref="P:NDepend.CodeModel.IMember.FullName" /> for member) is <paramref name="userCodeElementFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" /> must be called instead.
            </summary>
      <param name="usedCodeElement">This <see cref="T:NDepend.CodeModel.IUsed" /> object. A <see cref="T:NDepend.CodeModel.IUsed" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IMember" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <param name="userCodeElementFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> (or <see cref="P:NDepend.CodeModel.IMember.FullName" /> for member) of the code element user.<br /><br />
            The string <paramref name="userCodeElementFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several code elements are matched by <paramref name="userCodeElementFullName" />, this method has a <i>used by <b>any</b></i> behavior.<br /><br />
            If <paramref name="userCodeElementFullName" /> matchs several code elements of different kinds (like some assemblies and some namespaces) a compilation resolving error is emitted.<br /> 
            To solve this issue, the string can be prefixed with <i>"ASSEMBLY:"</i>, <i>"NAMESPACE:"</i>, <i>"TYPE:"</i>, <i>"METHOD:"</i> or <i>"FIELD:"</i> to precise the kind of code element to match.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" /> can be used instead, to insert this prefix.<br /><br />
            If no code element is matched by <paramref name="userCodeElementFullName" />, the CQLinq query will emit a compilation error, except if <paramref name="userCodeElementFullName" /> is prefixed with <i>"OPTIONAL:"</i>.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" /> can be used instead, to insert the <i>"OPTIONAL:"</i> prefix.<br /></param>
      <remarks>
            If one or several code elements are matched by <paramref name="userCodeElementFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
      <requires description="usedCodeElement object must not be null" csharp="usedCodeElement != null" vb="usedCodeElement &lt;&gt; Nothing">usedCodeElement != null</requires>
      <requires description="userCodeElementFullName string must not be null" csharp="userCodeElementFullName != null" vb="userCodeElementFullName &lt;&gt; Nothing">userCodeElementFullName != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedByAssembly(NDepend.CodeModel.IUsed,System.String)">
      <summary>
            Returns true if this <paramref name="usedCodeElement" /> is directly used by a <see cref="T:NDepend.CodeModel.IAssembly" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> is <paramref name="userAssemblyName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedByAssembly(NDepend.CodeModel.IAssembly)" /> must be called instead.
            </summary>
      <param name="usedCodeElement">This <see cref="T:NDepend.CodeModel.IUsed" /> object. A <see cref="T:NDepend.CodeModel.IUsed" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IMember" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <param name="userAssemblyName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> of the assembly user.<br />
            The string <paramref name="userAssemblyName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several assemblies are matched by <paramref name="userAssemblyName" />, this method has a <i>used by <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several assemblies are matched by <paramref name="userAssemblyName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedByAssembly(NDepend.CodeModel.IAssembly)" /> must be called instead.</exception>
      <requires description="usedCodeElement object must not be null" csharp="usedCodeElement != null" vb="usedCodeElement &lt;&gt; Nothing">usedCodeElement != null</requires>
      <requires description="userAssemblyName string must not be null" csharp="userAssemblyName != null" vb="userAssemblyName &lt;&gt; Nothing">userAssemblyName != null</requires>
      <requires description="userAssemblyName string must not be empty" csharp="userAssemblyName.Length &gt; 0" vb="userAssemblyName.Length &gt; 0">userAssemblyName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedByNamespace(NDepend.CodeModel.IUsed,System.String)">
      <summary>
            Returns true if this <paramref name="usedCodeElement" /> is directly used by a <see cref="T:NDepend.CodeModel.INamespace" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> is <paramref name="userNamespaceName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedByNamespace(NDepend.CodeModel.INamespace)" /> must be called instead.
            </summary>
      <param name="usedCodeElement">This <see cref="T:NDepend.CodeModel.IUsed" /> object. A <see cref="T:NDepend.CodeModel.IUsed" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IMember" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <param name="userNamespaceName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> of the namespace user.<br />
            The string <paramref name="userNamespaceName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several namespaces are matched by <paramref name="userNamespaceName" />, this method has a <i>used by <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several namespaces are matched by <paramref name="userNamespaceName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedByNamespace(NDepend.CodeModel.INamespace)" /> must be called instead.</exception>
      <requires description="usedCodeElement object must not be null" csharp="usedCodeElement != null" vb="usedCodeElement &lt;&gt; Nothing">usedCodeElement != null</requires>
      <requires description="userNamespaceName string must not be null" csharp="userNamespaceName != null" vb="userNamespaceName &lt;&gt; Nothing">userNamespaceName != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedByType(NDepend.CodeModel.IUsed,System.String)">
      <summary>
            Returns true if this <paramref name="usedCodeElement" /> is directly used by a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="userTypeFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedByType(NDepend.CodeModel.IType)" /> must be called instead.
            </summary>
      <param name="usedCodeElement">This <see cref="T:NDepend.CodeModel.IUsed" /> object. A <see cref="T:NDepend.CodeModel.IUsed" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IMember" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <param name="userTypeFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of the type user.<br />
            The string <paramref name="userTypeFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several types are matched by <paramref name="userTypeFullName" />, this method has a <i>used by <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several types are matched by <paramref name="userTypeFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedByType(NDepend.CodeModel.IType)" /> must be called instead.</exception>
      <requires description="usedCodeElement object must not be null" csharp="usedCodeElement != null" vb="usedCodeElement &lt;&gt; Nothing">usedCodeElement != null</requires>
      <requires description="userTypeFullName string must not be null" csharp="userTypeFullName != null" vb="userTypeFullName &lt;&gt; Nothing">userTypeFullName != null</requires>
      <requires description="userTypeFullName string must not be empty" csharp="userTypeFullName.Length &gt; 0" vb="userTypeFullName.Length &gt; 0">userTypeFullName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedByMethod(NDepend.CodeModel.IUsed,System.String)">
      <summary>
            Returns true if this <paramref name="usedCodeElement" /> is directly used by a <see cref="T:NDepend.CodeModel.IMethod" /> whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="userMethodFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedByMethod(NDepend.CodeModel.IMethod)" /> must be called instead.
            </summary>
      <param name="usedCodeElement">This <see cref="T:NDepend.CodeModel.IUsed" /> object. A <see cref="T:NDepend.CodeModel.IUsed" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IMember" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <param name="userMethodFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of the method user.<br />
            The string <paramref name="userMethodFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several methods are matched by <paramref name="userMethodFullName" />, this method has a <i>used by <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several methods are matched by <paramref name="userMethodFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUsed" />.<see cref="M:NDepend.CodeModel.IUsed.IsUsedByMethod(NDepend.CodeModel.IMethod)" /> must be called instead.</exception>
      <requires description="usedCodeElement object must not be null" csharp="usedCodeElement != null" vb="usedCodeElement &lt;&gt; Nothing">usedCodeElement != null</requires>
      <requires description="userMethodFullName string must not be null" csharp="userMethodFullName != null" vb="userMethodFullName &lt;&gt; Nothing">userMethodFullName != null</requires>
      <requires description="userMethodFullName string must not be empty" csharp="userMethodFullName.Length &gt; 0" vb="userMethodFullName.Length &gt; 0">userMethodFullName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)">
      <summary>
            Returns a non-null depth of usage value, if <paramref name="usedCodeElement" /> is <b>directly or indirectly</b> used by a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> (or <see cref="P:NDepend.CodeModel.IMember.FullName" /> for member) is <paramref name="userCodeElementFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" /> must be called instead.
            </summary>
      <param name="usedCodeElement">This <see cref="T:NDepend.CodeModel.IUsed" /> object. A <see cref="T:NDepend.CodeModel.IUsed" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IMember" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <param name="userCodeElementFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> (or <see cref="P:NDepend.CodeModel.IMember.FullName" /> for member) of the code element user.<br />
            The string <paramref name="userCodeElementFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several code elements are matched by <paramref name="userCodeElementFullName" />, this method has a <i>used by <b>any</b></i> behavior.<br /><br />
            If <paramref name="userCodeElementFullName" /> matchs several code elements of different kinds (like some assemblies and some namespaces) a compilation resolving error is emitted.<br /> 
            To solve this issue, the string can be prefixed with <i>"ASSEMBLY:"</i>, <i>"NAMESPACE:"</i>, <i>"TYPE:"</i>, <i>"METHOD:"</i> or <i>"FIELD:"</i> to precise the kind of code element to match.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" /> can be used instead, to insert this prefix.<br /><br />
            If no code element is matched by <paramref name="userCodeElementFullName" />, the CQLinq query will emit a compilation error, except if <paramref name="userCodeElementFullName" /> is prefixed with <i>"OPTIONAL:"</i>.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" /> can be used instead, to insert the <i>"OPTIONAL:"</i> prefix.<br /></param>
      <remarks>
            If one or several code elements are matched by <paramref name="userCodeElementFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <returns>
        <i>userCodeElement</i> being a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> (or <see cref="P:NDepend.CodeModel.IMember.FullName" /> for member) is <paramref name="userCodeElementFullName" />: <br />
            Returns null if <paramref name="usedCodeElement" /> is not directly nor indirectly used by a <i>userCodeElement</i>.<br />
            Returns 0 if <paramref name="usedCodeElement" /> is, or belongs to, a <i>userCodeElement</i>.<br />
            Returns 1 if <paramref name="usedCodeElement" /> is directly used by a <i>userCodeElement</i>.<br />
            Returns 2 if <paramref name="usedCodeElement" /> is directly used by a code element that is directly used by a <i>userCodeElement</i>.<br />
            ...<br />
            If a non-null number is returned, returns the lowest possible number.
            </returns>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" /> must be called instead.</exception>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
      <requires description="usedCodeElement object must not be null" csharp="usedCodeElement != null" vb="usedCodeElement &lt;&gt; Nothing">usedCodeElement != null</requires>
      <requires description="userCodeElementFullName string must not be null" csharp="userCodeElementFullName != null" vb="userCodeElementFullName &lt;&gt; Nothing">userCodeElementFullName != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)">
      <summary>
            Returns true if <paramref name="usedCodeElement" /> is, <b>directly or indirectly</b>, used by a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> (or <see cref="P:NDepend.CodeModel.IMember.FullName" /> for member) is <paramref name="userCodeElementFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" /> must be called instead.
            </summary>
      <param name="usedCodeElement">This <see cref="T:NDepend.CodeModel.IUsed" /> object. A <see cref="T:NDepend.CodeModel.IUsed" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IMember" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <param name="userCodeElementFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> (or <see cref="P:NDepend.CodeModel.IMember.FullName" /> for member) of the code element user.<br />
            The string <paramref name="userCodeElementFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several code elements are matched by <paramref name="userCodeElementFullName" />, this method has a <i>used by <b>any</b></i> behavior.<br /><br />
            If <paramref name="userCodeElementFullName" /> matchs several code elements of different kinds (like some assemblies and some namespaces) a compilation resolving error is emitted.<br /> 
            To solve this issue, the string can be prefixed with <i>"ASSEMBLY:"</i>, <i>"NAMESPACE:"</i>, <i>"TYPE:"</i>, <i>"METHOD:"</i> or <i>"FIELD:"</i> to precise the kind of code element to match.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" /> can be used instead, to insert this prefix.<br /><br />
            If no code element is matched by <paramref name="userCodeElementFullName" />, the CQLinq query will emit a compilation error, except if <paramref name="userCodeElementFullName" /> is prefixed with <i>"OPTIONAL:"</i>.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" /> can be used instead, to insert the <i>"OPTIONAL:"</i> prefix.<br /></param>
      <remarks>
            If one or several code elements are matched by <paramref name="userCodeElementFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <returns>
        <i>userCodeElement</i> being a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> (or <see cref="P:NDepend.CodeModel.IMember.FullName" /> for member) is <paramref name="userCodeElementFullName" />: <br />
            Returns true if <paramref name="usedCodeElement" /> is, <b>directly or indirectly</b>, used by a <i>userCodeElement</i>, otherwise returns false.<br /></returns>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" /> must be called instead.</exception>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
      <requires description="usedCodeElement object must not be null" csharp="usedCodeElement != null" vb="usedCodeElement &lt;&gt; Nothing">usedCodeElement != null</requires>
      <requires description="userCodeElementFullName string must not be null" csharp="userCodeElementFullName != null" vb="userCodeElementFullName &lt;&gt; Nothing">userCodeElementFullName != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)">
      <summary>
            Returns true if this <paramref name="userCodeElement" /> is directly using a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> (or <see cref="P:NDepend.CodeModel.IMember.FullName" /> for member) is <paramref name="usedCodeElementFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsing(NDepend.CodeModel.ICodeElement)" /> must be called instead.
            </summary>
      <param name="userCodeElement">This <see cref="T:NDepend.CodeModel.IUser" /> object. A <see cref="T:NDepend.CodeModel.IUser" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
      <param name="usedCodeElementFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> (or <see cref="P:NDepend.CodeModel.IMember.FullName" /> for member) of the code element used.<br />
            The string <paramref name="usedCodeElementFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several code elements are matched by <paramref name="usedCodeElementFullName" />, this method has a <i>using <b>any</b></i> behavior.<br /><br />
            If <paramref name="usedCodeElementFullName" /> matchs several code elements of different kinds (like some assemblies and some namespaces) a compilation resolving error is emitted.<br /> 
            To solve this issue, the string can be prefixed with <i>"ASSEMBLY:"</i>, <i>"NAMESPACE:"</i>, <i>"TYPE:"</i>, <i>"METHOD:"</i> or <i>"FIELD:"</i> to precise the kind of code element to match.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" /> can be used instead, to insert this prefix.<br /><br />
            If no code element is matched by <paramref name="usedCodeElementFullName" />, the CQLinq query will emit a compilation error, except if <paramref name="usedCodeElementFullName" /> is prefixed with <i>"OPTIONAL:"</i>.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" /> can be used instead, to insert the <i>"OPTIONAL:"</i> prefix.<br /></param>
      <remarks>
            If one or several code elements are matched by <paramref name="usedCodeElementFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsing(NDepend.CodeModel.ICodeElement)" /> must be called instead.</exception>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
      <requires description="userCodeElement object must not be null" csharp="userCodeElement != null" vb="userCodeElement &lt;&gt; Nothing">userCodeElement != null</requires>
      <requires description="usedCodeElementFullName string must not be null" csharp="usedCodeElementFullName != null" vb="usedCodeElementFullName &lt;&gt; Nothing">usedCodeElementFullName != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingAssembly(NDepend.CodeModel.IUser,System.String)">
      <summary>
            Returns true if this <paramref name="userCodeElement" /> is directly using a <see cref="T:NDepend.CodeModel.IAssembly" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> is <paramref name="usedAssemblyName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingAssembly(NDepend.CodeModel.IAssembly)" /> must be called instead.
            </summary>
      <param name="userCodeElement">This <see cref="T:NDepend.CodeModel.IUser" /> object. A <see cref="T:NDepend.CodeModel.IUser" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
      <param name="usedAssemblyName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> of the assembly used.<br />
            The string <paramref name="usedAssemblyName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several assemblies are matched by <paramref name="usedAssemblyName" />, this method has a <i>using <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several assemblies are matched by <paramref name="usedAssemblyName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingAssembly(NDepend.CodeModel.IAssembly)" /> must be called instead.</exception>
      <requires description="userCodeElement object must not be null" csharp="userCodeElement != null" vb="userCodeElement &lt;&gt; Nothing">userCodeElement != null</requires>
      <requires description="usedAssemblyName string must not be null" csharp="usedAssemblyName != null" vb="usedAssemblyName &lt;&gt; Nothing">usedAssemblyName != null</requires>
      <requires description="usedAssemblyName string must not be empty" csharp="usedAssemblyName.Length &gt; 0" vb="usedAssemblyName.Length &gt; 0">usedAssemblyName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingNamespace(NDepend.CodeModel.IUser,System.String)">
      <summary>
            Returns true if this <paramref name="userCodeElement" /> is directly using a <see cref="T:NDepend.CodeModel.INamespace" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> is <paramref name="usedNamespaceName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingNamespace(NDepend.CodeModel.INamespace)" /> must be called instead.
            </summary>
      <param name="userCodeElement">This <see cref="T:NDepend.CodeModel.IUser" /> object. A <see cref="T:NDepend.CodeModel.IUser" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
      <param name="usedNamespaceName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> of the namespace used.<br />
            The string <paramref name="usedNamespaceName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several namespaces are matched by <paramref name="usedNamespaceName" />, this method has a <i>using <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several namespaces are matched by <paramref name="usedNamespaceName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingNamespace(NDepend.CodeModel.INamespace)" /> must be called instead.</exception>
      <requires description="userCodeElement object must not be null" csharp="userCodeElement != null" vb="userCodeElement &lt;&gt; Nothing">userCodeElement != null</requires>
      <requires description="usedNamespaceName string must not be null" csharp="usedNamespaceName != null" vb="usedNamespaceName &lt;&gt; Nothing">usedNamespaceName != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingType(NDepend.CodeModel.IUser,System.String)">
      <summary>
            Returns true if this <paramref name="userCodeElement" /> is directly using a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="usedTypeFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingType(NDepend.CodeModel.IType)" /> must be called instead.
            </summary>
      <param name="userCodeElement">This <see cref="T:NDepend.CodeModel.IUser" /> object. A <see cref="T:NDepend.CodeModel.IUser" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
      <param name="usedTypeFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of the type used.<br />
            The string <paramref name="usedTypeFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several types are matched by <paramref name="usedTypeFullName" />, this method has a <i>using <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several types are matched by <paramref name="usedTypeFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingType(NDepend.CodeModel.IType)" /> must be called instead.</exception>
      <requires description="userCodeElement object must not be null" csharp="userCodeElement != null" vb="userCodeElement &lt;&gt; Nothing">userCodeElement != null</requires>
      <requires description="usedTypeFullName string must not be null" csharp="usedTypeFullName != null" vb="usedTypeFullName &lt;&gt; Nothing">usedTypeFullName != null</requires>
      <requires description="usedTypeFullName string must not be empty" csharp="usedTypeFullName.Length &gt; 0" vb="usedTypeFullName.Length &gt; 0">usedTypeFullName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingMethod(NDepend.CodeModel.IUser,System.String)">
      <summary>
            Returns true if this <paramref name="userCodeElement" /> is directly using a <see cref="T:NDepend.CodeModel.IMethod" /> whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="usedMethodFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingMethod(NDepend.CodeModel.IMethod)" /> must be called instead.
            </summary>
      <param name="userCodeElement">This <see cref="T:NDepend.CodeModel.IUser" /> object. A <see cref="T:NDepend.CodeModel.IUser" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
      <param name="usedMethodFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of the method used.<br />
            The string <paramref name="usedMethodFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several methods are matched by <paramref name="usedMethodFullName" />, this method has a <i>using <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several methods are matched by <paramref name="usedMethodFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingMethod(NDepend.CodeModel.IMethod)" /> must be called instead.</exception>
      <requires description="userCodeElement object must not be null" csharp="userCodeElement != null" vb="userCodeElement &lt;&gt; Nothing">userCodeElement != null</requires>
      <requires description="usedMethodFullName string must not be null" csharp="usedMethodFullName != null" vb="usedMethodFullName &lt;&gt; Nothing">usedMethodFullName != null</requires>
      <requires description="usedMethodFullName string must not be empty" csharp="usedMethodFullName.Length &gt; 0" vb="usedMethodFullName.Length &gt; 0">usedMethodFullName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingField(NDepend.CodeModel.IUser,System.String)">
      <summary>
            Returns true if this <paramref name="userCodeElement" /> is directly using a <see cref="T:NDepend.CodeModel.IField" /> whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="usedFieldFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingField(NDepend.CodeModel.IField)" /> must be called instead.
            </summary>
      <param name="userCodeElement">This <see cref="T:NDepend.CodeModel.IUser" /> object. A <see cref="T:NDepend.CodeModel.IUser" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
      <param name="usedFieldFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of the field used.<br />
            The string <paramref name="usedFieldFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several fields are matched by <paramref name="usedFieldFullName" />, this method has a <i>using <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several fields are matched by <paramref name="usedFieldFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IUser" />.<see cref="M:NDepend.CodeModel.IUser.IsUsingField(NDepend.CodeModel.IField)" /> must be called instead.</exception>
      <requires description="userCodeElement object must not be null" csharp="userCodeElement != null" vb="userCodeElement &lt;&gt; Nothing">userCodeElement != null</requires>
      <requires description="usedFieldFullName string must not be null" csharp="usedFieldFullName != null" vb="usedFieldFullName &lt;&gt; Nothing">usedFieldFullName != null</requires>
      <requires description="usedFieldFullName string must not be empty" csharp="usedFieldFullName.Length &gt; 0" vb="usedFieldFullName.Length &gt; 0">usedFieldFullName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)">
      <summary>
            Returns a non-null depth of usage value, if <paramref name="userCodeElement" /> is <b>directly or indirectly</b> using a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> (or <see cref="P:NDepend.CodeModel.IMember.FullName" /> for member) is <paramref name="usedCodeElementFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" /> must be called instead.
            </summary>
      <param name="userCodeElement">This <see cref="T:NDepend.CodeModel.IUser" /> object. A <see cref="T:NDepend.CodeModel.IUser" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
      <param name="usedCodeElementFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> (or <see cref="P:NDepend.CodeModel.IMember.FullName" /> for member) of the code element used.<br />
            The string <paramref name="usedCodeElementFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several code elements are matched by <paramref name="usedCodeElementFullName" />, this method has a <i>using <b>any</b></i> behavior.<br /><br />
            If <paramref name="usedCodeElementFullName" /> matchs several code elements of different kinds (like some assemblies and some namespaces) a compilation resolving error is emitted.<br /> 
            To solve this issue, the string can be prefixed with <i>"ASSEMBLY:"</i>, <i>"NAMESPACE:"</i>, <i>"TYPE:"</i>, <i>"METHOD:"</i> or <i>"FIELD:"</i> to precise the kind of code element to match.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" /> can be used instead, to insert this prefix.<br /><br />
            If no code element is matched by <paramref name="usedCodeElementFullName" />, the CQLinq query will emit a compilation error, except if <paramref name="usedCodeElementFullName" /> is prefixed with <i>"OPTIONAL:"</i>.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" /> can be used instead, to insert the <i>"OPTIONAL:"</i> prefix.<br /></param>
      <remarks>
            If one or several code elements are matched by <paramref name="usedCodeElementFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <returns>
        <i>usedCodeElement</i> being a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> (or <see cref="P:NDepend.CodeModel.IMember.FullName" /> for member) is <paramref name="usedCodeElementFullName" />: <br />
            Returns null if <paramref name="userCodeElement" /> is not directly nor indirectly using a <i>usedCodeElement</i>.<br />
            Returns 0 if <paramref name="userCodeElement" /> is, or belongs to, a <i>usedCodeElement</i>.<br />
            Returns 1 if <paramref name="userCodeElement" /> is directly using a <i>usedCodeElement</i>.<br />
            Returns 2 if <paramref name="userCodeElement" /> is directly using a code element that directly uses a <i>usedCodeElement</i>.<br />
            ...<br />
            If a non-null number is returned, returns the lowest possible number.
            </returns>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" /> must be called instead.</exception>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
      <requires description="userCodeElement object must not be null" csharp="userCodeElement != null" vb="userCodeElement &lt;&gt; Nothing">userCodeElement != null</requires>
      <requires description="usedCodeElementFullName string must not be null" csharp="usedCodeElementFullName != null" vb="usedCodeElementFullName &lt;&gt; Nothing">usedCodeElementFullName != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)">
      <summary>
            Returns true if <paramref name="userCodeElement" /> is, <b>directly or indirectly</b>, using a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> (or <see cref="P:NDepend.CodeModel.IMember.FullName" /> for member) is <paramref name="usedCodeElementFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" /> must be called instead.
            </summary>
      <param name="userCodeElement">This <see cref="T:NDepend.CodeModel.IUser" /> object. A <see cref="T:NDepend.CodeModel.IUser" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
      <param name="usedCodeElementFullName">
            The <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> (or <see cref="P:NDepend.CodeModel.IMember.FullName" /> for member) of the code element used.<br />
            The string <paramref name="usedCodeElementFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several code elements are matched by <paramref name="usedCodeElementFullName" />, this method has a <i>using <b>any</b></i> behavior.<br /><br />
            If <paramref name="usedCodeElementFullName" /> matchs several code elements of different kinds (like some assemblies and some namespaces) a compilation resolving error is emitted.<br /> 
            To solve this issue, the string can be prefixed with <i>"ASSEMBLY:"</i>, <i>"NAMESPACE:"</i>, <i>"TYPE:"</i>, <i>"METHOD:"</i> or <i>"FIELD:"</i> to precise the kind of code element to match.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" /> or <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" /> can be used instead, to insert this prefix.<br /><br />
            If no code element is matched by <paramref name="usedCodeElementFullName" />, the CQLinq query will emit a compilation error, except if <paramref name="usedCodeElementFullName" /> is prefixed with <i>"OPTIONAL:"</i>.<br />
            Alternatively, the string extensions methods <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" /> can be used instead, to insert the <i>"OPTIONAL:"</i> prefix.<br /></param>
      <remarks>
            If one or several code elements are matched by <paramref name="usedCodeElementFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <returns>
        <i>userCodeElement</i> being a <see cref="T:NDepend.CodeModel.ICodeElement" /> whose <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> (or <see cref="P:NDepend.CodeModel.IMember.FullName" /> for member) is <paramref name="usedCodeElementFullName" />: <br />
            Returns true if <paramref name="userCodeElement" /> is, <b>directly or indirectly</b>, using a <i>userCodeElement</i>, otherwise returns false.<br /></returns>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" /> must be called instead.</exception>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchAssembly(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchNamespace(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchType(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchMethod(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.MatchField(System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AllowNoMatch(System.String)" />
      <requires description="userCodeElement object must not be null" csharp="userCodeElement != null" vb="userCodeElement &lt;&gt; Nothing">userCodeElement != null</requires>
      <requires description="usedCodeElementFullName string must not be null" csharp="usedCodeElementFullName != null" vb="usedCodeElementFullName &lt;&gt; Nothing">usedCodeElementFullName != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)">
      <summary>
            Returns a non-null depth of inheritance value, if <paramref name="type" /> is, <b>directly or indirectly</b>, deriving from a class whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="baseClassFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IType" />.<see cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" /> must be called instead.
            </summary>
      <param name="type">This derived type.</param>
      <param name="baseClassFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of the base class.<br />
            The string <paramref name="baseClassFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several classes are matched by <paramref name="baseClassFullName" />, this method has a <i>derives from <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several classes are matched by <paramref name="baseClassFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <returns>
        <i>baseClass</i> being a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="baseClassFullName" />: <br />
            Returns null if <paramref name="type" /> is not directly nor indirectly deriving from <i>baseClass</i>.<br />
            Returns 0 if <paramref name="type" /> is a <i>baseClass</i>.<br />
            Returns 1 if <paramref name="type" /> directly derives from <i>baseClass</i>.<br />
            Returns 2 if <paramref name="type" /> directly derives from a base class that directly derives from a <i>baseClass</i>.<br />
            ...<br />
            If a non-null number is returned, returns the lowest possible number.
            </returns>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IType" />.<see cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" /> must be called instead.</exception>
      <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
      <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
      <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
      <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <requires description="type object must not be null" csharp="type != null" vb="type &lt;&gt; Nothing">type != null</requires>
      <requires description="baseClassFullName string must not be null" csharp="baseClassFullName != null" vb="baseClassFullName &lt;&gt; Nothing">baseClassFullName != null</requires>
      <requires description="baseClassFullName string must not be empty" csharp="baseClassFullName.Length &gt; 0" vb="baseClassFullName.Length &gt; 0">baseClassFullName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)">
      <summary>
            Returns true if <paramref name="type" /> is, <b>directly or indirectly</b>, deriving from a class whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="baseClassFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IType" />.<see cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" /> must be called instead.
            </summary>
      <param name="type">This derived type.</param>
      <param name="baseClassFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of the base class.<br />
            The string <paramref name="baseClassFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several classes are matched by <paramref name="baseClassFullName" />, this method has a <i>derives from <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several classes are matched by <paramref name="baseClassFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <returns>
        <i>baseClass</i> being a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="baseClassFullName" />: <br />
            Returns true if <paramref name="type" /> is, <b>directly or indirectly</b>, deriving from a <i>baseClass</i>, otherwise returns false.<br /></returns>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IType" />.<see cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" /> must be called instead.</exception>
      <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
      <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
      <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
      <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <requires description="type object must not be null" csharp="type != null" vb="type &lt;&gt; Nothing">type != null</requires>
      <requires description="baseClassFullName string must not be null" csharp="baseClassFullName != null" vb="baseClassFullName &lt;&gt; Nothing">baseClassFullName != null</requires>
      <requires description="baseClassFullName string must not be empty" csharp="baseClassFullName.Length &gt; 0" vb="baseClassFullName.Length &gt; 0">baseClassFullName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.Implement(NDepend.CodeModel.IType,System.String)">
      <summary>
            Returns true if <paramref name="type" /> implements an interface whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="interfaceFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IType" />.<see cref="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)" /> must be called instead.
            </summary>
      <param name="type">This implementer type.</param>
      <param name="interfaceFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of the interface.<br />
            The string <paramref name="interfaceFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several interfaces are matched by <paramref name="interfaceFullName" />, this method has a <i>implements <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several interfaces are matched by <paramref name="interfaceFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <returns>
        <i>interface</i> being a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="interfaceFullName" />: <br />
            Returns true if <paramref name="type" /> implements a <i>interface</i>, otherwise returns false.<br /></returns>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IType" />.<see cref="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)" /> must be called instead.</exception>
      <seealso cref="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.InterfacesImplemented" />
      <seealso cref="P:NDepend.CodeModel.IType.TypesThatImplementMe" />
      <seealso cref="P:NDepend.CodeModel.IType.NbInterfacesImplemented" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplement(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAll(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <requires description="type object must not be null" csharp="type != null" vb="type &lt;&gt; Nothing">type != null</requires>
      <requires description="interfaceFullName string must not be null" csharp="interfaceFullName != null" vb="interfaceFullName &lt;&gt; Nothing">interfaceFullName != null</requires>
      <requires description="interfaceFullName string must not be empty" csharp="interfaceFullName.Length &gt; 0" vb="interfaceFullName.Length &gt; 0">interfaceFullName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.ReturnTypeIs(NDepend.CodeModel.IMethod,System.String)">
      <summary>
            Returns true if <paramref name="method" /> has a return value of a type whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="returnTypeFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the property getter <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.ReturnType" /> must be used instead.
            </summary>
      <param name="method">This method.</param>
      <param name="returnTypeFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of this method's return type.<br />
            The string <paramref name="returnTypeFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several types are matched by <paramref name="returnTypeFullName" />, this method has a <i>returns <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several types are matched by <paramref name="returnTypeFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <returns>
        <i>returnType</i> being a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="returnTypeFullName" />: <br />
            Returns true if <paramref name="method" /> returns a <i>returnType</i>, otherwise returns false.<br /></returns>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the property getter <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.ReturnType" /> must be used instead.</exception>
      <seealso cref="P:NDepend.CodeModel.IMethod.ReturnType" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithReturnType(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithReturnTypeIn(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <requires description="method object must not be null" csharp="method != null" vb="method &lt;&gt; Nothing">method != null</requires>
      <requires description="returnTypeFullName string must not be null" csharp="returnTypeFullName != null" vb="returnTypeFullName &lt;&gt; Nothing">returnTypeFullName != null</requires>
      <requires description="returnTypeFullName string must not be empty" csharp="returnTypeFullName.Length &gt; 0" vb="returnTypeFullName.Length &gt; 0">returnTypeFullName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)">
      <summary>
            Returns true if <paramref name="method" /> is assigning a field whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="assignedFieldFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the property getter <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" /> must be used instead.
            </summary>
      <param name="method">This method.</param>
      <param name="assignedFieldFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of the assigned field.<br />
            The string <paramref name="assignedFieldFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several fields are matched by <paramref name="assignedFieldFullName" />, this method has a <i>assigning <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several fields are matched by <paramref name="assignedFieldFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <returns>
        <i>assignedField</i> being a <see cref="T:NDepend.CodeModel.IField" /> whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="assignedFieldFullName" />: <br />
            Returns true if <paramref name="method" /> assigns a <i>assignedField</i>, otherwise returns false.<br /></returns>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the property getter <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" /> must be used instead.</exception>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="method object must not be null" csharp="method != null" vb="method &lt;&gt; Nothing">method != null</requires>
      <requires description="assignedFieldFullName string must not be null" csharp="assignedFieldFullName != null" vb="assignedFieldFullName &lt;&gt; Nothing">assignedFieldFullName != null</requires>
      <requires description="assignedFieldFullName string must not be empty" csharp="assignedFieldFullName.Length &gt; 0" vb="assignedFieldFullName.Length &gt; 0">assignedFieldFullName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)">
      <summary>
            Returns true if <paramref name="method" /> is assigning, <b>directly or indirectly</b>, a field whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="assignedFieldFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" /> must be used instead.
            </summary>
      <param name="method">This method.</param>
      <param name="assignedFieldFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of the assigned field.<br />
            The string <paramref name="assignedFieldFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several fields are matched by <paramref name="assignedFieldFullName" />, this method has a <i>assigning <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several fields are matched by <paramref name="assignedFieldFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <returns>
        <i>assignedField</i> being a <see cref="T:NDepend.CodeModel.IField" /> whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="assignedFieldFullName" />: <br />
            Returns true if <paramref name="method" /> assigns, <b>directly or indirectly</b>, a <i>assignedField</i>, otherwise returns false.<br /></returns>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" /> must be used instead.</exception>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="method object must not be null" csharp="method != null" vb="method &lt;&gt; Nothing">method != null</requires>
      <requires description="assignedFieldFullName string must not be null" csharp="assignedFieldFullName != null" vb="assignedFieldFullName &lt;&gt; Nothing">assignedFieldFullName != null</requires>
      <requires description="assignedFieldFullName string must not be empty" csharp="assignedFieldFullName.Length &gt; 0" vb="assignedFieldFullName.Length &gt; 0">assignedFieldFullName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)">
      <summary>
            Returns a non-null depth value, if <paramref name="method" /> is assigning, <b>directly or indirectly</b>, a field whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="assignedFieldFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" /> must be used instead.
            </summary>
      <param name="method">This method.</param>
      <param name="assignedFieldFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of the assigned field.<br />
            The string <paramref name="assignedFieldFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several fields are matched by <paramref name="assignedFieldFullName" />, this method has a <i>assigning <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several fields are matched by <paramref name="assignedFieldFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <returns>
        <i>assignedField</i> being a <see cref="T:NDepend.CodeModel.IField" /> whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="assignedFieldFullName" />: <br />
            Returns null if <paramref name="method" /> is not directly nor indirectly assigning a <i>assignedField</i>.<br />
            Returns 0 if <paramref name="method" /> is assigning a <i>assignedField</i>.<br />
            Returns 1 if <paramref name="method" /> is calling a method that is assigning a <i>assignedField</i>.<br />
            Returns 2 if <paramref name="method" /> is calling a method, that is calling a method, that is assigning a <i>assignedField</i>.<br />
            ...<br />
            If a non-null number is returned, returns the lowest possible number.
            </returns>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" /> must be used instead.</exception>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="method object must not be null" csharp="method != null" vb="method &lt;&gt; Nothing">method != null</requires>
      <requires description="assignedFieldFullName string must not be null" csharp="assignedFieldFullName != null" vb="assignedFieldFullName &lt;&gt; Nothing">assignedFieldFullName != null</requires>
      <requires description="assignedFieldFullName string must not be empty" csharp="assignedFieldFullName.Length &gt; 0" vb="assignedFieldFullName.Length &gt; 0">assignedFieldFullName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)">
      <summary>
            Returns true if <paramref name="method" /> is calling a constructor of a type, whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="createdTypeFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" /> must be used instead.
            </summary>
      <param name="method">This method.</param>
      <param name="createdTypeFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of the instantiated type.<br />
            The string <paramref name="createdTypeFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several types are matched by <paramref name="createdTypeFullName" />, this method has a <i>creates an instance of <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several types are matched by <paramref name="createdTypeFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <returns>
        <i>createdType</i> being a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="createdTypeFullName" />: <br />
            Returns true if <paramref name="method" /> is creating an instance of <i>createdType</i>, otherwise returns false.<br /></returns>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" /> must be used instead.</exception>
      <seealso cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="method object must not be null" csharp="method != null" vb="method &lt;&gt; Nothing">method != null</requires>
      <requires description="createdTypeFullName string must not be null" csharp="createdTypeFullName != null" vb="createdTypeFullName &lt;&gt; Nothing">createdTypeFullName != null</requires>
      <requires description="createdTypeFullName string must not be empty" csharp="createdTypeFullName.Length &gt; 0" vb="createdTypeFullName.Length &gt; 0">createdTypeFullName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)">
      <summary>
            Returns true if <paramref name="method" /> is calling, <b>directly or indirectly</b>, a constructor of a type, whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="createdTypeFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" /> must be used instead.
            </summary>
      <param name="method">This method.</param>
      <param name="createdTypeFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of the instantiated type.<br />
            The string <paramref name="createdTypeFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several types are matched by <paramref name="createdTypeFullName" />, this method has a <i>creates an instance of <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several types are matched by <paramref name="createdTypeFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <returns>
        <i>createdType</i> being a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="createdTypeFullName" />: <br />
            Returns true if <paramref name="method" /> is calling, <b>directly or indirectly</b>, a constructor of <i>createdType</i>, otherwise returns false.<br /></returns>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" /> must be used instead.</exception>
      <seealso cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="method object must not be null" csharp="method != null" vb="method &lt;&gt; Nothing">method != null</requires>
      <requires description="createdTypeFullName string must not be null" csharp="createdTypeFullName != null" vb="createdTypeFullName &lt;&gt; Nothing">createdTypeFullName != null</requires>
      <requires description="createdTypeFullName string must not be empty" csharp="createdTypeFullName.Length &gt; 0" vb="createdTypeFullName.Length &gt; 0">createdTypeFullName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)">
      <summary>
            Returns a non-null depth value, if <paramref name="method" /> is creating, <b>directly or indirectly</b>, an instance of a type, whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="createdTypeFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" /> must be used instead.
            </summary>
      <param name="method">This method.</param>
      <param name="createdTypeFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of the instantiated type.<br />
            The string <paramref name="createdTypeFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several types are matched by <paramref name="createdTypeFullName" />, this method has a <i>creates an instance of <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several types are matched by <paramref name="createdTypeFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <returns>
        <i>createdType</i> being a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="createdTypeFullName" />: <br />
            Returns null if <paramref name="method" /> is not directly nor indirectly creating an instance of <i>createdType</i>.<br />
            Returns 0 if <paramref name="method" /> is a constructor of <i>createdType</i>.<br />
            Returns 1 if <paramref name="method" /> is calling a constructor of <i>createdType</i>.<br />
            Returns 2 if <paramref name="method" /> is calling a method, that is calling a constructor of <i>createdType</i>.<br />
            ...<br />
            If a non-null number is returned, returns the lowest possible number.
            </returns>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" /> must be used instead.</exception>
      <seealso cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="method object must not be null" csharp="method != null" vb="method &lt;&gt; Nothing">method != null</requires>
      <requires description="createdTypeFullName string must not be null" csharp="createdTypeFullName != null" vb="createdTypeFullName &lt;&gt; Nothing">createdTypeFullName != null</requires>
      <requires description="createdTypeFullName string must not be empty" csharp="createdTypeFullName.Length &gt; 0" vb="createdTypeFullName.Length &gt; 0">createdTypeFullName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.FieldTypeIs(NDepend.CodeModel.IField,System.String)">
      <summary>
            Returns true if <paramref name="field" /> has a field type whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="fieldTypeFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the property getter <see cref="T:NDepend.CodeModel.IField" />.<see cref="P:NDepend.CodeModel.IField.FieldType" /> must be used instead.
            </summary>
      <param name="field">This field.</param>
      <param name="fieldTypeFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of this field's type.<br />
            The string <paramref name="fieldTypeFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several types are matched by <paramref name="fieldTypeFullName" />, this method has a <i>has <b>any</b> field type</i> behavior.
            </param>
      <remarks>
            If one or several types are matched by <paramref name="fieldTypeFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <returns>
        <i>fieldType</i> being a <see cref="T:NDepend.CodeModel.IType" /> whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="fieldTypeFullName" />: <br />
            Returns true if <paramref name="field" /> has for field type a <i>fieldType</i>, otherwise returns false.<br /></returns>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the property getter <see cref="T:NDepend.CodeModel.IField" />.<see cref="P:NDepend.CodeModel.IField.FieldType" /> must be used instead.</exception>
      <see cref="P:NDepend.CodeModel.IField.FieldType" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithFieldType(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithFieldTypeIn(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <requires description="field object must not be null" csharp="field != null" vb="field &lt;&gt; Nothing">field != null</requires>
      <requires description="fieldTypeFullName string must not be null" csharp="fieldTypeFullName != null" vb="fieldTypeFullName &lt;&gt; Nothing">fieldTypeFullName != null</requires>
      <requires description="fieldTypeFullName string must not be empty" csharp="fieldTypeFullName.Length &gt; 0" vb="fieldTypeFullName.Length &gt; 0">fieldTypeFullName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)">
      <summary>
            Returns true if this <paramref name="attributeTargetCodeElement" /> is directly tagged by a attribute class whose <see cref="P:NDepend.CodeModel.IMember.FullName" /> is <paramref name="attributeTypeFullName" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the method <see cref="T:NDepend.CodeModel.IAttributeTarget" />.<see cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" /> must be called instead.
            </summary>
      <param name="attributeTargetCodeElement">This <see cref="T:NDepend.CodeModel.IAttributeTarget" /> object. A <see cref="T:NDepend.CodeModel.IAttributeTarget" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <param name="attributeTypeFullName">
            The <see cref="P:NDepend.CodeModel.IMember.FullName" /> of the attribute type.<br />
            The string <paramref name="attributeTypeFullName" /> can contain wildcard '*' characters but cannot be just a single wildcard string "*".<br />
            If one or several code elements are matched by <paramref name="attributeTypeFullName" />, this method has a <i>tagged by <b>any</b></i> behavior.
            </param>
      <remarks>
            If one or several attribute classes are matched by <paramref name="attributeTypeFullName" />, they will be listed in <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements" />.<br />
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.IAttributeTarget" />.<see cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" /> must be called instead.</exception>
      <requires description="attributeTargetCodeElement object must not be null" csharp="attributeTargetCodeElement != null" vb="attributeTargetCodeElement &lt;&gt; Nothing">attributeTargetCodeElement != null</requires>
      <requires description="attributeTypeFullName string must not be null" csharp="attributeTypeFullName != null" vb="attributeTypeFullName &lt;&gt; Nothing">attributeTypeFullName != null</requires>
      <requires description="attributeTypeFullName string must not be empty" csharp="attributeTypeFullName.Length &gt; 0" vb="attributeTypeFullName.Length &gt; 0">attributeTypeFullName.Length &gt; 0</requires>
    </member>
    <member name="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqNaming">
      <summary>
            Presents extension methods to match code elements and members by name, through regular expressions.
            </summary>
      <remarks>
        <b>These extension methods exist for CQLinq friendly syntax reasons</b> and can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />.<br />
            Indeed they all require a special regular expressions compilation step prior to query execution, that compiles once for all, specified regular expressions.<br />
            The user doesn't have to write this regular expressions compilation step. This results in less syntax burden.<br />
            For each of these extension methods, there are some corresponding methods in <see cref="N:NDepend.CodeModel" />, that can be called to get the same action done.<br />
            This pre regular expression compilation step is weaved at CQLinq compilation time, the CQLinq compiler takes care of transforming calls to these extension methods adequately.<br />
            These extension methods cannot be called from a program consuming NDepend.API, since it would provoke regular expressions to be compiled for each code elements.
            </remarks>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqNaming.NameLike(NDepend.CodeModel.ICodeElement,System.String)">
      <summary>
            Returns true if this <paramref name="codeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.Name" /> string matches the regular expression <paramref name="regexString" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsNaming" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" /> must be called instead.
            </summary>
      <param name="codeElement">This <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <param name="regexString">
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </param>
      <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ExtensionMethodsNaming" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" /> must be called instead.</exception>
      <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <requires description="this codeElement object must not be null" csharp="codeElement != null" vb="codeElement &lt;&gt; Nothing">codeElement != null</requires>
      <requires description="regexString must not be null" csharp="regexString != null" vb="regexString &lt;&gt; Nothing">regexString != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqNaming.SimpleNameLike(NDepend.CodeModel.ISimpleNamed,System.String)">
      <summary>
            Returns true if this <paramref name="codeElement" />.<see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" /> string matches the regular expression <paramref name="regexString" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsNaming" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" /> must be called instead.
            </summary>
      <param name="codeElement">This <see cref="T:NDepend.CodeModel.ISimpleNamed" /> object. A <see cref="T:NDepend.CodeModel.ISimpleNamed" /> object can be a <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.INamespace" /> object.</param>
      <param name="regexString">
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </param>
      <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ExtensionMethodsNaming" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" /> must be called instead.</exception>
      <seealso cref="P:NDepend.CodeModel.IMember.FullName" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToSimpleNameLikePredicate(System.String)" />
      <requires description="this code element object must not be null" csharp="codeElement != null" vb="codeElement &lt;&gt; Nothing">codeElement != null</requires>
      <requires description="regexString must not be null" csharp="regexString != null" vb="regexString &lt;&gt; Nothing">regexString != null</requires>
    </member>
    <member name="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqNaming.FullNameLike(NDepend.CodeModel.IMember,System.String)">
      <summary>
            Returns true if this <paramref name="member" />.<see cref="P:NDepend.CodeModel.IMember.FullName" /> string matches the regular expression <paramref name="regexString" />. This method can only be called in a <see cref="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext" />, otherwise the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsNaming" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" /> must be called instead.
            </summary>
      <param name="member">This <see cref="T:NDepend.CodeModel.IMember" /> object. A <see cref="T:NDepend.CodeModel.IMember" /> object can be a <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <param name="regexString">
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </param>
      <remarks>
            In the context of a CQLinq compiled query, this method has a constant time complexity.
            </remarks>
      <exception cref="T:System.NotImplementedException">This extension method cannot be called from a program consuming NDepend.API. In such context, the method <see cref="T:NDepend.CodeModel.ExtensionMethodsNaming" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" /> must be called instead.</exception>
      <seealso cref="P:NDepend.CodeModel.IMember.FullName" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToMemberFullNameLikePredicate(System.String)" />
      <requires description="this member object must not be null" csharp="member != null" vb="member &lt;&gt; Nothing">member != null</requires>
      <requires description="regexString must not be null" csharp="regexString != null" vb="regexString &lt;&gt; Nothing">regexString != null</requires>
    </member>
    <member name="T:NDepend.CodeModel.ExtensionMethodsHelpers">
      <summary>
            Provides a set of extension methods that makes the code model API usage more convenient to use. 
            </summary>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)">
      <summary>Creates a new <see cref="T:NDepend.CodeModel.ICompareContext" /> object, with <paramref name="newer" /> for <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> and <paramref name="older" /> for <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />.</summary>
      <param name="newer">The <see cref="T:NDepend.CodeModel.ICodeBase" /> object that represents the <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> in the created compare context.</param>
      <param name="older">The <see cref="T:NDepend.CodeModel.ICodeBase" /> object that represents the <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" /> in the created compare context.</param>
      <seealso cref="T:NDepend.CodeModel.ICompareContext" />
      <seealso cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare" />
      <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)" />
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.ICollection{System.String},NDepend.CodeModel.ICompareContext)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceFileLine,NDepend.CodeModel.ISourceFileLine)" />
      <requires description="newer must not be null" csharp="newer != null" vb="newer &lt;&gt; Nothing">newer != null</requires>
      <requires description="older must not be null" csharp="older != null" vb="older &lt;&gt; Nothing">older != null</requires>
      <ensures description="return ICompareContext object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.ExceptThirdParty``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Filter code elements object from this <paramref name="codeElements" /> sequence. Keeps only code elements for those <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.IsThirdParty" /> is <i>false</i>.
            </summary>
      <param name="codeElements">This sequence of code elements objects.</param>
      <returns>A sequence of code elements objects with a <i>false</i> value for <see cref="P:NDepend.CodeModel.ICodeElement.IsThirdParty" />.</returns>
      <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
      <remarks>
            This extension method has a <i>O(<paramref name="codeElements" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.ICodeElement.IsThirdParty" />
      <requires description="seq must not be null" csharp="codeElements != null" vb="codeElements &lt;&gt; Nothing">codeElements != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.ContainsSameCodeElementsThan``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns <i>true</i> if this <paramref name="codeElements" /> sequence contains the same set of code elements than the <paramref name="otherCodeElements" /> sequence. Otherwise returns <i>false</i>.
            </summary>
      <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
      <param name="codeElements">This sequence of code elements objects.</param>
      <param name="otherCodeElements">The other sequence of code elements objects.</param>
      <remarks>
            Notice that both sequences can contain doublons, hence this operation first gets <i><paramref name="codeElements" />.Distinct()</i> and <i><paramref name="otherCodeElements" />.Distinct()</i>.<br />
            This extension method has a <i>O(<paramref name="codeElements" />.Count + <paramref name="otherCodeElements" />.Count)</i> time complexity.
            </remarks>
      <requires description="seq must not be null" csharp="codeElements != null" vb="codeElements &lt;&gt; Nothing">codeElements != null</requires>
      <requires description="otherCodeElements must not be null" csharp="otherCodeElements != null" vb="otherCodeElements &lt;&gt; Nothing">otherCodeElements != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.ContainsSameCodeElementsThan``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.HashSet{``0})">
      <summary>
            Returns <i>true</i> if this <paramref name="codeElements" /> sequence contains the same set of code elements than the <paramref name="otherCodeElementsHashset" /> hashset. Otherwise returns <i>false</i>.
            </summary>
      <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
      <param name="codeElements">This sequence of code elements objects.</param>
      <param name="otherCodeElementsHashset">The hahshet of code elements objects.</param>
      <remarks>
            This <see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ContainsSameCodeElementsThan``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" /> overload, relies on the fact that <paramref name="otherCodeElementsHashset" /> is a hashset to execute with a faster <i>O(<paramref name="codeElements" />.Count)</i> time complexity.<br />
            Notice that <paramref name="codeElements" /> can contain doublons, hence this operation first gets <i><paramref name="codeElements" />.Distinct()</i>.<br /><paramref name="otherCodeElementsHashset" /> necessarily contains distinct code elements.<br /></remarks>
      <requires description="seq must not be null" csharp="codeElements != null" vb="codeElements &lt;&gt; Nothing">codeElements != null</requires>
      <requires description="otherCodeElementsHashset must not be null" csharp="otherCodeElementsHashset != null" vb="otherCodeElementsHashset &lt;&gt; Nothing">otherCodeElementsHashset != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.ContainsSameCodeElementsThan``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.HashSet{``0})">
      <summary>
            Returns <i>true</i> if this <paramref name="codeElementsHashset" /> hashset contains the same set of code elements than the <paramref name="otherCodeElementsHashset" /> hashset. Otherwise returns <i>false</i>.
            </summary>
      <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
      <param name="codeElementsHashset">This hahshet of code elements objects.</param>
      <param name="otherCodeElementsHashset">The other hahshet of code elements objects.</param>
      <remarks>
            This <see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ContainsSameCodeElementsThan``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" /> overload, relies on the fact that both <paramref name="codeElementsHashset" /> and <paramref name="otherCodeElementsHashset" /> are hashsets, to execute with a faster <i>O(<paramref name="codeElementsHashset" />.Count)</i> time complexity.<br /></remarks>
      <requires description="codeElementsHashset must not be null" csharp="codeElementsHashset != null" vb="codeElementsHashset &lt;&gt; Nothing">codeElementsHashset != null</requires>
      <requires description="otherCodeElementsHashset must not be null" csharp="otherCodeElementsHashset != null" vb="otherCodeElementsHashset &lt;&gt; Nothing">otherCodeElementsHashset != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.ContainsSameCodeElementsThan``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns <i>true</i> if this <paramref name="codeElementsHashset" /> hashset contains the same set of code elements than the <paramref name="otherCodeElements" /> sequence. Otherwise returns <i>false</i>.
            </summary>
      <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
      <param name="codeElementsHashset">This hahshet of code elements objects.</param>
      <param name="otherCodeElements">The other sequence of code elements objects.</param>
      <remarks>
            This <see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ContainsSameCodeElementsThan``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" /> overload, relies on the fact that both <paramref name="codeElementsHashset" /> and <paramref name="otherCodeElements" /> are hashsets, to execute with a faster <i>O(<paramref name="otherCodeElements" />.Count)</i> time complexity.<br />
            Notice that <paramref name="otherCodeElements" /> can contain doublons, hence this operation first gets <i><paramref name="otherCodeElements" />.Distinct()</i>.<br /><paramref name="codeElementsHashset" /> necessarily contains distinct code elements.<br /></remarks>
      <requires description="codeElementsHashset must not be null" csharp="codeElementsHashset != null" vb="codeElementsHashset &lt;&gt; Nothing">codeElementsHashset != null</requires>
      <requires description="otherCodeElements must not be null" csharp="otherCodeElements != null" vb="otherCodeElements &lt;&gt; Nothing">otherCodeElements != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.FillIterative``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Iteratively fills a sequence of code elements, until no new element can be added. The first iteration starts with <paramref name="initialSeq" />, and the function <paramref name="func" /> is used to compute new elements of the iteration <i>N+1</i> from new elements computed at iteration <i>N</i>.
            </summary>
      <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
      <param name="initialSeq">The initial sequence of code elements consummed by the first iteration.</param>
      <param name="func">The function used to compute new elements of the iteration <i>N+1</i> from new elements computed at iteration <i>N</i>.</param>
      <returns>A new <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object. The code metric value for each element in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is the iteration number when it was added. Value for code elements in <paramref name="initialSeq" /> is 0.</returns>
      <exception cref="T:System.InvalidOperationException">The number of iterations has outreached the maximum iterations threshold, which is fixed to 100.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="initialSeq" /> or a sequence returned by a call to <paramref name="func" /> contains a null <typeparamref name="TCodeElement" />.</exception>
      <requires description="initialSeq must not be null" csharp="initialSeq != null" vb="initialSeq &lt;&gt; Nothing">initialSeq != null</requires>
      <requires description="func must not be null" csharp="func != null" vb="func &lt;&gt; Nothing">func != null</requires>
      <ensures description="returned code metric object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)">
      <summary>
            Returns a predicate object that takes a <see cref="T:NDepend.CodeModel.ICodeElement" /> object as input parameter, and returns a boolean that determines whether the code element's <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> matches the regular expression <paramref name="regexString" />.
            </summary>
      <param name="regexString">The regular expression string.</param>
      <remarks>
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="regexString" /> is an invalid regular exception.</exception>
      <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqNaming.NameLike(NDepend.CodeModel.ICodeElement,System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToMemberFullNameLikePredicate(System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToSimpleNameLikePredicate(System.String)" />
      <requires description="regexString must not be null" csharp="regexString != null" vb="regexString &lt;&gt; Nothing">regexString != null</requires>
      <ensures description="returned predicate object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToMemberFullNameLikePredicate(System.String)">
      <summary>
            Returns a predicate object that takes a <see cref="T:NDepend.CodeModel.IMember" /> object as input parameter, and returns a boolean that determines whether the member's <see cref="P:NDepend.CodeModel.IMember.FullName" /> matches the regular expression <paramref name="regexString" />.
            </summary>
      <param name="regexString">The regular expression string.</param>
      <remarks>
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="regexString" /> is an invalid regular exception.</exception>
      <seealso cref="P:NDepend.CodeModel.IMember.FullName" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqNaming.FullNameLike(NDepend.CodeModel.IMember,System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToSimpleNameLikePredicate(System.String)" />
      <requires description="regexString must not be null" csharp="regexString != null" vb="regexString &lt;&gt; Nothing">regexString != null</requires>
      <ensures description="returned predicate object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToSimpleNameLikePredicate(System.String)">
      <summary>
            Returns a predicate object that takes a <see cref="T:NDepend.CodeModel.IMethod" /> object as input parameter, and returns a boolean that determines whether the code element's <see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" /> matches the regular expression <paramref name="regexString" />.
            </summary>
      <param name="regexString">The regular expression string.</param>
      <remarks>
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="regexString" /> is an invalid regular exception.</exception>
      <seealso cref="T:NDepend.CodeModel.ISimpleNamed" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToMemberFullNameLikePredicate(System.String)" />
      <requires description="regexString must not be null" csharp="regexString != null" vb="regexString &lt;&gt; Nothing">regexString != null</requires>
      <ensures description="returned predicate object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:NDepend.CodeModel.ExtensionMethodsNaming">
      <summary>
            Provides a set of extension methods to filter a sequence of code elements by <see cref="P:NDepend.CodeModel.IMember.FullName" />, <see cref="P:NDepend.CodeModel.ICodeElement.Name" />  or <see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" />. 
            </summary>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> equals <i>case sensitive</i> to <paramref name="name" /> .
            </summary>
      <param name="seq">This sequence of code elements objects.</param>
      <param name="name">The name string.</param>
      <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
      <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="name must not be null" csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> equals <i>case sensitive</i> to <paramref name="name0" /> or <paramref name="name1" />, or equals to a string contained in <paramref name="names" />.
            </summary>
      <param name="seq">This sequence of code elements objects.</param>
      <param name="name0">One of the possible name string.</param>
      <param name="names">An array of possible name string.</param>
      <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
      <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="name0 must not be null" csharp="name0 != null" vb="name0 &lt;&gt; Nothing">name0 != null</requires>
      <requires description="names must not be null" csharp="names != null" vb="names &lt;&gt; Nothing">names != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> not equals <i>case sensitive</i> to <paramref name="name0" /> and <paramref name="name1" />, and not equals to a string contained in <paramref name="names" />.
            </summary>
      <param name="seq">This sequence of code elements objects.</param>
      <param name="name0">One of the forbidden name string.</param>
      <param name="names">An array of forbidden name string.</param>
      <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
      <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="name0 must not be null" csharp="name0 != null" vb="name0 &lt;&gt; Nothing">name0 != null</requires>
      <requires description="names must not be null" csharp="names != null" vb="names &lt;&gt; Nothing">names != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> matching the regular expression <paramref name="regexString" />.
            </summary>
      <param name="seq">This sequence of code elements objects.</param>
      <param name="regexString">The regular expression string.</param>
      <remarks>
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </remarks>
      <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="regexString" /> is an invalid regular exception.</exception>
      <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqNaming.NameLike(NDepend.CodeModel.ICodeElement,System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="regexString must not be null" csharp="regexString != null" vb="regexString &lt;&gt; Nothing">regexString != null</requires>
      <requires description="regexString must not be empty" csharp="regexString.Length &gt; 0" vb="regexString.Length &gt; 0">regexString.Length &gt; 0</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> matching the wildcard pattern string <paramref name="nameWildcardPattern" />.
            </summary>
      <param name="seq">This sequence of code elements objects.</param>
      <param name="nameWildcardPattern">The wildcard pattern string.</param>
      <remarks>
            The string <paramref name="nameWildcardPattern" /> can contain wildcard '*' characters.<br />
            Hence, if the string <paramref name="nameWildcardPattern" /> is equals to "*", it means <i>match all.</i><br /></remarks>
      <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
      <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="nameWildcardPattern must not be null" csharp="nameWildcardPattern != null" vb="nameWildcardPattern &lt;&gt; Nothing">nameWildcardPattern != null</requires>
      <requires description="nameWildcardPattern must not be empty" csharp="nameWildcardPattern.Length &gt; 0" vb="nameWildcardPattern.Length &gt; 0">nameWildcardPattern.Length &gt; 0</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> matching any wildcard pattern string in <paramref name="nameWildcardPattern0" /> union <paramref name="nameWildcardPatterns" />.
            </summary>
      <param name="seq">This sequence of code elements objects.</param>
      <param name="nameWildcardPattern0">The wildcard pattern string.</param>
      <param name="nameWildcardPatterns">An array of wildcard pattern strings.</param>
      <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="nameWildcardPatterns" /> must not contain a null string.</exception>
      <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="nameWildcardPattern0 must not be null" csharp="nameWildcardPattern0 != null" vb="nameWildcardPattern0 &lt;&gt; Nothing">nameWildcardPattern0 != null</requires>
      <requires description="nameWildcardPatterns must not be null" csharp="nameWildcardPatterns != null" vb="nameWildcardPatterns &lt;&gt; Nothing">nameWildcardPatterns != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> matching none of the wildcard pattern string in <paramref name="nameWildcardPattern0" /> union <paramref name="nameWildcardPatterns" />.
            </summary>
      <param name="seq">This sequence of code elements objects.</param>
      <param name="nameWildcardPattern0">The wildcard pattern string.</param>
      <param name="nameWildcardPatterns">An array of wildcard pattern strings.</param>
      <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="nameWildcardPatterns" /> must not contain a null string.</exception>
      <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToNameLikePredicate(System.String)" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="nameWildcardPattern0 must not be null" csharp="nameWildcardPattern0 != null" vb="nameWildcardPattern0 &lt;&gt; Nothing">nameWildcardPattern0 != null</requires>
      <requires description="nameWildcardPatterns must not be null" csharp="nameWildcardPatterns != null" vb="nameWildcardPatterns &lt;&gt; Nothing">nameWildcardPatterns != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only members objects with <see cref="P:NDepend.CodeModel.IMember.FullName" /> equals <i>case sensitive</i> to <paramref name="fullName" /> .
            </summary>
      <param name="seq">This sequence of members objects.</param>
      <param name="fullName">The member full name string.</param>
      <typeparam name="TMember">The member type that is <see cref="T:NDepend.CodeModel.IMember" /> or that implements <see cref="T:NDepend.CodeModel.IMember" />.</typeparam>
      <seealso cref="P:NDepend.CodeModel.IMember.FullName" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="fullName must not be null" csharp="fullName != null" vb="fullName &lt;&gt; Nothing">fullName != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only members objects with <see cref="P:NDepend.CodeModel.IMember.FullName" /> equals <i>case sensitive</i> to <paramref name="fullName0" /> or <paramref name="fullName1" />, or equals to a string contained in <paramref name="fullNames" />.
            </summary>
      <param name="seq">This sequence of members objects.</param>
      <param name="fullName0">One of the possible full name string.</param>
      <param name="fullNames">An array of possible full name string.</param>
      <typeparam name="TMember">The member type that is <see cref="T:NDepend.CodeModel.IMember" /> or that implements <see cref="T:NDepend.CodeModel.IMember" />.</typeparam>
      <seealso cref="P:NDepend.CodeModel.IMember.FullName" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="fullName1 must not be null" csharp="fullName0 != null" vb="fullName0 &lt;&gt; Nothing">fullName0 != null</requires>
      <requires description="fullNames must not be null" csharp="fullNames != null" vb="fullNames &lt;&gt; Nothing">fullNames != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only members objects with <see cref="P:NDepend.CodeModel.IMember.FullName" /> not equals <i>case sensitive</i> to <paramref name="fullName0" /> and <paramref name="fullName1" />, and not equals to a string contained in <paramref name="fullNames" />.
            </summary>
      <param name="seq">This sequence of members objects.</param>
      <param name="fullName0">One of the forbidden full name string.</param>
      <param name="fullNames">An array of forbidden full name string.</param>
      <typeparam name="TMember">The member type that is <see cref="T:NDepend.CodeModel.IMember" /> or that implements <see cref="T:NDepend.CodeModel.IMember" />.</typeparam>
      <seealso cref="P:NDepend.CodeModel.IMember.FullName" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="fullName1 must not be null" csharp="fullName0 != null" vb="fullName0 &lt;&gt; Nothing">fullName0 != null</requires>
      <requires description="fullNames must not be null" csharp="fullNames != null" vb="fullNames &lt;&gt; Nothing">fullNames != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only members objects with <see cref="P:NDepend.CodeModel.IMember.FullName" /> matching the regular expression <paramref name="regexString" />.
            </summary>
      <param name="seq">This sequence of members objects.</param>
      <param name="regexString">The regular expression string.</param>
      <remarks>
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="regexString" /> is an invalid regular exception.</exception>
      <typeparam name="TMember">The member type that is <see cref="T:NDepend.CodeModel.IMember" /> or that implements <see cref="T:NDepend.CodeModel.IMember" />.</typeparam>
      <seealso cref="P:NDepend.CodeModel.IMember.FullName" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqNaming.FullNameLike(NDepend.CodeModel.IMember,System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToMemberFullNameLikePredicate(System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="regexString must not be null" csharp="regexString != null" vb="regexString &lt;&gt; Nothing">regexString != null</requires>
      <requires description="regexString must not be empty" csharp="regexString.Length &gt; 0" vb="regexString.Length &gt; 0">regexString.Length &gt; 0</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only members objects with <see cref="P:NDepend.CodeModel.IMember.FullName" /> matching the wildcard pattern string <paramref name="fullNameWildcardPattern" />.
            </summary>
      <param name="seq">This sequence of members objects.</param>
      <param name="fullNameWildcardPattern">The wildcard pattern string.</param>
      <remarks>
            The string <paramref name="fullNameWildcardPattern" /> can contain wildcard '*' characters.<br />
            Hence, if the string <paramref name="fullNameWildcardPattern" /> is equals to "*", it means <i>match all.</i><br /></remarks>
      <typeparam name="TMember">The member type that is <see cref="T:NDepend.CodeModel.IMember" /> or that implements <see cref="T:NDepend.CodeModel.IMember" />.</typeparam>
      <seealso cref="P:NDepend.CodeModel.IMember.FullName" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="fullNameWildcardPattern must not be null" csharp="fullNameWildcardPattern != null" vb="fullNameWildcardPattern &lt;&gt; Nothing">fullNameWildcardPattern != null</requires>
      <requires description="fullNameWildcardPattern must not be empty" csharp="fullNameWildcardPattern.Length &gt; 0" vb="fullNameWildcardPattern.Length &gt; 0">fullNameWildcardPattern.Length &gt; 0</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only members objects with <see cref="P:NDepend.CodeModel.IMember.FullName" /> matching any wildcard pattern string in <paramref name="fullNameWildcardPattern0" /> union <paramref name="fullNameWildcardPatterns" />.
            </summary>
      <param name="seq">This sequence of members objects.</param>
      <param name="fullNameWildcardPattern0">The wildcard pattern string.</param>
      <param name="fullNameWildcardPatterns">An array of wildcard pattern strings.</param>
      <typeparam name="TMember">The member type that is <see cref="T:NDepend.CodeModel.IMember" /> or that implements <see cref="T:NDepend.CodeModel.IMember" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fullNameWildcardPatterns" /> must not contain a null string.</exception>
      <seealso cref="P:NDepend.CodeModel.IMember.FullName" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="fullNameWildcardPattern0 must not be null" csharp="fullNameWildcardPattern0 != null" vb="fullNameWildcardPattern0 &lt;&gt; Nothing">fullNameWildcardPattern0 != null</requires>
      <requires description="fullNameWildcardPatterns must not be null" csharp="fullNameWildcardPatterns != null" vb="fullNameWildcardPatterns &lt;&gt; Nothing">fullNameWildcardPatterns != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only members objects with <see cref="P:NDepend.CodeModel.IMember.FullName" /> matching none of the wildcard pattern string in <paramref name="fullNameWildcardPattern0" /> union <paramref name="fullNameWildcardPatterns" />.
            </summary>
      <param name="seq">This sequence of members objects.</param>
      <param name="fullNameWildcardPattern0">The wildcard pattern string.</param>
      <param name="fullNameWildcardPatterns">An array of wildcard pattern strings.</param>
      <typeparam name="TMember">The member type that is <see cref="T:NDepend.CodeModel.IMember" /> or that implements <see cref="T:NDepend.CodeModel.IMember" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="fullNameWildcardPatterns" /> must not contain a null string.</exception>
      <seealso cref="P:NDepend.CodeModel.IMember.FullName" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="fullNameWildcardPattern0 must not be null" csharp="fullNameWildcardPattern0 != null" vb="fullNameWildcardPattern0 &lt;&gt; Nothing">fullNameWildcardPattern0 != null</requires>
      <requires description="fullNameWildcardPatterns must not be null" csharp="fullNameWildcardPatterns != null" vb="fullNameWildcardPatterns &lt;&gt; Nothing">fullNameWildcardPatterns != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements with <see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" /> equals <i>case sensitive</i> to <paramref name="simpleName" /> .
            </summary>
      <param name="seq">This sequence of methods objects.</param>
      <param name="simpleName">The method simple name string.</param>
      <seealso cref="T:NDepend.CodeModel.ISimpleNamed" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="simpleName must not be null" csharp="simpleName != null" vb="simpleName &lt;&gt; Nothing">simpleName != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements objects with <see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" /> equals <i>case sensitive</i> to <paramref name="simpleName0" /> or equals to a string contained in <paramref name="simpleNames" />.
            </summary>
      <param name="seq">This sequence of methods objects.</param>
      <param name="simpleName0">One of the possible simple name string.</param>
      <param name="simpleNames">An array of possible simple name string.</param>
      <seealso cref="T:NDepend.CodeModel.ISimpleNamed" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="simpleName1 must not be null" csharp="simpleName0 != null" vb="simpleName0 &lt;&gt; Nothing">simpleName0 != null</requires>
      <requires description="simpleNames must not be null" csharp="simpleNames != null" vb="simpleNames &lt;&gt; Nothing">simpleNames != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements with <see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" /> not equals <i>case sensitive</i> to <paramref name="simpleName0" /> and <paramref name="simpleName1" />, and not equals to a string contained in <paramref name="simpleNames" />.
            </summary>
      <param name="seq">This sequence of methods objects.</param>
      <param name="simpleName0">One of the possible simple name string.</param>
      <param name="simpleNames">An array of possible simple name string.</param>
      <seealso cref="T:NDepend.CodeModel.ISimpleNamed" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="simpleName1 must not be null" csharp="simpleName0 != null" vb="simpleName0 &lt;&gt; Nothing">simpleName0 != null</requires>
      <requires description="simpleNames must not be null" csharp="simpleNames != null" vb="simpleNames &lt;&gt; Nothing">simpleNames != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements with <see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" /> matching the regular expression <paramref name="regexString" />.
            </summary>
      <param name="seq">This sequence of methods objects.</param>
      <param name="regexString">The regular expression string.</param>
      <remarks>
            The regular expression is defined with the <i>System.Text.RegularExpressions</i> syntax.<br />
            The regular expression string can be suffixed with <i>"\i"</i> to specify the <i>ignore case</i> option.
            </remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="regexString" /> is an invalid regular exception.</exception>
      <seealso cref="T:NDepend.CodeModel.ISimpleNamed" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="regexString must not be null" csharp="regexString != null" vb="regexString &lt;&gt; Nothing">regexString != null</requires>
      <requires description="regexString must not be empty" csharp="regexString.Length &gt; 0" vb="regexString.Length &gt; 0">regexString.Length &gt; 0</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements with <see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" /> matching the wildcard pattern string <paramref name="simpleNameWildcardPattern" />.
            </summary>
      <param name="seq">This sequence of methods objects.</param>
      <param name="simpleNameWildcardPattern">The wildcard pattern string.</param>
      <remarks>
            The string <paramref name="simpleNameWildcardPattern" /> can contain wildcard '*' characters.<br />
            Hence, if the string <paramref name="simpleNameWildcardPattern" /> is equals to "*", it means <i>match all.</i><br /></remarks>
      <seealso cref="T:NDepend.CodeModel.ISimpleNamed" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="simpleNameWildcardPattern must not be null" csharp="simpleNameWildcardPattern != null" vb="simpleNameWildcardPattern &lt;&gt; Nothing">simpleNameWildcardPattern != null</requires>
      <requires description="simpleNameWildcardPattern must not be empty" csharp="simpleNameWildcardPattern.Length &gt; 0" vb="simpleNameWildcardPattern.Length &gt; 0">simpleNameWildcardPattern.Length &gt; 0</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements with <see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" /> matching any wildcard pattern string in <paramref name="simpleNameWildcardPattern0" /> union <paramref name="simpleNameWildcardPatterns" />.
            </summary>
      <param name="seq">This sequence of methods objects.</param>
      <param name="simpleNameWildcardPattern0">A wildcard pattern string.</param>
      <param name="simpleNameWildcardPatterns">An array of wildcard pattern strings.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="simpleNameWildcardPatterns" /> must not contain a null string.</exception>
      <seealso cref="T:NDepend.CodeModel.ISimpleNamed" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="simpleNameWildcardPattern0 must not be null" csharp="simpleNameWildcardPattern0 != null" vb="simpleNameWildcardPattern0 &lt;&gt; Nothing">simpleNameWildcardPattern0 != null</requires>
      <requires description="simpleNameWildcardPatterns must not be null" csharp="simpleNameWildcardPatterns != null" vb="simpleNameWildcardPatterns &lt;&gt; Nothing">simpleNameWildcardPatterns != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="seq" />, containing only code elements with <see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" /> matching none of the wildcard pattern string in <paramref name="simpleNameWildcardPattern0" /> union <paramref name="simpleNameWildcardPatterns" />.
            </summary>
      <param name="seq">This sequence of methods objects.</param>
      <param name="simpleNameWildcardPattern0">A wildcard pattern string.</param>
      <param name="simpleNameWildcardPatterns">An array of wildcard pattern strings.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="simpleNameWildcardPatterns" /> must not contain a null string.</exception>
      <seealso cref="T:NDepend.CodeModel.ISimpleNamed" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithSimpleNameWildcardMatchIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <requires description="seq must not be null" csharp="seq != null" vb="seq &lt;&gt; Nothing">seq != null</requires>
      <requires description="simpleNameWildcardPattern0 must not be null" csharp="simpleNameWildcardPattern0 != null" vb="simpleNameWildcardPattern0 &lt;&gt; Nothing">simpleNameWildcardPattern0 != null</requires>
      <requires description="simpleNameWildcardPatterns must not be null" csharp="simpleNameWildcardPatterns != null" vb="simpleNameWildcardPatterns &lt;&gt; Nothing">simpleNameWildcardPatterns != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:NDepend.CodeModel.ExtensionMethodsProjection">
      <summary>
            Provides a set of extension methods to realize projection of a sequence of code elements to a sequence of children or parents code elements. 
            </summary>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects, containing all <see cref="P:NDepend.CodeModel.IAssembly.ChildNamespaces" /> objects of all <see cref="T:NDepend.CodeModel.IAssembly" /> objects contained in this sequence <paramref name="assemblies" />.
            </summary>
      <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
      <requires description="assemblies must not be null" csharp="assemblies != null" vb="assemblies &lt;&gt; Nothing">assemblies != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IType" /> objects, containing all <see cref="P:NDepend.CodeModel.IAssembly.ChildTypes" /> objects of all <see cref="T:NDepend.CodeModel.IAssembly" /> objects contained in this sequence <paramref name="assemblies" />.
            </summary>
      <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
      <requires description="assemblies must not be null" csharp="assemblies != null" vb="assemblies &lt;&gt; Nothing">assemblies != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildMethods(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects, containing all <see cref="P:NDepend.CodeModel.IAssembly.ChildMethods" /> objects of all <see cref="T:NDepend.CodeModel.IAssembly" /> objects contained in this sequence <paramref name="assemblies" />.
            </summary>
      <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
      <requires description="assemblies must not be null" csharp="assemblies != null" vb="assemblies &lt;&gt; Nothing">assemblies != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IAssembly})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IField" /> objects, containing all <see cref="P:NDepend.CodeModel.IAssembly.ChildFields" /> objects of all <see cref="T:NDepend.CodeModel.IAssembly" /> objects contained in this sequence <paramref name="assemblies" />.
            </summary>
      <param name="assemblies">This sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects.</param>
      <requires description="assemblies must not be null" csharp="assemblies != null" vb="assemblies &lt;&gt; Nothing">assemblies != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentAssemblies(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects, containing all distinct <see cref="P:NDepend.CodeModel.INamespace.ParentAssembly" /> objects of all <see cref="T:NDepend.CodeModel.INamespace" /> objects contained in this sequence <paramref name="namespaces" />.
            </summary>
      <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
      <requires description="namespaces must not be null" csharp="namespaces != null" vb="namespaces &lt;&gt; Nothing">namespaces != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IType" /> objects, containing all <see cref="P:NDepend.CodeModel.INamespace.ChildTypes" /> objects of all <see cref="T:NDepend.CodeModel.INamespace" /> objects contained in this sequence <paramref name="namespaces" />.
            </summary>
      <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
      <requires description="namespaces must not be null" csharp="namespaces != null" vb="namespaces &lt;&gt; Nothing">namespaces != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildMethods(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects, containing all <see cref="P:NDepend.CodeModel.INamespace.ChildMethods" /> objects of all <see cref="T:NDepend.CodeModel.INamespace" /> objects contained in this sequence <paramref name="namespaces" />.
            </summary>
      <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
      <requires description="namespaces must not be null" csharp="namespaces != null" vb="namespaces &lt;&gt; Nothing">namespaces != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.INamespace})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IField" /> objects, containing all <see cref="P:NDepend.CodeModel.INamespace.ChildFields" /> objects of all <see cref="T:NDepend.CodeModel.INamespace" /> objects contained in this sequence <paramref name="namespaces" />.
            </summary>
      <param name="namespaces">This sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects.</param>
      <requires description="namespaces must not be null" csharp="namespaces != null" vb="namespaces &lt;&gt; Nothing">namespaces != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentAssemblies(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects, containing all distinct <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> objects of all <see cref="T:NDepend.CodeModel.IType" /> objects contained in this sequence <paramref name="types" />.
            </summary>
      <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
      <requires description="types must not be null" csharp="types != null" vb="types &lt;&gt; Nothing">types != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects, containing all distinct <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects of all <see cref="T:NDepend.CodeModel.IType" /> objects contained in this sequence <paramref name="types" />.
            </summary>
      <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
      <requires description="types must not be null" csharp="types != null" vb="types &lt;&gt; Nothing">types != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildMethods(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects, containing all <see cref="P:NDepend.CodeModel.IType.MethodsAndContructors" /> objects of all <see cref="T:NDepend.CodeModel.IType" /> objects contained in this sequence <paramref name="types" />.
            </summary>
      <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IType" /> objects.</param>
      <requires description="types must not be null" csharp="types != null" vb="types &lt;&gt; Nothing">types != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ChildFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IField" /> objects, containing all <see cref="P:NDepend.CodeModel.IType.Fields" /> objects of all <see cref="T:NDepend.CodeModel.IType" /> objects contained in this sequence <paramref name="types" />.
            </summary>
      <param name="types">This sequence of <see cref="T:NDepend.CodeModel.IField" /> objects.</param>
      <requires description="types must not be null" csharp="types != null" vb="types &lt;&gt; Nothing">types != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentAssemblies(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects, containing all distinct <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> objects of all <see cref="T:NDepend.CodeModel.IMethod" /> objects contained in this sequence <paramref name="methods" />.
            </summary>
      <param name="methods">This sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects.</param>
      <requires description="methods must not be null" csharp="methods != null" vb="methods &lt;&gt; Nothing">methods != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects, containing all distinct <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects of all <see cref="T:NDepend.CodeModel.IMethod" /> objects contained in this sequence <paramref name="methods" />.
            </summary>
      <param name="methods">This sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects.</param>
      <requires description="methods must not be null" csharp="methods != null" vb="methods &lt;&gt; Nothing">methods != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IType" /> objects, containing all distinct <see cref="P:NDepend.CodeModel.IMember.ParentType" /> objects of all <see cref="T:NDepend.CodeModel.IMethod" /> objects contained in this sequence <paramref name="methods" />.
            </summary>
      <param name="methods">This sequence of <see cref="T:NDepend.CodeModel.IMethod" /> objects.</param>
      <requires description="methods must not be null" csharp="methods != null" vb="methods &lt;&gt; Nothing">methods != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentAssemblies(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IAssembly" /> objects, containing all distinct <see cref="P:NDepend.CodeModel.IMember.ParentAssembly" /> objects of all <see cref="T:NDepend.CodeModel.IField" /> objects contained in this sequence <paramref name="fields" />.
            </summary>
      <param name="fields">This sequence of <see cref="T:NDepend.CodeModel.IField" /> objects.</param>
      <requires description="fields must not be null" csharp="fields != null" vb="fields &lt;&gt; Nothing">fields != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentNamespaces(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.INamespace" /> objects, containing all distinct <see cref="P:NDepend.CodeModel.IMember.ParentNamespace" /> objects of all <see cref="T:NDepend.CodeModel.IField" /> objects contained in this sequence <paramref name="fields" />.
            </summary>
      <param name="fields">This sequence of <see cref="T:NDepend.CodeModel.IField" /> objects.</param>
      <requires description="fields must not be null" csharp="fields != null" vb="fields &lt;&gt; Nothing">fields != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsProjection.ParentTypes(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
      <summary>
            Returns a sequence of <see cref="T:NDepend.CodeModel.IType" /> objects, containing all distinct <see cref="P:NDepend.CodeModel.IMember.ParentType" /> objects of all <see cref="T:NDepend.CodeModel.IField" /> objects contained in this sequence <paramref name="fields" />.
            </summary>
      <param name="fields">This sequence of <see cref="T:NDepend.CodeModel.IField" /> objects.</param>
      <requires description="fields must not be null" csharp="fields != null" vb="fields &lt;&gt; Nothing">fields != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage">
      <summary>
            Provides a set of extension methods to resolve incoming or outgoing dependencies, from or to, a sequence of code elements.
            </summary>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedBy``2(System.Collections.Generic.IEnumerable{``0},``1)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUsed" />, containing only code elements directly used by <paramref name="codeElementUser" /> .
            </summary>
      <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
      <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
      <param name="codeElementsUsed">This sequence of code elements.</param>
      <param name="codeElementUser">The code element that uses code elements in the returned sequence.</param>
      <remarks>This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count)</i> time complexity.</remarks>
      <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <requires description="codeElementsUsed must not be null" csharp="codeElementsUsed != null" vb="codeElementsUsed &lt;&gt; Nothing">codeElementsUsed != null</requires>
      <requires description="codeElementUser must not be null" csharp="(object)codeElementUser != null" vb="((Object)codeElementUser) &lt;&gt; Nothing">(object)codeElementUser != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUsed" />, containing only code elements directly used by <i>any</i> code element in the sequence <paramref name="codeElementsUser" /> .
            </summary>
      <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
      <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
      <param name="codeElementsUsed">This sequence of code elements.</param>
      <param name="codeElementsUser">The sequence of code elements that uses code elements in the returned sequence.</param>
      <remarks>
            Elements contained in both sequences are removed from the result, since such element is used by itelf.<br />
            This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count + <paramref name="codeElementsUser" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <requires description="codeElementsUsed must not be null" csharp="codeElementsUsed != null" vb="codeElementsUsed &lt;&gt; Nothing">codeElementsUsed != null</requires>
      <requires description="codeElementsUser" csharp="codeElementsUser != null" vb="codeElementsUser &lt;&gt; Nothing">codeElementsUser != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUsed" />, containing only code elements directly used by <i>all</i> code elements in the sequence <paramref name="codeElementsUser" /> .
            </summary>
      <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
      <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
      <param name="codeElementsUsed">This sequence of code elements.</param>
      <param name="codeElementsUser">The sequence of code elements that all uses code elements in the returned sequence.</param>
      <remarks>
            This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count)</i> time complexity if <typeparamref name="TUsed" /> is strictly finer-grained than <typeparamref name="TUser" />, like for example <typeparamref name="TUser" /> is <see cref="T:NDepend.CodeModel.INamespace" /> and <typeparamref name="TUsed" /> is <see cref="T:NDepend.CodeModel.IType" />. <br />
            Otherwise it has a O(<paramref name="codeElementsUser" />.Count) time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <requires description="codeElementsUsed must not be null" csharp="codeElementsUsed != null" vb="codeElementsUsed &lt;&gt; Nothing">codeElementsUsed != null</requires>
      <requires description="codeElementsUser" csharp="codeElementsUser != null" vb="codeElementsUser &lt;&gt; Nothing">codeElementsUser != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedBy``2(System.Collections.Generic.IEnumerable{``0},``1)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUsed" />, containing only code elements <i>directly or indirectly</i> used by <paramref name="codeElementUser" /> .
            </summary>
      <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
      <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
      <param name="codeElementsUsed">This sequence of code elements.</param>
      <param name="codeElementUser">The code element that uses <i>directly or indirectly</i> code elements in the returned sequence.</param>
      <remarks>This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count)</i> time complexity.</remarks>
      <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsing``2(System.Collections.Generic.IEnumerable{``0},``1)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <requires description="codeElementsUsed must not be null" csharp="codeElementsUsed != null" vb="codeElementsUsed &lt;&gt; Nothing">codeElementsUsed != null</requires>
      <requires description="codeElementUser must not be null" csharp="(object)codeElementUser != null" vb="((Object)codeElementUser) &lt;&gt; Nothing">(object)codeElementUser != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUsed" />, containing only code elements <i>directly or indirectly</i> used by <i>any</i> code element in the sequence <paramref name="codeElementsUser" /> .
            </summary>
      <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
      <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
      <param name="codeElementsUsed">This sequence of code elements.</param>
      <param name="codeElementsUser">The sequence of code elements that <i>directly or indirectly</i> uses code elements in the returned sequence.</param>
      <remarks>
            Elements contained in both sequences are removed from the result, since such element is used by itelf.<br />
            This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count + <paramref name="codeElementsUser" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedBy``2(System.Collections.Generic.IEnumerable{``0},``1)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsing``2(System.Collections.Generic.IEnumerable{``0},``1)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <requires description="codeElementsUsed must not be null" csharp="codeElementsUsed != null" vb="codeElementsUsed &lt;&gt; Nothing">codeElementsUsed != null</requires>
      <requires description="codeElementsUser" csharp="codeElementsUser != null" vb="codeElementsUser &lt;&gt; Nothing">codeElementsUser != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsedBy``2(System.Collections.Generic.IEnumerable{``0},``1)">
      <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="codeElementsUsed" />, containing only code elements <i>directly or indirectly</i> used by <paramref name="codeElementUser" />. The metric value for each code element in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the depth of usage.
            </summary>
      <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
      <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
      <param name="codeElementsUsed">This sequence of code elements.</param>
      <param name="codeElementUser">The code element that uses <i>directly or indirectly</i> code elements in the returned sequence.</param>
      <remarks>
            If <paramref name="codeElementUser" /> or a child or parent of <paramref name="codeElementUser" /> is in the returned sequence, its depth of usage is 0.<br />
            The depth of usage of a code element in <paramref name="codeElementsUsed" />, directly used by <paramref name="codeElementUser" /> or a child or parent of <paramref name="codeElementUser" />, is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <requires description="codeElementsUsed must not be null" csharp="codeElementsUsed != null" vb="codeElementsUsed &lt;&gt; Nothing">codeElementsUsed != null</requires>
      <requires description="codeElementUser must not be null" csharp="(object)codeElementUser != null" vb="((Object)codeElementUser) &lt;&gt; Nothing">(object)codeElementUser != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="codeElementsUsed" />, containing only code elements <i>directly or indirectly</i> used by <i>any</i> code element in <paramref name="codeElementsUser" />. The metric value for each code element in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the depth of usage.
            </summary>
      <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
      <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
      <param name="codeElementsUsed">This sequence of code elements.</param>
      <param name="codeElementsUser">The sequence of code elements that uses <i>directly or indirectly</i> code elements in the returned sequence.</param>
      <remarks>
            If a code element in <paramref name="codeElementsUser" /> or a child or parent of a code element in <paramref name="codeElementsUser" />, is in the returned sequence, its depth of usage is 0.<br />
            The depth of usage of a code element in <paramref name="codeElementsUsed" />, directly used by a code element in <paramref name="codeElementsUser" /> or a child or parent of a code element in <paramref name="codeElementsUser" />, is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count + <paramref name="codeElementsUser" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedByAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsedBy``2(System.Collections.Generic.IEnumerable{``0},``1)" />
      <requires description="codeElementsUsed must not be null" csharp="codeElementsUsed != null" vb="codeElementsUsed &lt;&gt; Nothing">codeElementsUsed != null</requires>
      <requires description="codeElementsUser" csharp="codeElementsUser != null" vb="codeElementsUser &lt;&gt; Nothing">codeElementsUser != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.Using``2(System.Collections.Generic.IEnumerable{``0},``1)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUser" />, containing only code elements directly using <paramref name="codeElementUsed" /> .
            </summary>
      <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
      <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
      <param name="codeElementsUser">This sequence of code elements.</param>
      <param name="codeElementUsed">The code element that is used by code elements in the returned sequence.</param>
      <remarks>This extension method has a <i>O(<paramref name="codeElementsUser" />.Count)</i> time complexity.</remarks>
      <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <requires description="codeElementsUser" csharp="codeElementsUser != null" vb="codeElementsUser &lt;&gt; Nothing">codeElementsUser != null</requires>
      <requires description="codeElementUsed" csharp="(object)codeElementUsed != null" vb="((Object)codeElementUsed) &lt;&gt; Nothing">(object)codeElementUsed != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUser" />, containing only code elements directly used by <i>any</i> code element in the sequence <paramref name="codeElementsUsed" />.
            </summary>
      <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
      <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
      <param name="codeElementsUser">This sequence of code elements.</param>
      <param name="codeElementsUsed">The sequence of code elements that are used by <i>any</i> code elements in the returned sequence.</param>
      <remarks>
            Elements contained in both sequences are removed from the result, since such element is using itelf.<br />
            This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count + <paramref name="codeElementsUser" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <requires description="codeElementsUser" csharp="codeElementsUser != null" vb="codeElementsUser &lt;&gt; Nothing">codeElementsUser != null</requires>
      <requires description="codeElementsUsed must not be null" csharp="codeElementsUsed != null" vb="codeElementsUsed &lt;&gt; Nothing">codeElementsUsed != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUser" />, containing only code elements directly using <i>all</i> code elements in the sequence <paramref name="codeElementsUsed" /> .
            </summary>
      <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
      <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
      <param name="codeElementsUser">This sequence of code elements.</param>
      <param name="codeElementsUsed">The sequence of code elements that are all used by code elements in the returned sequence.</param>
      <remarks>
            This extension method has a <i>O(<paramref name="codeElementsUser" />.Count)</i> time complexity if <typeparamref name="TUser" /> is strictly finer-grained than <typeparamref name="TUsed" />, like for example <typeparamref name="TUsed" /> is <see cref="T:NDepend.CodeModel.INamespace" /> and <typeparamref name="TUser" /> is <see cref="T:NDepend.CodeModel.IType" />. <br />
            Otherwise it has a O(<paramref name="codeElementsUsed" />.Count) time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <requires description="codeElementsUser" csharp="codeElementsUser != null" vb="codeElementsUser &lt;&gt; Nothing">codeElementsUser != null</requires>
      <requires description="codeElementsUsed must not be null" csharp="codeElementsUsed != null" vb="codeElementsUsed &lt;&gt; Nothing">codeElementsUsed != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsing``2(System.Collections.Generic.IEnumerable{``0},``1)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUser" />, containing only code elements <i>directly or indirectly</i> using <paramref name="codeElementUsed" /> .
            </summary>
      <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
      <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
      <param name="codeElementsUser">This sequence of code elements.</param>
      <param name="codeElementUsed">The code element that is  <i>directly or indirectly</i> used by code elements in the returned sequence.</param>
      <remarks>
            This extension method has a <i>O(<paramref name="codeElementsUser" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedBy``2(System.Collections.Generic.IEnumerable{``0},``1)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <requires description="codeElementsUser" csharp="codeElementsUser != null" vb="codeElementsUser &lt;&gt; Nothing">codeElementsUser != null</requires>
      <requires description="codeElementUsed" csharp="(object)codeElementUsed != null" vb="((Object)codeElementUsed) &lt;&gt; Nothing">(object)codeElementUsed != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsUser" />, containing only code elements <i>directly or indirectly</i> used by <i>any</i> code element in the sequence <paramref name="codeElementsUsed" /> .
            </summary>
      <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
      <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
      <param name="codeElementsUser">This sequence of code elements.</param>
      <param name="codeElementsUsed">The sequence of code elements that are <i>directly or indirectly</i> used by <i>any</i> code elements in the returned sequence.</param>
      <remarks>
            Elements contained in both sequences are removed from the result, since such element is using itelf.<br />
            This extension method has a <i>O(<paramref name="codeElementsUsed" />.Count + <paramref name="codeElementsUser" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedBy``2(System.Collections.Generic.IEnumerable{``0},``1)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsedByAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.IndirectlyUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <requires description="codeElementsUser" csharp="codeElementsUser != null" vb="codeElementsUser &lt;&gt; Nothing">codeElementsUser != null</requires>
      <requires description="codeElementsUsed must not be null" csharp="codeElementsUsed != null" vb="codeElementsUsed &lt;&gt; Nothing">codeElementsUsed != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsing``2(System.Collections.Generic.IEnumerable{``0},``1)">
      <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="codeElementsUser" />, containing only code elements <i>directly or indirectly</i> using <paramref name="codeElementUsed" />. The metric value for each code element in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the depth of usage.
            </summary>
      <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
      <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
      <param name="codeElementsUser">This sequence of code elements.</param>
      <param name="codeElementUsed">The code element that is <i>directly or indirectly</i> used by code elements in the returned sequence.</param>
      <remarks>
            If <paramref name="codeElementUsed" /> or a child or parent of <paramref name="codeElementUsed" /> is in the returned sequence, its depth of usage is 0.<br />
            The depth of usage of a code element in <paramref name="codeElementsUser" />, directly using <paramref name="codeElementUsed" /> or a child or parent of <paramref name="codeElementUsed" />, is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="codeElementsUser" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IUser.IsUsing(NDepend.CodeModel.ICodeElement)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <requires description="codeElementsUser" csharp="codeElementsUser != null" vb="codeElementsUser &lt;&gt; Nothing">codeElementsUser != null</requires>
      <requires description="codeElementUsed" csharp="(object)codeElementUsed != null" vb="((Object)codeElementUsed) &lt;&gt; Nothing">(object)codeElementUsed != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="codeElementsUser" />, containing only code elements <i>directly or indirectly</i> using <i>any</i> code element in <paramref name="codeElementsUsed" />. The metric value for each code element in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the depth of usage.
            </summary>
      <typeparam name="TUsed">The used code elements type that is <see cref="T:NDepend.CodeModel.IUsed" /> or that implements <see cref="T:NDepend.CodeModel.IUsed" />.</typeparam>
      <typeparam name="TUser">The user code elements type that is <see cref="T:NDepend.CodeModel.IUser" /> or that implements <see cref="T:NDepend.CodeModel.IUser" />.</typeparam>
      <param name="codeElementsUser">This sequence of code elements.</param>
      <param name="codeElementsUsed">The sequence of code elements that are <i>directly or indirectly</i> used by code elements in the returned sequence.</param>
      <remarks>
            If a code element in <paramref name="codeElementsUsed" /> or a child or parent of a code element in <paramref name="codeElementsUsed" />, is in the returned sequence, its depth of usage is 0.<br />
            The depth of usage of a code element in <paramref name="codeElementsUser" />, directly using a code element in <paramref name="codeElementsUsed" /> or a child or parent of a code element in <paramref name="codeElementsUsed" />, is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="codeElementsUser" />.Count + <paramref name="codeElementsUsed" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IUser.IsUsing(NDepend.CodeModel.ICodeElement)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAny``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsingAll``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfIsUsing``2(System.Collections.Generic.IEnumerable{``0},``1)" />
      <requires description="codeElementsUser" csharp="codeElementsUser != null" vb="codeElementsUser &lt;&gt; Nothing">codeElementsUser != null</requires>
      <requires description="codeElementsUsed must not be null" csharp="codeElementsUsed != null" vb="codeElementsUsed &lt;&gt; Nothing">codeElementsUsed != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAttribute``1(System.Collections.Generic.IEnumerable{``0},NDepend.CodeModel.IType)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsTagged" />, containing only code elements tagged with <paramref name="typeAttribute" /> .
            </summary>
      <typeparam name="TTagged">The tagged code elements' type that is <see cref="T:NDepend.CodeModel.IAttributeTarget" /> or that implements <see cref="T:NDepend.CodeModel.IAttributeTarget" />, being one of <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IField" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IAssembly" /> type.</typeparam>
      <param name="codeElementsTagged">This sequence of code elements.</param>
      <param name="typeAttribute">The type attribute that tags code elements in the returned sequence.</param>
      <remarks>This extension method has a <i>O(<paramref name="codeElementsTagged" />.Count)</i> time complexity.</remarks>
      <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAnyAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAllAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
      <requires description="codeElementsTagged must not be null" csharp="codeElementsTagged != null" vb="codeElementsTagged &lt;&gt; Nothing">codeElementsTagged != null</requires>
      <requires description="typeAttribute must not be null" csharp="typeAttribute != null" vb="typeAttribute &lt;&gt; Nothing">typeAttribute != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAnyAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsTagged" />, containing only code elements tagged with <i>any</i> attribute type in <paramref name="typesAttribute" /> .
            </summary>
      <typeparam name="TTagged">The tagged code elements' type that is <see cref="T:NDepend.CodeModel.IAttributeTarget" /> or that implements <see cref="T:NDepend.CodeModel.IAttributeTarget" />, being one of <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IField" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IAssembly" /> type.</typeparam>
      <param name="codeElementsTagged">This sequence of code elements.</param>
      <param name="typesAttribute">A sequence of types attribute that tag code elements in the returned sequence.</param>
      <remarks>This extension method has a <i>O(<paramref name="codeElementsTagged" />.Count + <paramref name="typesAttribute" />.Count)</i> time complexity.</remarks>
      <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAttribute``1(System.Collections.Generic.IEnumerable{``0},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAllAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
      <requires description="codeElementsTagged must not be null" csharp="codeElementsTagged != null" vb="codeElementsTagged &lt;&gt; Nothing">codeElementsTagged != null</requires>
      <requires description="typesAttribute" csharp="typesAttribute != null" vb="typesAttribute &lt;&gt; Nothing">typesAttribute != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAllAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="codeElementsTagged" />, containing only code elements tagged with <i>all</i> attribute types in <paramref name="typesAttribute" /> .
            </summary>
      <typeparam name="TTagged">The tagged code elements' type that is <see cref="T:NDepend.CodeModel.IAttributeTarget" /> or that implements <see cref="T:NDepend.CodeModel.IAttributeTarget" />, being one of <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IField" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IAssembly" /> type.</typeparam>
      <param name="codeElementsTagged">This sequence of code elements.</param>
      <param name="typesAttribute">A sequence of types attribute that all tag code elements in the returned sequence.</param>
      <remarks>This extension method has a <i>O(<paramref name="codeElementsTagged" />.Count + <paramref name="typesAttribute" />.Count)</i> time complexity.</remarks>
      <seealso cref="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAttribute``1(System.Collections.Generic.IEnumerable{``0},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAnyAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
      <requires description="codeElementsTagged must not be null" csharp="codeElementsTagged != null" vb="codeElementsTagged &lt;&gt; Nothing">codeElementsTagged != null</requires>
      <requires description="typesAttribute" csharp="typesAttribute != null" vb="typesAttribute &lt;&gt; Nothing">typesAttribute != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="types" />, containing only types that derive from <paramref name="typeBase" /> .
            </summary>
      <param name="types">This sequence of types.</param>
      <param name="typeBase">The type base of types in the returned sequence.</param>
      <remarks>This extension method has a <i>O(<paramref name="types" />.Count)</i> time complexity.</remarks>
      <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
      <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
      <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
      <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <requires description="types must not be null" csharp="types != null" vb="types &lt;&gt; Nothing">types != null</requires>
      <requires description="typeBase must not be null" csharp="typeBase != null" vb="typeBase &lt;&gt; Nothing">typeBase != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="types" />, containing only types that derive from <i>any</i> type in <paramref name="typesBase" /> .
            </summary>
      <param name="types">This sequence of types.</param>
      <param name="typesBase">Types base of types in the returned sequence.</param>
      <remarks>This extension method has a <i>O(<paramref name="types" />.Count + <paramref name="typesBase" />.Count)</i> time complexity.</remarks>
      <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
      <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
      <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
      <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <requires description="types must not be null" csharp="types != null" vb="types &lt;&gt; Nothing">types != null</requires>
      <requires description="typesBase must not be null" csharp="typesBase != null" vb="typesBase &lt;&gt; Nothing">typesBase != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="types" />, containing only types that <i>directly</i> derive from <paramref name="typeBase" /> .
            </summary>
      <param name="types">This sequence of types.</param>
      <param name="typeBase">The <i>direct</i> type base of types in the returned sequence.</param>
      <remarks>This extension method has a <i>O(<paramref name="types" />.Count)</i> time complexity.</remarks>
      <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
      <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
      <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
      <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <requires description="types must not be null" csharp="types != null" vb="types &lt;&gt; Nothing">types != null</requires>
      <requires description="typeBase must not be null" csharp="typeBase != null" vb="typeBase &lt;&gt; Nothing">typeBase != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="types" />, containing only types that <i>directly</i> derive from <i>any</i> type in <paramref name="typesBase" /> .
            </summary>
      <param name="types">This sequence of types.</param>
      <param name="typesBase">
        <i>Direct</i> types base of types in the returned sequence.</param>
      <remarks>This extension method has a <i>O(<paramref name="types" />.Count + <paramref name="typesBase" />.Count)</i> time complexity.</remarks>
      <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
      <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
      <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
      <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <requires description="types must not be null" csharp="types != null" vb="types &lt;&gt; Nothing">types != null</requires>
      <requires description="typesBase must not be null" csharp="typesBase != null" vb="typesBase &lt;&gt; Nothing">typesBase != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)">
      <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="types" />, containing only types that derive from <paramref name="typeBase" />. The metric value for each type in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the depth of inheritance relative to <paramref name="typeBase" />.
            </summary>
      <param name="types">This sequence of types.</param>
      <param name="typeBase">The type base of types in the returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />.</param>
      <remarks>
            The depth of <paramref name="typeBase" /> is 0.<br />
            The depth of types that directly derive from <paramref name="typeBase" /> is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="types" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
      <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
      <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
      <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <requires description="types must not be null" csharp="types != null" vb="types &lt;&gt; Nothing">types != null</requires>
      <requires description="typeBase must not be null" csharp="typeBase != null" vb="typeBase &lt;&gt; Nothing">typeBase != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
      <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="types" />, containing only types that derive from <i>any</i> type in <paramref name="typesBase" />. The metric value for each type in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the smallest depth of inheritance relative to <i>any</i> type in <paramref name="typesBase" />.
            </summary>
      <param name="types">This sequence of types.</param>
      <param name="typesBase">Types base of types in the returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />.</param>
      <remarks>
            The depth of <i>any</i> type in <paramref name="typesBase" /> is 0.<br />
            The depth of types that directly derive from <i>any</i> type in <paramref name="typesBase" /> is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="types" />.Count + <paramref name="typesBase" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
      <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
      <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
      <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <requires description="types must not be null" csharp="types != null" vb="types &lt;&gt; Nothing">types != null</requires>
      <requires description="typesBase must not be null" csharp="typesBase != null" vb="typesBase &lt;&gt; Nothing">typesBase != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplement(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="types" />, containing only types that implement, or interfaces that extend, <paramref name="@interface" />.
            </summary>
      <param name="types">This sequence of types.</param>
      <param name="interface">The interface implemented by types in the returned sequence.</param>
      <remarks>
            If the <paramref name="@interface" /> type is not an interface, the sequence returned is empty.<br />
            This extension method has a <i>O(<paramref name="types" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.InterfacesImplemented" />
      <seealso cref="P:NDepend.CodeModel.IType.TypesThatImplementMe" />
      <seealso cref="P:NDepend.CodeModel.IType.NbInterfacesImplemented" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAll(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.Implement(NDepend.CodeModel.IType,System.String)" />
      <requires description="types must not be null" csharp="types != null" vb="types &lt;&gt; Nothing">types != null</requires>
      <requires description="interface must not be null" csharp="interface != null" vb="interface &lt;&gt; Nothing">interface != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="types" />, containing only types that implement, or interfaces that extend, <i>any</i> interface in <paramref name="interfaces" />.
            </summary>
      <param name="types">This sequence of types.</param>
      <param name="interfaces">The sequence of interfaces implemented by types in the returned sequence.</param>
      <remarks>
            Types in <paramref name="interfaces" /> that are not interface, are not taken account.<br />
            This extension method has a <i>O(<paramref name="types" />.Count + <paramref name="interfaces" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.InterfacesImplemented" />
      <seealso cref="P:NDepend.CodeModel.IType.TypesThatImplementMe" />
      <seealso cref="P:NDepend.CodeModel.IType.NbInterfacesImplemented" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplement(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAll(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.Implement(NDepend.CodeModel.IType,System.String)" />
      <requires description="types must not be null" csharp="types != null" vb="types &lt;&gt; Nothing">types != null</requires>
      <requires description="interfaces must not be null" csharp="interfaces != null" vb="interfaces &lt;&gt; Nothing">interfaces != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAll(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="types" />, containing only types that implement, or interfaces that extend, <i>all</i> interfaces in <paramref name="interfaces" />.
            </summary>
      <param name="types">This sequence of types.</param>
      <param name="interfaces">The sequence of interfaces all implemented by all types in the returned sequence.</param>
      <remarks>
            Types in <paramref name="interfaces" /> that are not interface, are not taken account.<br />
            This extension method has a <i>O(<paramref name="types" />.Count + <paramref name="interfaces" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.InterfacesImplemented" />
      <seealso cref="P:NDepend.CodeModel.IType.TypesThatImplementMe" />
      <seealso cref="P:NDepend.CodeModel.IType.NbInterfacesImplemented" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplement(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.Implement(NDepend.CodeModel.IType,System.String)" />
      <requires description="types must not be null" csharp="types != null" vb="types &lt;&gt; Nothing">types != null</requires>
      <requires description="interfaces must not be null" csharp="interfaces != null" vb="interfaces &lt;&gt; Nothing">interfaces != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="methods" />, containing only methods that assigns the field <paramref name="fieldAssigned" />.
            </summary>
      <param name="methods">This sequence of methods.</param>
      <param name="fieldAssigned">The field assigned by all methods in the returned sequence.</param>
      <remarks>
            This extension method has a <i>O(<paramref name="methods" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
      <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="methods must not be null" csharp="methods != null" vb="methods &lt;&gt; Nothing">methods != null</requires>
      <requires description="fieldAssigned must not be null" csharp="fieldAssigned != null" vb="fieldAssigned &lt;&gt; Nothing">fieldAssigned != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="methods" />, containing only methods that assigns <i>any</i> field in <paramref name="fieldsAssigned" />.
            </summary>
      <param name="methods">This sequence of methods.</param>
      <param name="fieldsAssigned">The sequence of fields assigned by methods in the returned sequence.</param>
      <remarks>
            This extension method has a <i>O(<paramref name="methods" />.Count + <paramref name="fieldsAssigned" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
      <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="methods must not be null" csharp="methods != null" vb="methods &lt;&gt; Nothing">methods != null</requires>
      <requires description="fieldsAssigned" csharp="fieldsAssigned != null" vb="fieldsAssigned &lt;&gt; Nothing">fieldsAssigned != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="methods" />, containing only methods that assigns <i>directly or indirectly any</i> field in <paramref name="fieldsAssigned" />.
            </summary>
      <param name="methods">This sequence of methods.</param>
      <param name="fieldsAssigned">The sequence of fields <i>directly or indirectly </i> assigned by methods in the returned sequence.</param>
      <remarks>
            This extension method has a <i>O(<paramref name="methods" />.Count + <paramref name="fieldsAssigned" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
      <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="methods must not be null" csharp="methods != null" vb="methods &lt;&gt; Nothing">methods != null</requires>
      <requires description="fieldsAssigned" csharp="fieldsAssigned != null" vb="fieldsAssigned &lt;&gt; Nothing">fieldsAssigned != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)">
      <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="methods" />, containing only methods that <i>directly or indirectly</i> assign <paramref name="fieldAssigned" />. The metric value for each method in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the depth of usage of the field.
            </summary>
      <param name="methods">This sequence of methods.</param>
      <param name="fieldAssigned">The field assigned by all methods in the returned sequence.</param>
      <remarks>
            The depth value for methods in returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />, that are directly assigning <paramref name="fieldAssigned" />, is 0.<br />
            The depth value for methods in returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />, that are directly calling a method that assigns <paramref name="fieldAssigned" />, is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="methods" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="methods must not be null" csharp="methods != null" vb="methods &lt;&gt; Nothing">methods != null</requires>
      <requires description="fieldAssigned must not be null" csharp="fieldAssigned != null" vb="fieldAssigned &lt;&gt; Nothing">fieldAssigned != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})">
      <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="methods" />, containing only methods that <i>directly or indirectly</i> assign <i>any</i> field in <paramref name="fieldsAssigned" />. The metric value for each method in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the smallest depth of usage of <i>any</i> field assigned.
            </summary>
      <param name="methods">This sequence of methods.</param>
      <param name="fieldsAssigned">The sequence of fields assigned by methods in the returned sequence.</param>
      <remarks>
            The depth value for methods in returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />, that are directly assigning <i>any</i> field in <paramref name="fieldsAssigned" />, is 0.<br />
            The depth value for methods in returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />, that are directly calling a method that assigns <i>any</i> field in <paramref name="fieldsAssigned" />, is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="methods" />.Count + <paramref name="fieldsAssigned" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="methods must not be null" csharp="methods != null" vb="methods &lt;&gt; Nothing">methods != null</requires>
      <requires description="fieldsAssigned" csharp="fieldsAssigned != null" vb="fieldsAssigned &lt;&gt; Nothing">fieldsAssigned != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="methods" />, containing only methods that calls a constructor of <paramref name="typeCreated" />.
            </summary>
      <param name="methods">This sequence of methods.</param>
      <param name="typeCreated">The type instantiated by all methods in the returned sequence.</param>
      <remarks>
            This extension method has a <i>O(<paramref name="methods" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="methods must not be null" csharp="methods != null" vb="methods &lt;&gt; Nothing">methods != null</requires>
      <requires description="typeCreated must not be null" csharp="typeCreated != null" vb="typeCreated &lt;&gt; Nothing">typeCreated != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="methods" />, containing only methods that calls a constructor of <i>any</i> type in <paramref name="typesCreated" />.
            </summary>
      <param name="methods">This sequence of methods.</param>
      <param name="typesCreated">The types instantiated by methods in the returned sequence.</param>
      <remarks>
            This extension method has a <i>O(<paramref name="methods" />.Count + <paramref name="typesCreated" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="methods must not be null" csharp="methods != null" vb="methods &lt;&gt; Nothing">methods != null</requires>
      <requires description="typesCreated must not be null" csharp="typesCreated != null" vb="typesCreated &lt;&gt; Nothing">typesCreated != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="methods" />, containing only methods that <i>directly or indirectly</i> calls a constructor of <i>any</i> type in <paramref name="typesCreated" />.
            </summary>
      <param name="methods">This sequence of methods.</param>
      <param name="typesCreated">The types instantiated <i>directly or indirectly</i> by methods in the returned sequence.</param>
      <remarks>
            Constructors of types in <paramref name="typesCreated" /> are not kept in the returned sequence.<br />
            This extension method has a <i>O(<paramref name="methods" />.Count + <paramref name="typesCreated" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="methods must not be null" csharp="methods != null" vb="methods &lt;&gt; Nothing">methods != null</requires>
      <requires description="typesCreated must not be null" csharp="typesCreated != null" vb="typesCreated &lt;&gt; Nothing">typesCreated != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)">
      <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="methods" />, containing only methods that <i>directly or indirectly</i> call a constructor of <paramref name="typeCreated" />. The metric value for each method in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the smallest depth of usage of a constructor.
            </summary>
      <param name="methods">This sequence of methods.</param>
      <param name="typeCreated">The type <i>directly or indirectly</i> instantiated by all methods in the returned sequence.</param>
      <remarks>
            The depth value for methods in returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />, that are constructors of <paramref name="typeCreated" />, is 0.<br />
            The depth value for methods in returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />, that are directly calling a constructor of <paramref name="typeCreated" />, is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="methods" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="methods must not be null" csharp="methods != null" vb="methods &lt;&gt; Nothing">methods != null</requires>
      <requires description="typeCreated must not be null" csharp="typeCreated != null" vb="typeCreated &lt;&gt; Nothing">typeCreated != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
      <summary>
            Returns a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> object whose <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is a sub-sequence of this sequence <paramref name="methods" />, containing only methods that <i>directly or indirectly</i> call a constructor of a type in <paramref name="typesCreated" />. The metric value for each method in <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" /> is equal to the smallest depth of usage of a constructor.
            </summary>
      <param name="methods">This sequence of methods.</param>
      <param name="typesCreated">The types <i>directly or indirectly</i> instantiated by methods in the returned sequence.</param>
      <remarks>
            The depth value for methods in returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />, that are constructors of <i>any</i> type in <paramref name="typesCreated" />, is 0.<br />
            The depth value for methods in returned code metric <see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />, that are directly calling a constructor of <i>any</i> type in <paramref name="typesCreated" />, is 1.<br />
            And so forth.<br />
            This extension method has a <i>O(<paramref name="methods" />.Count + <paramref name="typesCreated" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="methods must not be null" csharp="methods != null" vb="methods &lt;&gt; Nothing">methods != null</requires>
      <requires description="typesCreated must not be null" csharp="typesCreated != null" vb="typesCreated &lt;&gt; Nothing">typesCreated != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithReturnType(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="methods" />, containing only methods that have <paramref name="returnType" /> for return type.
            </summary>
      <param name="methods">This sequence of methods.</param>
      <param name="returnType">The return type of all methods in the returned sequence.</param>
      <remarks>
            This extension method has a <i>O(<paramref name="methods" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.ReturnType" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithReturnTypeIn(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.ReturnTypeIs(NDepend.CodeModel.IMethod,System.String)" />
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithReturnTypeIn(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="methods" />, containing only methods that have <i>any</i> type in <paramref name="returnTypes" /> for return type.
            </summary>
      <param name="methods">This sequence of methods.</param>
      <param name="returnTypes">The sequence of return types of methods in the returned sequence.</param>
      <remarks>
            This extension method has a <i>O(<paramref name="methods" />.Count + <paramref name="returnTypes" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.ReturnType" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithReturnType(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.ReturnTypeIs(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="methods must not be null" csharp="methods != null" vb="methods &lt;&gt; Nothing">methods != null</requires>
      <requires description="returnTypes must not be null" csharp="returnTypes != null" vb="returnTypes &lt;&gt; Nothing">returnTypes != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithFieldType(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField},NDepend.CodeModel.IType)">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="fields" />, containing only fields that have <paramref name="fieldType" /> for field type.
            </summary>
      <param name="fields">This sequence of fields.</param>
      <param name="fieldType">The field type of all fields in the returned sequence.</param>
      <remarks>
            This extension method has a <i>O(<paramref name="fields" />.Count)</i> time complexity.
            </remarks>
      <see cref="P:NDepend.CodeModel.IField.FieldType" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithFieldTypeIn(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.FieldTypeIs(NDepend.CodeModel.IField,System.String)" />
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithFieldTypeIn(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})">
      <summary>
            Returns a sub-sequence of this sequence <paramref name="fields" />, containing only fields that have <i>any</i> type in <paramref name="fieldTypes" /> for field type.
            </summary>
      <param name="fields">This sequence of fields.</param>
      <param name="fieldTypes">The sequence of field types of fields in the returned sequence.</param>
      <remarks>
            This extension method has a <i>O(<paramref name="fields" />.Count + <paramref name="fieldTypes" />.Count)</i> time complexity.
            </remarks>
      <see cref="P:NDepend.CodeModel.IField.FieldType" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithFieldType(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.FieldTypeIs(NDepend.CodeModel.IField,System.String)" />
      <requires description="fields must not be null" csharp="fields != null" vb="fields &lt;&gt; Nothing">fields != null</requires>
      <requires description="fieldTypes must not be null" csharp="fieldTypes != null" vb="fieldTypes &lt;&gt; Nothing">fieldTypes != null</requires>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:NDepend.CodeModel.ExtensionMethodsTooling">
      <summary>
            Provides a set of extension methods to open source code elements declarations with a text editor tool (like Visual Studio), or even compare source declarations with a diff tool.
            </summary>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsTooling.TryOpenSource(NDepend.CodeModel.ICodeElement)">
      <summary>
            Opens the source file containing the declaration of this <see cref="T:NDepend.CodeModel.ICodeElement" />, and points to the declaration line.
            </summary>
      <remarks>
            Code elements such as <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.INamespace" /> or <see cref="T:NDepend.CodeModel.IAssembly" /> objects, often have multiple source declarations in the sequence <see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" />.<br />
            In such a case, a dialog is shown to the user asking which declaration should be opened.<br />
            The source file declaration is opened in the editor tool defined through: <i>NDepend &gt; Options panel &gt; Source File Editor Tool</i></remarks>
      <returns>
        <i>true</i> if the source declaration was opened successfully.
            </returns>
      <param name="codeElement">The code element.</param>
      <requires description="codeElement must not be null" csharp="codeElement != null" vb="codeElement &lt;&gt; Nothing">codeElement != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsTooling.TryOpenSource(NDepend.CodeModel.ICodeElement,System.String@)">
      <summary>
            Opens the source file containing the declaration of this <see cref="T:NDepend.CodeModel.ICodeElement" />, and points to the declaration line.
            </summary>
      <remarks>
            Code elements such as <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.INamespace" /> or <see cref="T:NDepend.CodeModel.IAssembly" /> objects, often have multiple source declarations in the sequence <see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" />.<br />
            In such a case, a dialog is shown to the user asking which declaration should be opened.<br />
            The source file declaration is opened in the editor tool defined through: <i>NDepend &gt; Options panel &gt; Source File Editor Tool</i></remarks>
      <returns>
        <i>true</i> if the source declaration was opened successfully.
            </returns>
      <param name="codeElement">The code element.</param>
      <param name="failureReason">If <i>false</i> is returned, contains the plain-english description of the failure.</param>
      <requires description="codeElement must not be null" csharp="codeElement != null" vb="codeElement &lt;&gt; Nothing">codeElement != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceFileLine,NDepend.CodeModel.ISourceFileLine)">
      <summary>
            Opens with a textual files compare/diff tool, two source files declarations, this <paramref name="sourceFileLine" /> and <paramref name="sourceFileLineOther" />.
            </summary>
      <remarks>
        <paramref name="sourceFileLine" /> and <paramref name="sourceFileLineOther" /> can be obtained through <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" />.<br />
            The textual files compare/diff tool is defined through: <i>NDepend &gt; Options panel &gt; Build Comparison &gt; Sources Files Compare Tool</i></remarks>
      <returns>
        <i>true</i> if the two source declarations were compared successfully.
            </returns>
      <param name="sourceFileLine">The first line position in a source file.</param>
      <param name="sourceFileLineOther">The second line position in a source file.</param>
      <seealso cref="T:NDepend.CodeModel.ICompareContext" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />
      <seealso cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare" />
      <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)" />
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.ICollection{System.String},NDepend.CodeModel.ICompareContext)" />
      <requires description="sourceFileLine must not be null" csharp="sourceFileLine != null" vb="sourceFileLine &lt;&gt; Nothing">sourceFileLine != null</requires>
      <requires description="sourceFileLineOther must not be null" csharp="sourceFileLineOther != null" vb="sourceFileLineOther &lt;&gt; Nothing">sourceFileLineOther != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceFileLine,NDepend.CodeModel.ISourceFileLine,System.String@)">
      <summary>
            Opens with a textual files compare/diff tool, two source files declarations, this <paramref name="sourceFileLine" /> and <paramref name="sourceFileLineOther" />.
            </summary>
      <remarks>
        <paramref name="sourceFileLine" /> and <paramref name="sourceFileLineOther" /> can be obtained through <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" />.<br />
            The textual files compare/diff tool is defined through: <i>NDepend &gt; Options panel &gt; Build Comparison &gt; Sources Files Compare Tool</i></remarks>
      <returns>
        <i>true</i> if the two source declarations were compared successfully.
            </returns>
      <param name="sourceFileLine">The first line position in a source file.</param>
      <param name="sourceFileLineOther">The second line position in a source file.</param>
      <param name="failureReason">If <i>false</i> is returned, contains the plain-english description of the failure.</param>
      <seealso cref="T:NDepend.CodeModel.ICompareContext" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />
      <seealso cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare" />
      <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)" />
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.ICollection{System.String},NDepend.CodeModel.ICompareContext)" />
      <requires description="sourceFileLine must not be null" csharp="sourceFileLine != null" vb="sourceFileLine &lt;&gt; Nothing">sourceFileLine != null</requires>
      <requires description="sourceFileLineOther must not be null" csharp="sourceFileLineOther != null" vb="sourceFileLineOther &lt;&gt; Nothing">sourceFileLineOther != null</requires>
    </member>
    <member name="T:NDepend.CodeModel.IAssembly">
      <summary>
            Represents an application assembly, or a third-party assembly used by one or several application assemblies.
            </summary>
    </member>
    <member name="T:NDepend.CodeModel.ICodeElementParent">
      <summary>
            Represents a parent code element. This interface is implemented by <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.INamespace" /> and <see cref="T:NDepend.CodeModel.IAssembly" />.
            </summary>
      <remarks>
            This empty interface is used to propose extension methods common to <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.INamespace" /> and <see cref="T:NDepend.CodeModel.IAssembly" />.
            </remarks>
    </member>
    <member name="T:NDepend.CodeModel.ICodeContainer">
      <summary>
            Represents a code element that contains executable code. This interface is implemented by <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IAssembly" /> and <see cref="T:NDepend.CodeModel.ICodeBase" />.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.ICodeContainer.NbILInstructions">
      <summary>
            Gets a numeric nullable value counting the number of IL instructions for this code element.
            </summary>
      <remarks>
            The number of IL instructions can vary depending if an application assembly is compiled in <i>debug</i> or in <i>release</i> mode.<br /> 
            Indeed compiler's optimizations can modify the number of IL instructions.<br /> 
            For example a compiler can add some <i>nop</i> IL instructions in <i>debug</i> mode, to handle <i>Edit and Continue</i>, or to allow attaching an IL instruction to a curly brace.
            </remarks>
      <returns>
        <i>null</i> if this code element is defined in a third-party assembly.<br /><i>null</i> if this code element is an interface, an enumeration or an abstract method.<br />
            Otherwise returns the number of IL instructions for this code element.
            </returns>
    </member>
    <member name="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode">
      <summary>
            Gets a numeric nullable value counting the number of <i>logical</i> lines of code for this code element.
            </summary>
      <remarks>
            This metric (known as <i>LoC</i>) can be computed only if PDB files are present.<br /> 
            NDepend computes this metric directly from the information provided in PDB files.<br /> 
            The <i>LoC</i> for a method is equals to the number of sequence points found for this method in the PDB file.<br />
            A sequence point is used to mark a spot in the IL code that corresponds to a specific location in the original source.<br />
            More info about sequence points can be found <a href="http://blogs.msdn.com/b/rmbyers/archive/2005/09/08/462676.aspx" target="_blank">here</a><br />
            Notice that sequence points which correspond to C# braces‘{‘ and ‘}’ are not taken account.<br />
            Computing the number of lines of code from PDB’s sequence points allows to obtain a logical <i>LoC</i> of code instead of a physical <i>LoC</i> (i.e directly computed from source files).<br />
            Two significant advantages of logical  <i>LoC</i> over physical <i>LoC</i> are:
            <ul><li>Coding style doesn’t interfere with logical <i>LoC</i>. For example the <i>LoC</i> won’t change because a method call is spawn on several lines because of a high number of arguments.</li><li>Logical <i>LoC</i> is independent from the programming language. Values obtained from assemblies written with different languages are comparable and can be summed.</li></ul>
            Notice that the <i>LoC</i> for a type is the sum of its methods’ <i>LoC</i>, the <i>LoC</i> for a namespace is the sum of its types’ <i>LoC</i>, the <i>LoC</i> for an assembly is the sum of its namespaces’ <i>LoC</i> and the <i>LoC</i> for a code base is the sum of its application assemblies <i>LoC</i>.<br />
            Here are some observations:
            <ul><li>Interfaces, abstract methods and enumerations have a <i>NbLinesOfCode</i> value equals to <i>null</i>. Only concrete code that is effectively executed is considered when computing <i>LoC</i>.</li><li>Namespaces, types, fields and methods declarations are not considered as line of code because they don’t have corresponding sequence points.</li><li>When the C# or VB.NET compiler faces an inline instance fields initialization, it generates a sequence point for each of the instance constructor (the same remark applies for inline static fields initialization and static constructor).</li><li><i>LoC</i> computed from an anonymous method doesn’t interfere with the <i>LoC</i> of its outer declaring methods.</li><li>The overall ratio between <see cref="P:NDepend.CodeModel.ICodeContainer.NbILInstructions" /> and <i>LoC</i> (in C# and VB.NET) is usually around 7.</li></ul><i><u>Recommendations:</u></i><br /> 
            Methods where <i>NbLinesOfCode</i> is higher than 20 are hard to understand and maintain.<br /> 
            Methods where <i>NbLinesOfCode</i> is higher than 40 are extremely complex and should be split in smaller methods (except if they are automatically generated by a tool).
            </remarks>
      <returns>
        <i>null</i> if this code element is defined in a third-party assembly.<br /><i>null</i> if the PDB file of this assembly or code element parent's assembly, hasen't been found.<br /><i>null</i> if this code element is an interface, an enumeration, an abstract method or a default constructor.<br />
            Otherwise returns the number of <i>logical</i> lines of code for this code element.
            </returns>
    </member>
    <member name="P:NDepend.CodeModel.ICodeContainer.NbLinesOfComment">
      <summary>
            Gets a numeric nullable value counting the number of lines of comments contained in the body of this code element.
            </summary>
      <remarks>
            This metric can be computed only if assemblies PDB files are found at analysis-time and if corresponding source files can be found.<br /> 
            So far this metric is only computed for C# code and a VB.NET version will be released in the future.<br />
            The number of lines of comment is computed as follow:<br /><ul><li>For a method, this metric value is the number of lines of comment that can be found in its body. In C# the body of a method begins with a '{' and ends with a '}'. If a method contains an anonymous method, lines of comment defined in the anonymous method are not counted for the outer method but are counted for the anonymous method.</li><li>For a type, this metric value is the sum of the number of lines of comment that can be found in each of its partial definition. In C#, each partial definition of a type begins with a '{ and ends with a '}'.</li><li>For a namespace, this metric value is the sum of the number of lines of comment that can be found in each of its partial definition. In C# each partial definition of a namespace begins with a '{ and ends with a '}'.</li><li>For an assembly, this metric value is the sum of the number of lines of comment that can be found in each of its source file.</li></ul>
            Notice that this metric is not an additive metric (i.e for example, the number of lines of comment of a namespace can be greater than the number of lines of comment over all its types).<br /><i><u>Recommendations:</u></i><br />  
            This metric is not helpful to assess the quality of source code from a commenting perspective. Prefer using the metric <see cref="P:NDepend.CodeModel.ICodeContainer.PercentageComment" />. 
            </remarks>
      <returns>
        <i>null</i> if this code element is defined in a third-party assembly.<br /><i>null</i> if the PDB file of this assembly or code element parent's assembly, hasen't been found.<br /><i>null</i> if the source code file path referenced from the PDB file cannot be found.<br /><i>null</i> if the source code of this code element is written with a programming language different than C#.<br />
            Otherwise returns the number of comments for this code element.
            </returns>
    </member>
    <member name="P:NDepend.CodeModel.ICodeContainer.PercentageComment">
      <summary>
            Gets a numeric nullable value in the range [0,100] assessing the percentage of comments for this code element.
            </summary>
      <remarks>
            This metric value is computed with the following formula: <see cref="P:NDepend.CodeModel.ICodeContainer.PercentageComment" /> = 100*<see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfComment" />  / ( <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfComment" />  + <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" />).<br /><br /><i><u>Recommendations:</u></i><br />
            Code where the percentage of comment is lower than 20% might need to be more commented. However overly commented code (&gt;40%) is not necessarily a blessing as it can be considered as an insult to the intelligence of the reader.<br />
            Guidelines about code commenting can be found <a href="http://www.icsharpcode.net/TechNotes/Commenting20020413.pdf" target="_blank">here</a>. 
            </remarks>
      <returns>
        <i>null</i> if this code element is defined in a third-party assembly.<br /><i>null</i> if the PDB file of this assembly or code element parent's assembly, hasen't been found.<br /><i>null</i> if the source code file path referenced from the PDB file cannot be found.<br /><i>null</i> if the source code of this code element is written with a programming language different than C#.<br />
            Otherwise returns the comments percentage for this code element.
            </returns>
    </member>
    <member name="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage">
      <summary>
            Gets a numeric nullable value in the range [0,100] assessing the percentage of number of lines of code of this code element, covered by tests.
            </summary>
      <remarks>
        <i>
          <u>Recommendations:</u>
        </i>
        <br /> 
            The closer to 100%, the better!
            </remarks>
      <returns>
        <i>null</i> if no code coverage data are imported through the NDepend project settings <see cref="T:NDepend.Project.IProjectCoverage" />.<br /><i>null</i> if this code element is defined in a third-party assembly.<br /><i>null</i> if the PDB file of this assembly or code element parent's assembly, hasen't been found.<br />
            Otherwise returns the code coverage by tests percentage for this code element.
            </returns>
      <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCodeCoverageData" />
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" />
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />
      <seealso cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" />
      <seealso cref="P:NDepend.CodeModel.ICodeBase.CoverageDataAvailable" />
      <seealso cref="T:NDepend.Project.IProjectCoverage" />
    </member>
    <member name="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered">
      <summary>
            Gets a numeric nullable value in the range [0,this.<see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" />] counting the number of lines of code of this code element, covered by tests.
            </summary>
      <returns>
        <i>null</i> if no code coverage data are imported through the NDepend project settings <see cref="T:NDepend.Project.IProjectCoverage" />.<br /><i>null</i> if this code element is defined in a third-party assembly.<br /><i>null</i> if the PDB file of this assembly or code element parent's assembly, hasen't been found.<br />
            Otherwise returns the number of lines of code covered by tests for this code element.
            </returns>
      <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCodeCoverageData" />
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />
      <seealso cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" />
      <seealso cref="P:NDepend.CodeModel.ICodeBase.CoverageDataAvailable" />
      <seealso cref="T:NDepend.Project.IProjectCoverage" />
    </member>
    <member name="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered">
      <summary>
            Gets a numeric nullable value in the range [0,this.<see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" />] counting the number of lines of code of this code element, <b>not</b> covered by tests.
            </summary>
      <returns>
        <i>null</i> if no code coverage data are imported through the NDepend project settings <see cref="T:NDepend.Project.IProjectCoverage" />.<br /><i>null</i> if this code element is defined in a third-party assembly.<br /><i>null</i> if the PDB file of this assembly or code element parent's assembly, hasen't been found.<br />
            Otherwise returns the number of lines of code <b>not</b> covered by tests for this code element.
            </returns>
      <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCodeCoverageData" />
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" />
      <seealso cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" />
      <seealso cref="P:NDepend.CodeModel.ICodeBase.CoverageDataAvailable" />
      <seealso cref="T:NDepend.Project.IProjectCoverage" />
    </member>
    <member name="T:NDepend.CodeModel.IUsed">
      <summary>
            Represents a code element that can be used from another code element. This interface is implemented by <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IField" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.INamespace" /> and <see cref="T:NDepend.CodeModel.IAssembly" />.
            </summary>
      <seealso cref="T:NDepend.CodeModel.IUser" />
    </member>
    <member name="M:NDepend.CodeModel.IUsed.IsUsedBy(NDepend.CodeModel.ICodeElement)">
      <summary>
            Returns true if this code element is used by <paramref name="codeElementUser" />, otherwise returns false.
            </summary>
      <param name="codeElementUser">The code element that potentially uses this code element.</param>
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.UsedBy``2(System.Collections.Generic.IEnumerable{``0},``1)" />
      <requires description="the codeElementUser object must not be null" csharp="codeElementUser != null" vb="codeElementUser &lt;&gt; Nothing">codeElementUser != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.IUsed.IsUsedByAssembly(NDepend.CodeModel.IAssembly)">
      <summary>
            Returns true if this code element is used by <paramref name="assemblyUser" />, otherwise returns false.
            </summary>
      <param name="assemblyUser">The assembly that potentially uses this code element.</param>
      <requires description="the assemblyUser object must not be null" csharp="assemblyUser != null" vb="assemblyUser &lt;&gt; Nothing">assemblyUser != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.IUsed.IsUsedByNamespace(NDepend.CodeModel.INamespace)">
      <summary>
            Returns true if this code element is used by <paramref name="namespaceUser" />, otherwise returns false.
            </summary>
      <param name="namespaceUser">The namespace that potentially uses this code element.</param>
      <requires description="the namespaceUser object must not be null" csharp="namespaceUser != null" vb="namespaceUser &lt;&gt; Nothing">namespaceUser != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.IUsed.IsUsedByType(NDepend.CodeModel.IType)">
      <summary>
            Returns true if this code element is used by <paramref name="typeUser" />, otherwise returns false.
            </summary>
      <param name="typeUser">The type that potentially uses this code element.</param>
      <requires description="the typeUser object must not be null" csharp="typeUser != null" vb="typeUser &lt;&gt; Nothing">typeUser != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.IUsed.IsUsedByMethod(NDepend.CodeModel.IMethod)">
      <summary>
            Returns true if this code element is used by <paramref name="methodUser" />, otherwise returns false.
            </summary>
      <param name="methodUser">The method that potentially uses this code element.</param>
      <requires description="the methodUser object must not be null" csharp="methodUser != null" vb="methodUser &lt;&gt; Nothing">methodUser != null</requires>
    </member>
    <member name="T:NDepend.CodeModel.IUser">
      <summary>
            Represents a code element that can use another code element. This interface is implemented by <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.INamespace" /> and <see cref="T:NDepend.CodeModel.IAssembly" />.
            </summary>
      <seealso cref="T:NDepend.CodeModel.IUsed" />
    </member>
    <member name="M:NDepend.CodeModel.IUser.IsUsing(NDepend.CodeModel.ICodeElement)">
      <summary>
            Returns true if this code element is used by <paramref name="codeElementUsed" />, otherwise returns false.
            </summary>
      <param name="codeElementUsed">The code element that is potentially used by this code element.</param>
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.Using``2(System.Collections.Generic.IEnumerable{``0},``1)" />
      <requires description="the codeElementUsed object must not be null" csharp="codeElementUsed != null" vb="codeElementUsed &lt;&gt; Nothing">codeElementUsed != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.IUser.IsUsingAssembly(NDepend.CodeModel.IAssembly)">
      <summary>
            Returns true if this code element is used by <paramref name="assemblyUsed" />, otherwise returns false.
            </summary>
      <param name="assemblyUsed">The assembly that is potentially used by this code element.</param>
      <requires description="the assemblyUsed object must not be null" csharp="assemblyUsed != null" vb="assemblyUsed &lt;&gt; Nothing">assemblyUsed != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.IUser.IsUsingNamespace(NDepend.CodeModel.INamespace)">
      <summary>
            Returns true if this code element is used by <paramref name="namespaceUsed" />, otherwise returns false.
            </summary>
      <param name="namespaceUsed">The namespace that is potentially used by this code element.</param>
      <requires description="the namespaceUsed object must not be null" csharp="namespaceUsed != null" vb="namespaceUsed &lt;&gt; Nothing">namespaceUsed != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.IUser.IsUsingType(NDepend.CodeModel.IType)">
      <summary>
            Returns true if this code element is used by <paramref name="typeUsed" />, otherwise returns false.
            </summary>
      <param name="typeUsed">The type that is potentially used by this code element.</param>
      <requires description="the typeUsed object must not be null" csharp="typeUsed != null" vb="typeUsed &lt;&gt; Nothing">typeUsed != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.IUser.IsUsingMethod(NDepend.CodeModel.IMethod)">
      <summary>
            Returns true if this code element is used by <paramref name="methodUsed" />, otherwise returns false.
            </summary>
      <param name="methodUsed">The method that is potentially used by this code element.</param>
      <requires description="the methodUsed object must not be null" csharp="methodUsed != null" vb="methodUsed &lt;&gt; Nothing">methodUsed != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.IUser.IsUsingField(NDepend.CodeModel.IField)">
      <summary>
            Returns true if this code element is used by <paramref name="fieldUsed" />, otherwise returns false.
            </summary>
      <param name="fieldUsed">The field that is potentially used by this code element.</param>
      <requires description="the fieldUsed object must not be null" csharp="fieldUsed != null" vb="fieldUsed &lt;&gt; Nothing">fieldUsed != null</requires>
    </member>
    <member name="P:NDepend.CodeModel.IUser.IsExcludedFromCoverage">
      <summary>Gets a value indicating whether this assembly, namespace, type or method don’t have associated coverage data.</summary>
      <remarks>
            A <i>true</i> value for <see cref="P:NDepend.CodeModel.IUser.IsExcludedFromCoverage" /> doesn’t necessarily mean that the code element is not covered by tests but it means that no coverage data have been gathered because:<br /><ul><li>No coverage data is available for the code element or,</li><li>The coverage file is not in-sync with the code or,</li><li>The code element is tagged by <see cref="T:NDepend.Attributes.UncoverableByTestAttribute" /> or,</li><li>The code element only contains methods that match <see cref="P:NDepend.CodeModel.IUser.IsExcludedFromCoverage" />.</li></ul></remarks>
    </member>
    <member name="P:NDepend.CodeModel.IUser.Level">
      <summary>Gets a numeric nullable value indicating whether this assembly, namespace, type or method depends on a dependency cycle.</summary>
      <remarks>
        <i>
          <u>Level code metric description:</u>
        </i>
        <br />
            The Level value for a namespace is defined as follow:<br /><ul><li>Level = 0 : if the namespace doesn’t use any other namespace.</li><li>Level = 1 : if the namespace only uses directly namespace defined in third-party assemblies.</li><li>Level = 1 + (Max <i>Level</i> over namespace it uses direcly).</li><li>Level = null : if the namespace is involved in a dependency cycle or uses directly or indirectly a namespace involved in a dependency cycle.</li></ul>
            Level metric definitions for assemblies, types and methods are inferred from the above definition. This metric has been first defined by <i>John Lakos</i> in his book <a href="http://www.amazon.com/Large-Scale-Software-Design-John-Lakos/dp/0201633620" target="_blank">Large-Scale C++ Software Design</a>.
            <br /><br /><i><u>Recommendations:</u></i>
            This metric helps objectively classify the assemblies, namespaces, types and methods as high level mid level or low level.<br /> 
            There is no particular recommendation for high or small values. This metric is also useful to discover dependency cycles in your application.<br /><br /></remarks>
    </member>
    <member name="T:NDepend.CodeModel.IAttributeTarget">
      <summary>
            Represents a code element that can be tagged by an attribute. This interface is implemented by <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IField" />, <see cref="T:NDepend.CodeModel.IType" /> and <see cref="T:NDepend.CodeModel.IAssembly" />.
            </summary>
    </member>
    <member name="M:NDepend.CodeModel.IAttributeTarget.HasAttribute(NDepend.CodeModel.IType)">
      <summary>
            Returns true if this code element is tagged by <paramref name="attributeClass" />.
            </summary>
      <param name="attributeClass">The attribute class that potentially tags this code element.</param>
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAttribute``1(System.Collections.Generic.IEnumerable{``0},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAnyAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.TaggedWithAllAttributes``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />
      <requires description="the attributeClass object must not be null" csharp="attributeClass != null" vb="attributeClass &lt;&gt; Nothing">attributeClass != null</requires>
    </member>
    <member name="T:NDepend.CodeModel.ICodeNode`1">
      <summary>
            Represents a code element or a code base. This interface is implemented by <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IField" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IAssembly" /> and <see cref="T:NDepend.CodeModel.ICodeBase" />.
            </summary>
      <remarks>
            This interface is generic because of the extension properties <see cref="T:NDepend.CodeModel.ICompareContext" />.<see cref="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(NDepend.CodeModel.ICodeNode{``0})" /> and <see cref="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(NDepend.CodeModel.ICodeNode{``0})" />, that returns an object typed with this object's type.
            </remarks>
      <typeparam name="T">
            This generic parameter type is equals to this code element type, like <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.ICodeBase" /> for example.
            </typeparam>
    </member>
    <member name="P:NDepend.CodeModel.ICodeNode`1.UniqueID">
      <summary>
            Gets an integer identifier for this code element, unique in the scope of this <see cref="P:NDepend.CodeModel.ICodeElement.ParentCodeBase" />.
            </summary>
      <remarks>
            This code element's unique identifier might be useful in situations where a unique hash code per code element, unique in the scope of this <see cref="P:NDepend.CodeModel.ICodeElement.ParentCodeBase" />, is needed.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.FilePath">
      <summary>
            Gets this assembly main module file path, found during analysis.
            </summary>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned path object is not empty" csharp="!result.IsEmpty" vb="Not result.IsEmpty">!result.IsEmpty</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.VisualStudioProjectFilePath">
      <summary>
            Gets this assembly corresponding Visual Studio project file path, if found at analysis-time, otherwise gets <i>null</i>.
            </summary>
      <remarks>
            NDepend uses an heuristic to try to infer the Visual Studio project file corresponding to this assembly.<br />
            This facility is only supported for C# project so far.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.ChildNamespaces">
      <summary>
            Gets a sequence of namespaces declared in this application assembly. For a third-party assembly, gets only namespaces used by the application.
            </summary>
      <remarks>
            Notice that if <i>N</i> assemblies declare the same namespace, there are <i>N</i><see cref="T:NDepend.CodeModel.INamespace" /> objects with a common <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> value, one object for each assembly that declares the namespace.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IAssembly.ChildNamespaces" />.Count)</i> time complexity.
            </remarks>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.ChildTypes">
      <summary>
            Gets a sequence of types declared in this application assembly. For a third-party assembly, gets only types used by the application.
            </summary>
      <remarks>
            The result includes classes, structures, interfaces, enumerations and delegates classes.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IAssembly.ChildTypes" />.Count)</i> time complexity.
            </remarks>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.ChildMethods">
      <summary>
            Gets a sequence of methods declared in this application assembly. For a third-party assembly, gets only methods used by the application.
            </summary>
      <remarks>
            The result includes methods, constructors, class constructors, property getter and setters, event adders and removers.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IAssembly.ChildMethods" />.Count)</i> time complexity.
            </remarks>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.ChildFields">
      <summary>
            Gets a sequence of fields declared in this application assembly. For a third-party assembly, gets only fields used by the application.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IAssembly.ChildFields" />.Count)</i> time complexity.
            </remarks>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.ContainsNamespaceDependencyCycle">
      <summary>
            Gets a value indicating whether this application assembly contains a dependency cycle between its <see cref="P:NDepend.CodeModel.IAssembly.ChildNamespaces" />. Gets <i>null</i> if this assembly is a third-party assembly.
            </summary>
      <remarks>
            The result of this property getter is lazy computed.<br /> 
            The first time it is called it has a <i>O(this.<see cref="P:NDepend.CodeModel.IAssembly.ChildNamespaces" />.Count ^2)</i> time complexity.<br />
            Further calls result in a constant time complexity.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.AssembliesUsed">
      <summary>
            Gets a sequence of assemblies that this assembly is using. If this assembly is a third-party assembly, gets an empty sequence.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IAssembly.AssembliesUsed" />.Count)</i> time complexity.
            </remarks>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.AssembliesUsingMe">
      <summary>
            Gets a sequence of assemblies that are using this assembly.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IAssembly.AssembliesUsingMe" />.Count)</i> time complexity.
            </remarks>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.NbMethods">
      <summary>
            Gets the number of methods declared in types of this assembly. Gets null if this assembly is a third-party assembly.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.NbFields">
      <summary>
            Gets the number of fields declared in types of this assembly. Gets null if this assembly is a third-party assembly.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.NbTypes">
      <summary>
            Gets the number of types declared in this assembly. Gets null if this assembly is a third-party assembly.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.NbNamespaces">
      <summary>
            Gets the number of namespaces declared in this assembly. Gets null if this assembly is a third-party assembly.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.Abstractness">
      <summary>
            Gets a float numeric nullable value in the range [0,1] assessing the ratio of the number of internal abstract types (i.e abstract classes and interfaces) to the number of internal types.
            </summary>
      <remarks>
        <i>Abstractness</i>=0 indicates a completely concrete assembly and <i>Abstractness</i>=1 indicates a completely abstract assembly.<br />
            More information concerning the usefulness of this code metric is available in the descripion of the <see cref="P:NDepend.CodeModel.IAssembly.NormDistFromMainSeq" /> code metric.<br /><br /><i><u>Availability:</u></i><br />
            A null numeric value is returned for any third-party assembly.
            </remarks>
      <returns>
        <i>null</i> if this assembly is a third-party assembly.<br />
            Otherwise returns this assembly <see cref="P:NDepend.CodeModel.IAssembly.Abstractness" /> numeric value.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.Instability">
      <summary>
            Gets a float numeric nullable value in the range [0,1] assessing an value of the assembly's resilience to change..
            </summary>
      <remarks>
            The <i>Instability</i> value for an assembly is equal to the ratio of the incoming coupling (<see cref="P:NDepend.CodeModel.IAssembly.NbTypesUsingMe" />) to the total coupling (<see cref="P:NDepend.CodeModel.IAssembly.NbTypesUsingMe" /> + <see cref="P:NDepend.CodeModel.IAssembly.NbTypesUsed" />).<br />
            This metric is an indicator of the assembly's resilience to change.<br />
            The range for this metric is 0 to 1, with <i>Instability</i>=0 indicating a completely stable package and <i>Instability</i>=1 indicating a completely instable package.<br />
            More information concerning the usefulness of this code metric is available in the descripion of the <see cref="P:NDepend.CodeModel.IAssembly.NormDistFromMainSeq" /> code metric.<br /></remarks>
      <returns>
        <i>null</i> if this assembly is a third-party assembly.<br />
            Otherwise returns this assembly <see cref="P:NDepend.CodeModel.IAssembly.Instability" /> numeric value.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.DistFromMainSeq">
      <summary>
            Gets a float numeric nullable value equals to <see cref="P:NDepend.CodeModel.IAssembly.NormDistFromMainSeq" /> / Sqrt(2), assessing the balance between <see cref="P:NDepend.CodeModel.IAssembly.Abstractness" /> and <see cref="P:NDepend.CodeModel.IAssembly.Instability" /> for this assembly. A returned value close to 0 indicates an ideal balance.
            </summary>
      <remarks>
            More information concerning the usefulness of this code metric is available in the descripion of the <see cref="P:NDepend.CodeModel.IAssembly.NormDistFromMainSeq" /> code metric.<br /></remarks>
      <returns>
        <i>null</i> if this assembly is a third-party assembly.<br />
            Otherwise returns this assembly <see cref="P:NDepend.CodeModel.IAssembly.DistFromMainSeq" /> numeric value.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.NormDistFromMainSeq">
      <summary>
            Gets a float numeric nullable value in the range [0,1] assessing the balance between <see cref="P:NDepend.CodeModel.IAssembly.Abstractness" /> and <see cref="P:NDepend.CodeModel.IAssembly.Instability" /> for this assembly. A returned value close to 0 indicates an ideal balance.
            </summary>
      <remarks>
        <i>
          <u>Abstractness versus Instability Metrics:</u>
        </i>
        <br />
            By measuring coupling between types of your application, NDepend assesses the stability of each assembly.<br />
            An assembly is considered stable if its child types are used by a lot of types of others application assemblies (i.e stable = painful to modify).<br />
            If an assembly contains many abstract types (i.e interfaces and abstract classes) and few concrete types, it is considered as abstract.<br />
            Thus, <b>NDepend helps you detect which assemblies are potentially painful to maintain (i.e concrete and stable) and which assemblies are potentially useless (i.e abstract and instable).</b><br /><i>This theory and metrics have been first introduced by the excellent book <a href="http://www.amazon.com/Principles-Patterns-Practices-Robert-Martin/dp/0131857258/" target="_blank">Agile Software Development: Principles, Patterns, and Practices in C#, Robert C. Martin (Prentice Hall PTR, 2006)</a>.</i><br /><br /><i><u>Distance from main Sequence definition:</u></i><br />
            It represents the perpendicular normalized distance of an assembly from the idealized line <i>A</i> + <i>I</i> = 1. <i>A</i> stands for <i>Abstractness</i> and <i>I</i> for <i>Instability</i>. This line is called main sequence.<br />
            This metric is an indicator of the assembly's balance between abstractness and instability. An assembly squarely on the main sequence is optimally balanced with respect to its abstractness and stability.<br />
            Ideal assemblies are either completely abstract and stable (<i>I</i>=0, <i>A</i>=1) or completely concrete and instable (<i>I</i>=1, <i>A</i>=0).<br />
            The range for this <i>NormDistFromMainSeq</i> metric is 0 to 1, with <i>D</i>=0 indicating an assembly that is coincident with the main sequence and <i>D</i>=1 indicating an assembly that is as far from the main sequence as possible.<br />
            A picture provided within the NDepend report reveals if an assembly is in the zone of pain (<i>I</i> and <i>A</i> both close to 0) or in the zone of uselessness (<i>I</i> and <i>A</i> both close to 1).<br /><br /><i><u>Recommendations:</u></i><br />
            Assemblies where <i>NormDistFromMainSeq</i> is higher than 0.7 might be problematic. However, in the real world it is very hard to avoid such assemblies.<br />
            Therefore, you should allow just a few of your application assemblies to violate this 0.7 threshold.<br /></remarks>
      <returns>
        <i>null</i> if this assembly is a third-party assembly.<br />
            Otherwise returns this assembly <see cref="P:NDepend.CodeModel.IAssembly.NormDistFromMainSeq" /> numeric value.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.RelationalCohesion">
      <summary>
            Gets a float numeric nullable value assessing this assembly child types average cohesion.
            </summary>
      <remarks>
            Let <i>R</i> be the number of types relationships that are internal to this assembly (i.e that do not connect to types outside the assembly).<br />
            Let <i>N</i> be the number of types within the assembly.<br /><i>H</i> = (<i>R</i> + 1)/ <i>N</i>. The extra 1 in the formula prevents <i>H</i>=0 when <i>N</i>=1.<br />
            The relational cohesion represents the relationship that this assembly has to all its types.<br /><br /><i><u>Recommendations:</u></i><br />
            As classes inside an assembly should be strongly related, the cohesion should be high. On the other hand, too high values may indicate over-coupling.<br />
            A good range for <i>RelationalCohesion</i> is 1.5 to 4.0.<br />
            Hence, assemblies where <i>RelationalCohesion</i> &lt; 1.5 or <i>RelationalCohesion</i> &gt; 4.0 might be problematic.<br /></remarks>
      <returns>
        <i>null</i> if this assembly is a third-party assembly.<br />
            Otherwise returns this assembly <see cref="P:NDepend.CodeModel.IAssembly.RelationalCohesion" /> numeric value.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.NbTypesUsingMe">
      <summary>
            Gets a numeric nullable value counting types outside this assembly using a child type of this assembly.
            </summary>
      <remarks>
            More information concerning the usefulness of this code metric is available in the descripions of the <see cref="P:NDepend.CodeModel.IAssembly.NormDistFromMainSeq" /> and <see cref="P:NDepend.CodeModel.IAssembly.RelationalCohesion" /> code metrics.<br /></remarks>
      <returns>
        <i>null</i> if this assembly is a third-party assembly.<br />
            Otherwise returns this assembly <see cref="P:NDepend.CodeModel.IAssembly.NbTypesUsingMe" /> numeric value.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IAssembly.NbTypesUsed">
      <summary>
            Gets a numeric nullable value counting types outside this assembly used by child types of this assembly. Third-party types are taken account in this cout.
            </summary>
      <remarks>
            More information concerning the usefulness of this code metric is available in the descripions of the <see cref="P:NDepend.CodeModel.IAssembly.NormDistFromMainSeq" /> and <see cref="P:NDepend.CodeModel.IAssembly.RelationalCohesion" /> code metrics.<br />s
            </remarks>
      <returns>
        <i>null</i> if this assembly is a third-party assembly.<br />
            Otherwise returns this assembly <see cref="P:NDepend.CodeModel.IAssembly.NbTypesUsed" /> numeric value.<br /></returns>
    </member>
    <member name="T:NDepend.CodeModel.ICodeBase">
      <summary>
            Represents a code base snapshot, produced by a NDepend analysis. A <see cref="T:NDepend.CodeModel.ICodeBase" /> object can be obtained from the <see cref="T:NDepend.Analysis.IAnalysisResult" />.<see cref="P:NDepend.Analysis.IAnalysisResult.CodeBase" /> property.
            </summary>
    </member>
    <member name="T:NDepend.CodeModel.ICodeBaseView">
      <summary>
            Represents a total or restrained view of a <see cref="T:NDepend.CodeModel.ICodeBase" /> object.
            </summary>
      <remarks>
            Apart the <see cref="T:NDepend.CodeModel.ICodeBase" /> interface that implements <see cref="T:NDepend.CodeModel.ICodeBaseView" />, three code base views are available per default:<br /><ul><li><see cref="T:NDepend.CodeModel.ICodeBase" />.<see cref="P:NDepend.CodeModel.ICodeBase.Application" />, available in CQLinq through the predefined field <i>Application</i>.</li><li><see cref="T:NDepend.CodeModel.ICodeBase" />.<see cref="P:NDepend.CodeModel.ICodeBase.ThirdParty" />, available in CQLinq through the predefined field <i>ThirdParty</i>.</li><li><see cref="T:NDepend.Project.IProject" />.<see cref="P:NDepend.Project.IProject.CodeQueries" />.<see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.ComputeJustMyCode(NDepend.CodeQuery.IGroupOfGroups,NDepend.CodeModel.ICodeBase)" />, available in CQLinq through the predefined field <i>JustMyCode</i>.
            The <i>JustMyCode</i> code base view represents code elements that are not matched by any queries prefixed with the CQLinq keyword <i>notmycode</i> (<see cref="T:NDepend.CodeQuery.KindOfCodeQueryExpression" />.<see cref="F:NDepend.CodeQuery.KindOfCodeQueryExpression.NotMyCode" />).</li></ul>
            A custom <see cref="T:NDepend.CodeModel.ICodeBaseView" /> can be created through the method <see cref="T:NDepend.CodeModel.ICodeBaseView" />.<see cref="M:NDepend.CodeModel.ICodeBaseView.CreateSubView(System.Predicate{NDepend.CodeModel.ICodeElement})" />.
            </remarks>
    </member>
    <member name="M:NDepend.CodeModel.ICodeBaseView.Contains(NDepend.CodeModel.ICodeElement)">
      <summary>
            Gets a value indicating whether <paramref name="codeElement" /> is part of this code base view.
            </summary>
      <remarks>
            This method has a constant time complexity.
            </remarks>
      <param name="codeElement">The code element.</param>
      <requires description="the codeElement object must not be null" csharp="codeElement != null" vb="codeElement &lt;&gt; Nothing">codeElement != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICodeBaseView.CreateSubView(System.Predicate{NDepend.CodeModel.ICodeElement})">
      <summary>
            Creates a sub-view object, containing only this view code elements for which <paramref name="predicate" /> returns true;
            </summary>
      <remarks>Internally this method is used to create <i>codeBase.<see cref="P:NDepend.CodeModel.ICodeBase.Application" /></i> and <i>codeBase.<see cref="P:NDepend.CodeModel.ICodeBase.ThirdParty" /></i> views.</remarks>
      <param name="predicate">The predicate that elements in returned sub-view must satisfy.</param>
      <requires description="the predicate object must not be null" csharp="predicate != null" vb="predicate &lt;&gt; Nothing">predicate != null</requires>
      <ensures description="returned code base view object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:NDepend.CodeModel.ICodeBaseView.CodeBase">
      <summary>
            Gets the original <see cref="T:NDepend.CodeModel.ICodeBase" /> object from which this <see cref="T:NDepend.CodeModel.ICodeBaseView" /> is inferred from.
            </summary>
      <getter>
        <ensures description="returned code base object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ICodeBaseView.Assemblies">
      <summary>
            Gets the sequence of assemblies within this code base view.
            </summary>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ICodeBaseView.Namespaces">
      <summary>
            Gets the sequence of namespaces within this code base view.
            </summary>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ICodeBaseView.Types">
      <summary>
            Gets the sequence of types within this code base view.
            </summary>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ICodeBaseView.Methods">
      <summary>
            Gets the sequence of methods within this code base view.
            </summary>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ICodeBaseView.Fields">
      <summary>
            Gets the sequence of fields within this code base view.
            </summary>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ICodeBase.Name">
      <summary>
            Gets the code base name, which is equals to the <see cref="T:NDepend.Project.IProject" />.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.Name" />.
            </summary>
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned string is not empty" csharp="result.Length &gt; 0" vb="result.Length &gt; 0">result.Length &gt; 0</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ICodeBase.Application">
      <summary>
            Gets a <see cref="T:NDepend.CodeModel.ICodeBaseView" /> object restrained only to application assemblies and code elements declared in application assemblies.
            </summary>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ICodeBase.ThirdParty">
      <summary>
            Gets a <see cref="T:NDepend.CodeModel.ICodeBaseView" /> object restrained only to third-party assemblies and code elements declared in third-party assemblies and used by application assemblies.
            </summary>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ICodeBase.CoverageDataAvailable">
      <summary>
            Gets a value that determines if some coverage data is available for this code base snapshot.
            </summary>
      <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCodeCoverageData" />
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" />
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />
      <seealso cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" />
      <seealso cref="T:NDepend.Project.IProjectCoverage" />
    </member>
    <member name="T:NDepend.CodeModel.ICodeMetric`2">
      <summary>
            Represent a code metric, a correspondance between a set of code elements and some numerical values.
            </summary>
      <remarks>
            A code metric object is returned by extension methods of <see cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" /> defined on sequences of code elements.<br />
            A custom code metric object can also be created through the particular method <see cref="T:NDepend.CodeModel.ExtensionMethodsHelpers" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.FillIterative``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0}})" />.
            </remarks>
      <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
      <typeparam name="TNumeric">
            The numeric value type that is one of these type: <i>byte</i>, <i>sbyte</i>, <i>short</i>, <i>ushort</i>, <i>int</i>, <i>uint</i>, <i>long</i>, <i>ulong</i>, <i>float</i>, <i>double</i>, <i>decimal</i>. <br /></typeparam>
      <seealso cref="T:NDepend.CodeModel.ICodeMetricValue`2" />
      <seealso cref="T:NDepend.CodeModel.ExtensionMethodsSequenceUsage" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.FillIterative``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0}})" />
    </member>
    <member name="M:NDepend.CodeModel.ICodeMetric`2.DefinedFor(`0)">
      <summary>
            Gets a value indicating whether this code metric is defined for <paramref name="codeElement" />.
            </summary>
      <param name="codeElement">The code element.</param>
      <remarks>
            This method has a constant time complexity.
            </remarks>
      <requires description="codeElement must not be null" csharp="(decimal)codeElement != null" vb="((Object)codeElement) &lt;&gt; Nothing">(decimal)codeElement != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICodeMetric`2.ValueOf(`0)">
      <summary>
            Gets this code metric value for <paramref name="codeElement" />. Gets <i>null</i> if the metric is not defined for <paramref name="codeElement" />.
            </summary>
      <param name="codeElement">The code element.</param>
      <remarks>
            This method has a constant time complexity.
            </remarks>
      <requires description="codeElement must not be null" csharp="(decimal)codeElement != null" vb="((Object)codeElement) &lt;&gt; Nothing">(decimal)codeElement != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICodeMetric`2.ElementsWithValue(`1)">
      <summary>
            Gets the sequence of code elements for which, this code metric value is equals to <paramref name="value" /> Gets an empty sequence if no code element are matched.
            </summary>
      <param name="value">The value.</param>
      <remarks>
            This method has a <i>O(<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount" />)</i> time complexity.
            </remarks>
      <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount">
      <summary>
            Gets the number of code elements for which this code metric is defined.
            </summary>
      <remarks>
            This method has a constant time complexity.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain">
      <summary>
            Gets the sequence of code elements for which this code metric is defined.
            </summary>
      <remarks>
            This method has a <i>O(<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount" />)</i> time complexity.
            </remarks>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ICodeMetric`2.Item(`0)">
      <summary>
            Gets this code metric value for <paramref name="codeElement" />. Gets <i>null</i> if the metric is not defined for <paramref name="codeElement" />.
            </summary>
      <param name="codeElement">The code element.</param>
      <remarks>
            This accessor is equivalent to the method <see cref="M:NDepend.CodeModel.ICodeMetric`2.ValueOf(`0)" />.<br />
            This method has a constant time complexity.
            </remarks>
      <getter>
        <requires description="codeElement must not be null" csharp="(decimal)codeElement != null" vb="((Object)codeElement) &lt;&gt; Nothing">(decimal)codeElement != null</requires>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ICodeMetric`2.Values">
      <summary>
            Gets the sequence of this code metric values taken by all code elements in this.<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomain" />. Numeric values are sorted with an ascending order in the sequence.
            </summary>
      <remarks>
            Gets an empty sequence if DefinitionDomain is empty.<br />
            Notice that this.<see cref="P:NDepend.CodeModel.ICodeMetric`2.Values" />.Count() can be lower than this.<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount" /> if several code elements have the same value.<br />
            This method has a <i>O(<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount" />)</i> time complexity.
            </remarks>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ICodeMetric`2.MinValue">
      <summary>
            Gets the the minimum value in this.<see cref="P:NDepend.CodeModel.ICodeMetric`2.Values" />.
            </summary>
      <remarks>
            If this.<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount" /> is zero, returns <i>null</i>.<br />
            This method has a <i>O(<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount" />)</i> time complexity.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.ICodeMetric`2.MaxValue">
      <summary>
            Gets the the maximum value in this.<see cref="P:NDepend.CodeModel.ICodeMetric`2.Values" />.
            </summary>
      <remarks>
            If this.<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount" /> is zero, returns <i>null</i>.<br />
            This method has a <i>O(<see cref="P:NDepend.CodeModel.ICodeMetric`2.DefinitionDomainCount" />)</i> time complexity.
            </remarks>
    </member>
    <member name="T:NDepend.CodeModel.ICodeMetricValue`2">
      <summary>
            Represent a <see cref="T:NDepend.CodeModel.ICodeMetric`2" /> value.
            </summary>
      <typeparam name="TCodeElement">The code element type that is <see cref="T:NDepend.CodeModel.ICodeElement" /> or that implements <see cref="T:NDepend.CodeModel.ICodeElement" />.</typeparam>
      <typeparam name="TNumeric">
            The numeric value type that is one of these type: <i>byte</i>, <i>sbyte</i>, <i>short</i>, <i>ushort</i>, <i>int</i>, <i>uint</i>, <i>long</i>, <i>ulong</i>, <i>float</i>, <i>double</i>, <i>decimal</i>. <br /></typeparam>
      <seealso cref="T:NDepend.CodeModel.ICodeMetric`2" />
    </member>
    <member name="P:NDepend.CodeModel.ICodeMetricValue`2.CodeElement">
      <summary>
            Gets the code element of this <see cref="T:NDepend.CodeModel.ICodeMetricValue`2" /> object.
            </summary>
      <getter>
        <ensures description="returned code element object is not null" csharp="(decimal)result != null" vb="((Object)result) &lt;&gt; Nothing">(decimal)result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ICodeMetricValue`2.Value">
      <summary>
            Gets the numeric value of this <see cref="T:NDepend.CodeModel.ICodeMetricValue`2" /> object.
            </summary>
    </member>
    <member name="T:NDepend.CodeModel.ICompareContext">
      <summary>
            Represents a diff context of two <see cref="T:NDepend.CodeModel.ICodeBase" /> objects compared, <see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" /> and <see cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />. A <see cref="T:NDepend.CodeModel.ICompareContext" /> object can be obtained through the extension method <see cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />.
            </summary>
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />
      <seealso cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare" />
      <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext" />
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)" />
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.ICollection{System.String},NDepend.CodeModel.ICompareContext)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceFileLine,NDepend.CodeModel.ISourceFileLine)" />
    </member>
    <member name="M:NDepend.CodeModel.ICompareContext.NewerVersion``1(NDepend.CodeModel.ICodeNode{``0})">
      <summary>
            Returns the newer version of the <paramref name="codeNode" /> object.
            </summary>
      <remarks>
            If <paramref name="codeNode" /> is already the newer version, returns the <paramref name="codeNode" /> object.<br />
            If <paramref name="codeNode" /> has been removed and has no corresponding newer version, returns <i>null</i>.<br />
            This method has a constant time complexity.<br /></remarks>
      <typeparam name="T">
        <i>T</i> is the closed <see cref="T:NDepend.CodeModel.ICodeNode`1" /> generic type, like in <i>ICodeNode&lt;IMethod&gt;</i> or <i>ICodeNode&lt;ICodeBase&gt;</i> for example.</typeparam>
      <param name="codeNode">The <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object. A <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object.</param>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.NewerVersion``1(NDepend.CodeModel.ICodeNode{``0})" />
      <requires description="the codeNode object must not be null" csharp="codeNode != null" vb="codeNode &lt;&gt; Nothing">codeNode != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICompareContext.OlderVersion``1(NDepend.CodeModel.ICodeNode{``0})">
      <summary>
            Returns the older version of the <paramref name="codeNode" /> object.
            </summary>
      <remarks>
            If <paramref name="codeNode" /> is already the older version, returns the <paramref name="codeNode" /> object.<br />
            If <paramref name="codeNode" /> has been added and has no corresponding older version, returns <i>null</i>.<br />
            This method has a constant time complexity.<br /></remarks>
      <typeparam name="T">
        <i>T</i> is the closed <see cref="T:NDepend.CodeModel.ICodeNode`1" /> generic type, like in <i>ICodeNode&lt;IMethod&gt;</i> or <i>ICodeNode&lt;ICodeBase&gt;</i> for example.</typeparam>
      <param name="codeNode">The <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object. A <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object. </param>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.OlderVersion``1(NDepend.CodeModel.ICodeNode{``0})" />
      <requires description="the codeNode object must not be null" csharp="codeNode != null" vb="codeNode &lt;&gt; Nothing">codeNode != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICompareContext.IsInNewerBuild``1(NDepend.CodeModel.ICodeNode{``0})">
      <summary>
            Returns <i>true</i> if the <paramref name="codeNode" /> object is in the newer version of the code base.
            </summary>
      <remarks>
            This method has a constant time complexity.
            </remarks>
      <typeparam name="T">
        <i>T</i> is the closed <see cref="T:NDepend.CodeModel.ICodeNode`1" /> generic type, like in <i>ICodeNode&lt;IMethod&gt;</i> or <i>ICodeNode&lt;ICodeBase&gt;</i> for example.</typeparam>
      <param name="codeNode">The <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object. A <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object. </param>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsInNewerBuild``1(NDepend.CodeModel.ICodeNode{``0})" />
      <requires description="the codeNode object must not be null" csharp="codeNode != null" vb="codeNode &lt;&gt; Nothing">codeNode != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICompareContext.IsInOlderBuild``1(NDepend.CodeModel.ICodeNode{``0})">
      <summary>
            Returns <i>true</i> if the <paramref name="codeNode" /> object is in the older version of the code base.
            </summary>
      <remarks>
            This method has a constant time complexity.
            </remarks>
      <typeparam name="T">
        <i>T</i> is the closed <see cref="T:NDepend.CodeModel.ICodeNode`1" /> generic type, like in <i>ICodeNode&lt;IMethod&gt;</i> or <i>ICodeNode&lt;ICodeBase&gt;</i> for example.</typeparam>
      <param name="codeNode">The <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object. A <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object. </param>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsInOlderBuild``1(NDepend.CodeModel.ICodeNode{``0})" />
      <requires description="the codeNode object must not be null" csharp="codeNode != null" vb="codeNode &lt;&gt; Nothing">codeNode != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICompareContext.IsPresentInBothBuilds``1(NDepend.CodeModel.ICodeNode{``0})">
      <summary>
            Returns <i>true</i> if the <paramref name="codeNode" /> object is both in the newer and older versions of the code base.
            </summary>
      <remarks>
            If <i>true</i> is returned, this means that the <paramref name="codeNode" /> has not been added nor removed.<br />
            This method has a constant time complexity.
            </remarks>
      <typeparam name="T">
        <i>T</i> is the closed <see cref="T:NDepend.CodeModel.ICodeNode`1" /> generic type, like in <i>ICodeNode&lt;IMethod&gt;</i> or <i>ICodeNode&lt;ICodeBase&gt;</i> for example.</typeparam>
      <param name="codeNode">The <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object. A <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object. </param>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsPresentInBothBuilds``1(NDepend.CodeModel.ICodeNode{``0})" />
      <requires description="the codeNode object must not be null" csharp="codeNode != null" vb="codeNode &lt;&gt; Nothing">codeNode != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICompareContext.WasChanged``1(NDepend.CodeModel.ICodeNode{``0})">
      <summary>
            Returns <i>true</i> if the <paramref name="codeNode" /> object was changed in any way (code change, comment change, visibility change...).
            </summary>
      <remarks>
            This method has a constant time complexity.
            </remarks>
      <typeparam name="T">
        <i>T</i> is the closed <see cref="T:NDepend.CodeModel.ICodeNode`1" /> generic type, like in <i>ICodeNode&lt;IMethod&gt;</i> or <i>ICodeNode&lt;ICodeBase&gt;</i> for example.</typeparam>
      <param name="codeNode">The <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object. A <see cref="T:NDepend.CodeModel.ICodeNode`1" /> object can be a <see cref="T:NDepend.CodeModel.ICodeElement" /> or a <see cref="T:NDepend.CodeModel.ICodeBase" /> object. </param>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.WasChanged``1(NDepend.CodeModel.ICodeNode{``0})" />
      <requires description="the codeNode object must not be null" csharp="codeNode != null" vb="codeNode &lt;&gt; Nothing">codeNode != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICompareContext.WasAdded(NDepend.CodeModel.ICodeElement)">
      <summary>
            Returns <i>true</i> if the <paramref name="codeElement" /> object has been added and thus, is not present in the older version of the code base.
            </summary>
      <remarks>
            This method has a constant time complexity.
            </remarks>
      <param name="codeElement">The <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.WasAdded(NDepend.CodeModel.ICodeElement)" />
      <requires description="the codeElement object must not be null" csharp="codeElement != null" vb="codeElement &lt;&gt; Nothing">codeElement != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICompareContext.WasRemoved(NDepend.CodeModel.ICodeElement)">
      <summary>
            Returns <i>true</i> if the <paramref name="codeElement" /> object has been removed and thus, is not present in the newer version of the code base.
            </summary>
      <remarks>
            This method has a constant time complexity.
            </remarks>
      <param name="codeElement">The <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.WasRemoved(NDepend.CodeModel.ICodeElement)" />
      <requires description="the codeElement object must not be null" csharp="codeElement != null" vb="codeElement &lt;&gt; Nothing">codeElement != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICompareContext.IsUsedRecently(NDepend.CodeModel.ICodeElement)">
      <summary>
            Returns <i>true</i> if the <paramref name="codeElement" /> object is in a third-party assembly (or is a third-party assembly itself), and if it is used by the newer version of the code base, but not by the older version.
            </summary>
      <remarks>
            This method has a constant time complexity.
            </remarks>
      <param name="codeElement">The <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsUsedRecently(NDepend.CodeModel.ICodeElement)" />
      <requires description="the codeElement object must not be null" csharp="codeElement != null" vb="codeElement &lt;&gt; Nothing">codeElement != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICompareContext.IsNotUsedAnymore(NDepend.CodeModel.ICodeElement)">
      <summary>
            Returns <i>true</i> if the <paramref name="codeElement" /> object is in a third-party assembly (or is a third-party assembly itself), and if it is used by the older version of the code base, but not by the newer version.
            </summary>
      <remarks>
            This method has a constant time complexity.
            </remarks>
      <param name="codeElement">The <see cref="T:NDepend.CodeModel.ICodeElement" /> object. A <see cref="T:NDepend.CodeModel.ICodeElement" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsNotUsedAnymore(NDepend.CodeModel.ICodeElement)" />
      <requires description="the codeElement object must not be null" csharp="codeElement != null" vb="codeElement &lt;&gt; Nothing">codeElement != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICompareContext.CodeWasChanged(NDepend.CodeModel.ICodeContainer)">
      <summary>
            Returns <i>true</i> if the code of this <paramref name="codeContainer" /> object, has been modified.
            </summary>
      <remarks>
            This method has a constant time complexity.
            </remarks>
      <param name="codeContainer">The <see cref="T:NDepend.CodeModel.ICodeContainer" /> object. A <see cref="T:NDepend.CodeModel.ICodeContainer" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.CodeWasChanged(NDepend.CodeModel.ICodeContainer)" />
      <requires description="the codeContainer object must not be null" csharp="codeContainer != null" vb="codeContainer &lt;&gt; Nothing">codeContainer != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICompareContext.CommentsWereChanged(NDepend.CodeModel.ICodeContainer)">
      <summary>
            Returns <i>true</i> if comments of this <paramref name="codeContainer" /> object, have been modified.
            </summary>
      <remarks>
            So far, comments change is detected only when <see cref="T:NDepend.CodeModel.ICodeContainer" />.<see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfComment" /> has been changed.<br />
            This method has a constant time complexity.
            </remarks>
      <param name="codeContainer">The <see cref="T:NDepend.CodeModel.ICodeContainer" /> object. A <see cref="T:NDepend.CodeModel.ICodeContainer" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" />, <see cref="T:NDepend.CodeModel.IType" /> or <see cref="T:NDepend.CodeModel.IMethod" /> object.</param>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.CommentsWereChanged(NDepend.CodeModel.ICodeContainer)" />
      <requires description="the codeContainer object must not be null" csharp="codeContainer != null" vb="codeContainer &lt;&gt; Nothing">codeContainer != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICompareContext.VisibilityWasChanged(NDepend.CodeModel.IMember)">
      <summary>
            Returns <i>true</i> if the visibility of this <paramref name="member" /> has been changed.
            </summary>
      <remarks>
            This method has a constant time complexity.
            </remarks>
      <param name="member">The <see cref="T:NDepend.CodeModel.IMember" /> object. A <see cref="T:NDepend.CodeModel.IMember" /> object can be a <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.VisibilityWasChanged(NDepend.CodeModel.IMember)" />
      <requires description="the member object must not be null" csharp="member != null" vb="member &lt;&gt; Nothing">member != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICompareContext.BecameObsolete(NDepend.CodeModel.IMember)">
      <summary>
            Returns <i>true</i> if the <paramref name="member" /> is not tagged with <i>System.ObsoleteAttribute</i> in the older version of the code base, but is tagged as obsolete in the newer version of the code base.
            </summary>
      <remarks>
            This method has a constant time complexity.
            </remarks>
      <param name="member">The <see cref="T:NDepend.CodeModel.IMember" /> object. A <see cref="T:NDepend.CodeModel.IMember" /> object can be a <see cref="T:NDepend.CodeModel.IType" />, <see cref="T:NDepend.CodeModel.IMethod" /> or <see cref="T:NDepend.CodeModel.IField" /> object.</param>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.BecameObsolete(NDepend.CodeModel.IMember)" />
      <requires description="the member object must not be null" csharp="member != null" vb="member &lt;&gt; Nothing">member != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.ICompareContext.IsUsedDifferently(NDepend.CodeModel.ICodeElementParent)">
      <summary>
            Returns <i>true</i> if the <paramref name="codeElementParent" /> is a namespace or a type in a third-party assembly (or is a third-party assembly itself) and if some of its children code elements are not used anymore by the newer version of the code base, or are used by the newer version of the code base, but are not used by the older version.
            </summary>
      <remarks>
            This method has a constant time complexity.
            </remarks>
      <param name="codeElementParent">The <see cref="T:NDepend.CodeModel.ICodeElementParent" /> object. A <see cref="T:NDepend.CodeModel.ICodeElementParent" /> object can be a <see cref="T:NDepend.CodeModel.IAssembly" />, <see cref="T:NDepend.CodeModel.INamespace" /> or <see cref="T:NDepend.CodeModel.IType" /> object.</param>
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare.IsUsedDifferently(NDepend.CodeModel.ICodeElementParent)" />
      <requires description="the codeElementParent object must not be null" csharp="codeElementParent != null" vb="codeElementParent &lt;&gt; Nothing">codeElementParent != null</requires>
    </member>
    <member name="P:NDepend.CodeModel.ICompareContext.NewerCodeBase">
      <summary>
            Gets the newer version of the code base for this <see cref="T:NDepend.CodeModel.ICompareContext" /> object.
            </summary>
      <remarks>
            This property getter has a constant time complexity.<br /></remarks>
      <seealso cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />
      <getter>
        <ensures description="returned codeBase object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ICompareContext.OlderCodeBase">
      <summary>
            Gets the older version of the code base for this <see cref="T:NDepend.CodeModel.ICompareContext" /> object.
            </summary>
      <remarks>
            This property getter has a constant time complexity.<br /></remarks>
      <seealso cref="P:NDepend.CodeModel.ICompareContext.OlderCodeBase" />
      <getter>
        <ensures description="returned codeBase object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeModel.IField">
      <summary>
            Represents a field declared in an application assembly, or declared in a third-party assembly and used the by application code.
            </summary>
    </member>
    <member name="T:NDepend.CodeModel.IMember">
      <summary>
            Represents a member code element. This interface is implemented by <see cref="T:NDepend.CodeModel.IMethod" />, <see cref="T:NDepend.CodeModel.IField" /> and <see cref="T:NDepend.CodeModel.IType" />.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMember.FullName">
      <summary>Gets a string representing the full name of this member.</summary>
      <remarks>
        <ul>
          <li>If this member is a <see cref="T:NDepend.CodeModel.IType" />, the full name is <i>NamespaceName.TypeName&lt;T&gt;</i>.</li>
          <li>If this member is a nested <see cref="T:NDepend.CodeModel.IType" />, the full name is <i>NamespaceName.OutterTypeName+TypeName&lt;T&gt;</i>.</li>
          <li>If this member is a <see cref="T:NDepend.CodeModel.IMethod" />, the full name is <i>NamespaceName.TypeName.Method&lt;T&gt;(parameters types)</i>.</li>
          <li>If this member is a <see cref="T:NDepend.CodeModel.IField" />, the full name is <i>NamespaceName.TypeName.FieldName</i>.</li>
          <li>If the parent namespace is the anonymous namespace, the full name begins directly with <i>TypeName...</i>.</li>
        </ul>
            This property getter has a constant time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.ICodeElement.Name" />
      <seealso cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" />
      <seealso cref="T:NDepend.CodeModel.ISimpleNamed" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullName``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameNotIn``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsNaming.WithFullNameWildcardMatch``1(System.Collections.Generic.IEnumerable{``0},System.String)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.ToMemberFullNameLikePredicate(System.String)" />
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned string is not empty" csharp="result.Length &gt; 0" vb="result.Length &gt; 0">result.Length &gt; 0</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IMember.Visibility">
      <summary>Gets a <see cref="P:NDepend.CodeModel.IMember.Visibility" /> value representing the visibility of this member.</summary>
      <seealso cref="P:NDepend.CodeModel.IMember.IsPublic" />
      <seealso cref="P:NDepend.CodeModel.IMember.IsInternal" />
      <seealso cref="P:NDepend.CodeModel.IMember.IsProtected" />
      <seealso cref="P:NDepend.CodeModel.IMember.IsProtectedAndInternal" />
      <seealso cref="P:NDepend.CodeModel.IMember.IsProtectedOrInternal" />
      <seealso cref="P:NDepend.CodeModel.IMember.IsPrivate" />
      <seealso cref="P:NDepend.CodeModel.IMember.OptimalVisibility" />
    </member>
    <member name="P:NDepend.CodeModel.IMember.OptimalVisibility">
      <summary>Gets a <see cref="P:NDepend.CodeModel.IMember.Visibility" /> value representing the optimal visibility this member could have.</summary>
      <seealso cref="P:NDepend.CodeModel.IMember.CouldBeInternal" />
      <seealso cref="P:NDepend.CodeModel.IMember.CouldBeProtected" />
      <seealso cref="P:NDepend.CodeModel.IMember.CouldBeInternalProtected" />
      <seealso cref="P:NDepend.CodeModel.IMember.CouldBePrivate" />
      <seealso cref="P:NDepend.CodeModel.IMember.Visibility" />
      <seealso cref="T:NDepend.Attributes.CannotDecreaseVisibilityAttribute" />
    </member>
    <member name="P:NDepend.CodeModel.IMember.ParentType">
      <summary>
            Gets the parent type of this member. The returned object can be null only if this member is a type where <see cref="P:NDepend.CodeModel.IType.IsNested" /> equals <i>false</i>.
            </summary>
      <remarks>
            This property getter has a constant time complexity.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMember.ParentNamespace">
      <summary>
            Gets the parent namespace where this member is declared in.
            </summary>
      <remarks>
            This property getter has a constant time complexity.
            </remarks>
      <getter>
        <ensures description="returned namespace object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IMember.ParentAssembly">
      <summary>
            Gets the parent assembly where this member is declared in.
            </summary>
      <remarks>
            This property getter has a constant time complexity.
            </remarks>
      <getter>
        <ensures description="returned assembly object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IMember.IsPubliclyVisible">
      <summary>
            Gets a value indicating whether this member is publicly visible outside of its declaring assembly.
            </summary>
      <remarks>
            Being a publicly visible member is a stronger condition than just having the property getter <see cref="P:NDepend.CodeModel.IMember.IsPublic" /> equals to <i>true.</i>.<br />
            Indeed, it is common that a <i>public</i> member is declared in an <i>internal</i> type, in which case the member is not <i>publicly visible</i>.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMember.IsMethod">
      <summary>Gets a value indicating whether this member is a method, and can then be safely downcasted to <see cref="T:NDepend.CodeModel.IMethod" />.</summary>
    </member>
    <member name="P:NDepend.CodeModel.IMember.IsField">
      <summary>Gets a value indicating whether this member is a field, and can then be safely downcasted to <see cref="T:NDepend.CodeModel.IField" />.</summary>
    </member>
    <member name="P:NDepend.CodeModel.IMember.IsType">
      <summary>Gets a value indicating whether this member is a type, and can then be safely downcasted to <see cref="T:NDepend.CodeModel.IType" />.</summary>
    </member>
    <member name="P:NDepend.CodeModel.IMember.IsPublic">
      <summary>
            Gets a value indicating whether this member is declared as <i>public</i>.
            </summary>
      <remarks>
            See the condition <see cref="P:NDepend.CodeModel.IMember.IsPubliclyVisible" /> if you wish to assess if a member is publicly visible outside of its declaring assembly.s
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMember.IsPrivate">
      <summary>
            Gets a value indicating whether this member is declared as <i>private</i>.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMember.IsInternal">
      <summary>
            Gets a value indicating whether this member is declared as <i>internal</i> in C#, or <i>Friend</i> in VB.NET.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMember.IsProtected">
      <summary>
            Gets a value indicating whether this member is declared as <i>protected</i>.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMember.IsProtectedAndInternal">
      <summary>
            Gets a value indicating whether this member is declared as <i>protected <b>and</b> internal</i>. This visibility level is provided by the IL language but is not supported neither by C# nor VB.NET.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMember.IsProtectedOrInternal">
      <summary>
            Gets a value indicating whether this member is declared as <i>protected internal</i> in C#, or <i>Protected Friend</i> in VB.NET.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMember.IsStatic">
      <summary>
            Gets a value indicating whether this member is a static method or field, or a static type.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMember.IsSpecialName">
      <summary>
            Gets a value indicating whether this member has a name that requires special handling, in the sense defined by <i>System.Type.IsSpecialName</i> and <i>System.Reflection.MethodBase.IsSpecialName</i>.
            </summary>
      <remarks>
            Typically methods with special names are constructors, properties/events/indexers accessors, explicit interface method implementation.<br />
            Fields with special names is the instance field named <i>value__</i> generated for each enumeration.<br />
            &gt;
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMember.IsGeneratedByCompiler">
      <summary>
            Gets a value indicating whether this member has been generated by the compiler. This situation typically results from the compiler implementing lambdas, anonymous methods and iterators.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMember.IsObsolete">
      <summary>
            Gets a value indicating whether this member is tagged with <i>System.ObsoleteAttribute</i>.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMember.ShouldBePublic">
      <summary>
            Gets a value indicating whether this member is used outside of its declaring assembly thanks to the attribute <i>System.Compilers.Services.InternalsVisibleToAttribute</i>.
            </summary>
      <remarks>
            Often, having code elements that are considered as <see cref="P:NDepend.CodeModel.IMember.ShouldBePublic" /> is not a problem because it is made on purpose. However, it can be interesting to list them.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMember.CouldBeInternal">
      <summary>
            Gets a value indicating whether this member is declared as <i>public</i>, but could be declared as <i>internal</i> in C# (<i>Friend</i> in VB.NET) within the context of the analyzed application.
            </summary>
      <remarks>
            A public code element can be declared as <i>internal</i> if it is not used outside of the assembly it is declared in.<br />
            When analyzing a framework, many of public members will be considered as <see cref="P:NDepend.CodeModel.IMember.CouldBeInternal" /> because there is no analyzed client code using them.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMember.CouldBeInternalProtected">
      <summary>
            Gets a value indicating whether this member is declared as <i>public</i>, but could be declared as <i>protected internal</i> in C# (<i>Protected Friend</i> in VB.NET) within the context of the analyzed application.
            </summary>
      <remarks>
            A public member can be declared as <i>protected internal</i> (reads <i>protected <b>or</b> internal</i>) if it is not used outside of the assembly it is declared in and if it is not used outside of the classes that derive from the class it is declared in.<br />
            When analyzing a framework, some of the public members will be considered as <see cref="P:NDepend.CodeModel.IMember.CouldBeInternalProtected" /> because there is no analyzed client code using them.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMember.CouldBeProtected">
      <summary>
            Gets a value indicating whether this member is declared as <i>public</i>, but could be declared as <i>protected</i> in C# (<i>Protected</i> in VB.NET) within the context of the analyzed application.
            </summary>
      <remarks>
            A public member can be declared as <i>protected</i> if it is not used outside of the classes that derive from the class it is declared in.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMember.CouldBePrivate">
      <summary>
            Gets a value indicating whether this member could be declared as <i>private</i> in C# (<i>Protected</i> in VB.NET) within the context of the analyzed application.
            </summary>
      <remarks>
            A member can be declared as <i>protected</i> if it is not used outside of its parent class.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IField.MethodsUsingMe">
      <summary>
            Gets a sequence of methods that are using this field.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
      <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IField.MethodsAssigningMe">
      <summary>
            Gets a sequence of methods that are assigning this field.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
      <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe">
      <summary>
            Gets a sequence of methods that are assigning this field.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />.Count + this.<see cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
      <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IField.FieldType">
      <summary>
            Gets the field type of this field. Gets <i>null</i> if the field type of this field is not in the scope of assemblies analyzed defined by <see cref="T:NDepend.Project.IProject" />.<see cref="P:NDepend.Project.IProject.CodeToAnalyze" />.
            </summary>
      <remarks>
            This property getter has a constant time complexity.
            </remarks>
      <see cref="P:NDepend.CodeModel.IField.FieldType" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithFieldType(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithFieldTypeIn(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.FieldTypeIs(NDepend.CodeModel.IField,System.String)" />
    </member>
    <member name="P:NDepend.CodeModel.IField.IsEnumValue">
      <summary>
            Gets a value indicating whether this field is a value of an enumeration.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IField.IsEventDelegateObject">
      <summary>
            Gets a value indicating whether this field is an event delegate object. C# and VB.NET compilers define for each event an event adder, an event remover, and a field typed with a delegate class.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IField.IsLiteral">
      <summary>
            Gets a value indicating whether this field is declared with the <i>const</i> keyword in C# and the <i>Const</i> keyword in VB.NET.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IField.IsInitOnly">
      <summary>
            Gets a value indicating whether this field is declared with the <i>readonly</i> keyword in C# and the <i>ReadOnly</i> keyword in VB.NET.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IField.IsImmutable">
      <summary>
            Gets a value indicating whether this field is <i>immutable</i>.
            </summary>
      <remarks>
            A <i>static</i> field is considered as immutable if it is private and if it is only assigned by the static constructor.<br />
            An <i>instance</i> field is considered as immutable if it is private and if it is only assigned by its type’s constructor(s) or its type’s static constructor.<br />
            Fields with a <i>true</i> value for <see cref="P:NDepend.CodeModel.IField.IsLiteral" />, <see cref="P:NDepend.CodeModel.IField.IsEnumValue" /> or <see cref="P:NDepend.CodeModel.ICodeElement.IsThirdParty" /> are <b>never</b> considered as immutable to avoid noise in the search for immutable fields.<br />
            A field with a <i>true</i> value for <see cref="P:NDepend.CodeModel.IField.IsInitOnly" /> is <b>always</b> considered as immutable. <br />
            In addition, a field with a <i>true</i> value for <see cref="P:NDepend.CodeModel.IField.IsImmutable" /> can be safely marked as <i>readonly</i>.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IField.SizeOfInst">
      <summary>
            Gets a numeric nullable value measuring this field contribution, in bytes, to the parent's <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.SizeOfInst" /> value.
            </summary>
      <remarks>
        <i>
          <u>Size of Instance code metric description:</u>
        </i>
        <br />
        <i>SizeOfInst</i> for an instance field with a reference type field (class, interface, delegate) counts for 4 bytes.<br /><i>SizeOfInst</i> for an instance field with a value type field (structure, int, byte, double...) is equal to the value type <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.SizeOfInst" /> value.<br /><i>SizeOfInst</i> for a static field is null.<br /></remarks>
      <returns>
        <i>null</i> if this field is declared in a third-party assembly.<br /><i>null</i> if this field is static.<br />
            Otherwise returns this field <see cref="P:NDepend.CodeModel.IField.SizeOfInst" /> numeric value.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IField.NbMethodsUsingMe">
      <summary>
            Gets the number of methods that use this field.
            </summary>
    </member>
    <member name="T:NDepend.CodeModel.IMethod">
      <summary>
            Represents a method declared in an application assembly, or declared in a third-party assembly and used by the application code.
            </summary>
    </member>
    <member name="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)">
      <summary>
            Gets a value indicating whether this method is assigning the field <paramref name="fieldAssigned" />.
            </summary>
      <param name="fieldAssigned">The field object.</param>
      <remarks>
            This method has a <i>O(<paramref name="fieldAssigned" />.<see cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="the field object must not be null" csharp="fieldAssigned != null" vb="fieldAssigned &lt;&gt; Nothing">fieldAssigned != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.IMethod.CreateA(NDepend.CodeModel.IType)">
      <summary>
            Gets a value indicating whether this method is calling a constructor of the type <paramref name="typeCreated" />.
            </summary>
      <param name="typeCreated">The type object.</param>
      <remarks>
            This method has a O(this.<see cref="P:NDepend.CodeModel.IMethod.NbMethodsCalled" />.Count) time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateA(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfCreateAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyCreateA(NDepend.CodeModel.IMethod,System.String)" />
      <requires description="the type object must not be null" csharp="typeCreated != null" vb="typeCreated &lt;&gt; Nothing">typeCreated != null</requires>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsExtensionMethod">
      <summary>
            Gets a value indicating whether this method is an extension method.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.AccessThis">
      <summary>
            Gets a value indicating whether this method is explicitely accessign the this reference.
            </summary>
      <remarks>
            Returns false for any static method.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.MethodsCalled">
      <summary>
            Gets a sequence of methods that this method is calling. If this method is declared in a third-party assembly, gets an empty sequence.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IMethod.MethodsCalled" />.Count)</i> time complexity.
            </remarks>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.MembersUsed">
      <summary>
            Gets a sequence of fields and methods that this method is using and calling. If this method is declared in a third-party assembly, gets an empty sequence.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IMethod.MembersUsed" />.Count)</i> time complexity.
            </remarks>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.MethodsCallingMe">
      <summary>
            Gets a sequence of methods that are calling this method.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IMethod.MethodsCallingMe" />.Count)</i> time complexity.
            </remarks>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.FieldsUsed">
      <summary>
            Gets a sequence of fields that this method is using. If this method is declared in a third-party assembly, gets an empty sequence.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
      <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.FieldsAssigned">
      <summary>
            Gets a sequence of fields that this method is assigning. If this method is declared in a third-party assembly, gets an empty sequence.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned" />
      <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.FieldsReadButNotAssigned">
      <summary>
            Gets a sequence of fields that this method is reading but not assigning. If this method is declared in a third-party assembly, gets an empty sequence.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsUsed" />
      <seealso cref="P:NDepend.CodeModel.IMethod.FieldsAssigned" />
      <seealso cref="M:NDepend.CodeModel.IMethod.AssignField(NDepend.CodeModel.IField)" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsUsingMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsAssigningMe" />
      <seealso cref="P:NDepend.CodeModel.IField.MethodsReadingMeButNotAssigningMe" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatIndirectlyAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignField(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IField)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfAssignAnyFields(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IField})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IndirectlyAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.OverridesDerived">
      <summary>
            Gets a sequence of methods declared in this method <see cref="P:NDepend.CodeModel.IMember.ParentType" />.<see cref="P:NDepend.CodeModel.IType.DerivedTypes" />, overriding this method. If this method is not overridden, gets an empty sequence.
            </summary>
      <remarks>
            A sequence of methods overriding this method is also returned even if this method is declared in a third-party assembly.<br />
            Methods for which <see cref="P:NDepend.CodeModel.IMethod.IsNewSlot" /> is <i>true</i>, are not in the returned sequence.<br />
            This property getter has a O(this.<see cref="P:NDepend.CodeModel.IMember.ParentType" />.<see cref="P:NDepend.CodeModel.IType.NbChildren" />.Count) time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.OverridesDirectDerived" />
      <seealso cref="P:NDepend.CodeModel.IMethod.OverriddensBase" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.OverridesDirectDerived">
      <summary>
            Gets a sequence of methods declared in this method <see cref="P:NDepend.CodeModel.IMember.ParentType" />.<see cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />, overriding this method. If this method is not overridden, gets an empty sequence.
            </summary>
      <remarks>
            A sequence of methods overriding this method is also returned even if this method is declared in a third-party assembly.<br />
            Methods for which <see cref="P:NDepend.CodeModel.IMethod.IsNewSlot" /> is <i>true</i>, are not in the returned sequence.<br />
            This property getter has a O(this.<see cref="P:NDepend.CodeModel.IMember.ParentType" />.<see cref="P:NDepend.CodeModel.IType.NbChildren" />.Count) time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.OverridesDerived" />
      <seealso cref="P:NDepend.CodeModel.IMethod.OverriddensBase" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.OverriddensBase">
      <summary>
            Gets a sequence of methods declared in this method <see cref="P:NDepend.CodeModel.IMember.ParentType" />.<see cref="P:NDepend.CodeModel.IType.BaseClasses" /> and <see cref="P:NDepend.CodeModel.IType.InterfacesImplemented" />, overriden by this method. If this method doesn't override any method, gets an empty sequence.
            </summary>
      <remarks>
            A sequence of methods overridden by this method is also returned even if this method is declared in a third-party assembly.<br />
            This property getter has a O(this.<see cref="P:NDepend.CodeModel.IMember.ParentType" />.<see cref="P:NDepend.CodeModel.IType.DepthOfInheritance" />.Count) time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.OverridesDerived" />
      <seealso cref="P:NDepend.CodeModel.IMethod.OverridesDirectDerived" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.Overloads">
      <summary>
            Gets a sequence of methods declared in this method <see cref="P:NDepend.CodeModel.IMember.ParentType" />.<see cref="P:NDepend.CodeModel.IType.MethodsAndContructors" />, sharing the same <see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" /> with this method. The sequence returned doesn't contain this method.
            </summary>
      <remarks>
            If this method doesn't have any overload, gets an empty sequence.<br />
            If this method is declared in a third party assembly, gets an empty sequence no matter this method is overloaded or not.<br />
            Properties getters <see cref="P:NDepend.CodeModel.IMethod.IsOverloaded" /> and <see cref="P:NDepend.CodeModel.IMethod.NbOverloads" /> are faster to invoke than this property getter and might be better suited in some situations.<br />
            This property getter has a O(this.<see cref="P:NDepend.CodeModel.IMember.ParentType" />.<see cref="P:NDepend.CodeModel.IType.MethodsAndContructors" />.Count) time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IMethod.IsOverloaded" />
      <seealso cref="P:NDepend.CodeModel.IMethod.NbOverloads" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.ReturnType">
      <summary>
            Gets the return type of this method. Gets <i>null</i> if the return type of this method is not in the scope of assemblies analyzed defined by <see cref="T:NDepend.Project.IProject" />.<see cref="P:NDepend.Project.IProject.CodeToAnalyze" />.
            </summary>
      <remarks>
            This property getter has a constant time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithReturnType(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.WithReturnTypeIn(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IMethod},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.ReturnTypeIs(NDepend.CodeModel.IMethod,System.String)" />
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsConstructor">
      <summary>
            Gets a value indicating whether this method is an instance constructor.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsClassConstructor">
      <summary>
            Gets a value indicating whether this method is a class constructor.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsPropertySetter">
      <summary>
            Gets a value indicating whether this method is a property getter.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsPropertyGetter">
      <summary>
            Gets a value indicating whether this method is a property setter.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsIndexerSetter">
      <summary>
            Gets a value indicating whether this method is an indexer setter.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsIndexerGetter">
      <summary>
            Gets a value indicating whether this method is an indexer getter.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsEventAdder">
      <summary>
            Gets a value indicating whether this method is an event adder.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsEventRemover">
      <summary>
            Gets a value indicating whether this method is an event remover.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsOperator">
      <summary>
            Gets a value indicating whether this method is an operator implementation method.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsEntryPoint">
      <summary>
            Gets a value indicating whether this method is defined as the entry point.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsFinalizer">
      <summary>
            Gets a value indicating whether this method is a finalizer.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsGeneric">
      <summary>
            Gets a value indicating whether this method is a generic method.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsOverloaded">
      <summary>
            Gets a value indicating whether this method one of several methods the same <see cref="P:NDepend.CodeModel.ISimpleNamed.SimpleName" /></summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsVirtual">
      <summary>
            Gets a value indicating whether this method is declared as virtual.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsFinal">
      <summary>
            Gets a value indicating whether this method is declared with the <i>sealed</i> keyword in C#, <i>NotOverridable</i> keyword in VB.NET.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsNewSlot">
      <summary>
            Gets a value indicating whether this method has a new slot in the type's method table.
            </summary>
      <remarks>
            Certainly the best resource on the web about this <i>new slot</i> advanced topic is <a href="http://stackoverflow.com/questions/2072983/more-about-virtual-new-plus-interfaces">this stackoverflow Q&amp;A</a><br />
            Internally, NDepend relies on this <i>new slot</i> value to compute the override/overriden methods sets in <see cref="T:NDepend.CodeModel.IMethod" /> property getter <see cref="P:NDepend.CodeModel.IMethod.OverriddensBase" />, <see cref="P:NDepend.CodeModel.IMethod.OverridesDerived" /> and <see cref="P:NDepend.CodeModel.IMethod.OverridesDirectDerived" />.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsPInvokeImpl">
      <summary>
            Gets a value indicating whether this method is tagged with the <i>System.Runtime.InteropServices.DllImportAttribute</i> attribute.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsExplicitInterfaceImpl">
      <summary>
            Gets a value indicating whether this method is an explicit interface method implementation.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsAbstract">
      <summary>
            Gets a value indicating whether this method is an abstract method, or a method declared on an interface.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsUsingBoxing">
      <summary>
            Gets a value indicating whether this method IL body is using the <b>box</b> IL instruction.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsUsingUnboxing">
      <summary>
            Gets a value indicating whether this method IL body is using the <b>unbox</b> IL instruction.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsUsingPointers">
      <summary>
            Gets a value indicating whether this method contains <i>unsafe code</i> that is using some pointers.
            </summary>
      <remarks>
            VB.NET does not support <i>unsafe code</i> but C# does.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.IsUsingPinning">
      <summary>
            Gets a value indicating whether this method contains <i>unsafe code</i> that is using <i>pinning</i>.
            </summary>
      <remarks>
            VB.NET does not support <i>unsafe code</i> but C# does.<br />
            In C#, <i>pinning</i> is generated through the <i>fixed</i> keyword.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.ChangesObjectState">
      <summary>
            Gets a value indicating whether this method assigns an <i>instance</i> field of its parent type
            </summary>
      <remarks>
        <i>true</i> can be returned also for a constructor or a class constructor method.<br /><i>true</i> is returned for a static method or a class constructor that modifies the state of an object passed by reference.<br /><i>true</i> is returned for an instance method of a type <i>T</i> that modifies an instance of <i>T</i> that is not the one referenced by the <i>this</i> reference.<br />
            Methods that <i>ChangesObjectState</i> complexify the program because they break type immutability (see <see cref="T:NDepend.CodeModel.IType" />.<see cref="P:NDepend.CodeModel.IType.IsImmutable" />).<br /></remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.ChangesTypeState">
      <summary>
            Gets a value indicating whether this method assigns a <i>static</i> field of its parent type.
            </summary>
      <remarks>
        <i>true</i> can be returned also for a constructor or a class constructor method.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.ReadsMutableTypeState">
      <summary>
            Gets a value indicating whether this method reads a <i>static</i> field with a <i>false</i> value for <see cref="T:NDepend.CodeModel.IField" />.<see cref="P:NDepend.CodeModel.IField.IsImmutable" /></summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.ReadsMutableObjectState">
      <summary>
            Gets a value indicating whether this method reads an <i>instance</i> field with a <i>false</i> value for <see cref="T:NDepend.CodeModel.IField" />.<see cref="P:NDepend.CodeModel.IField.IsImmutable" /></summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.ReadsImmutableTypeState">
      <summary>
            Gets a value indicating whether this method reads a <i>static</i> field with a <i>true</i> value for <see cref="T:NDepend.CodeModel.IField" />.<see cref="P:NDepend.CodeModel.IField.IsImmutable" /></summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.ReadsImmutableObjectState">
      <summary>
            Gets a value indicating whether this method reads an <i>instance</i> field with a <i>true</i> value for <see cref="T:NDepend.CodeModel.IField" />.<see cref="P:NDepend.CodeModel.IField.IsImmutable" /></summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.CyclomaticComplexity">
      <summary>
            Gets a numeric nullable value measuring this method body complexity computed from source code.
            </summary>
      <remarks>
        <i>
          <u>Cyclomatic Complexity code metric description:</u>
        </i>
        <br />
            The Cyclomatic Complexity (CC) is a popular procedural software metric equal to the number of decisions that can be taken in a procedure. <br />
            Concretely, in C# the CC of a method is 1 + {the number of following expressions found in the body of the method}:<br /><br />
            if | while | for | foreach | case | default | continue | goto | &amp;&amp; | || | catch | ternary operator ?: | ??<br /><br />
            Following expressions are not counted for CC computation:<br /><br />
            else | do | switch | try | using | throw | finally | return | object creation | method call | field access<br /><br />
            Notice that the CC of a lambda method or an anonymous method is not counted when computing the CC of its outer method.<br /><br /><i><u>Recommendations:</u></i><br />
            Methods where CC is higher than 15 are hard to understand and maintain. Methods where CC is higher than 30 are extremely complex and should be split in smaller methods (except if they are automatically generated by a tool).<br /></remarks>
      <returns>
        <i>null</i> if this method is declared in a third-party assembly.<br /><i>null</i> if this method is abstract or is a default constructor.<br /><i>null</i> if the PDB file of this method parent's assembly, hasen't been found.<br /><i>null</i> if the source code file path referenced from the PDB file cannot be found.<br /><i>null</i> if the source code of this method is written with a programming language different than C#.<br />
            Otherwise returns this method body complexity computed from source code.<br />
            More information on this can be found at: <a href="http://www.ndepend.com/Doc_CI_Inputs.aspx" target="_blank">Understanding NDepend Analysis Inputs</a><br />
            If source code CC is not available for a non-abstract method, the code metric <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.ILCyclomaticComplexity" /> can be used instead.
            </returns>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.ILCyclomaticComplexity">
      <summary>
            Gets a numeric nullable value measuring this method body complexity computed from IL code.
            </summary>
      <remarks>
        <i>
          <u>Methods IL Cyclomatic Complexity code metric description:</u>
        </i>
        <br />
            The <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.CyclomaticComplexity" /> (CC) metric is language dependent. Thus, NDepend provides the metric <i>ILCyclomaticComplexity</i> (ILCC) which is language independent because it is computed from IL as:<br />
            1 + {the number of different offsets targeted by a jump/branch IL instruction}. <br />
            Experience shows that ILCC is a bit more larger than the source code CC. Indeed, a C# <i>if</i> expression yields one IL jump. A C# <i>for</i> loop yields two different offsets targeted by a branch IL instruction while a <i>foreach</i> C# loop yields three.<br /></remarks>
      <returns>
        <i>null</i> if this method is declared in a third-party assembly.<br /><i>null</i> if this method is abstract or is a default constructor.<br />
            Otherwise returns this method body complexity computed from IL code.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.ILNestingDepth">
      <summary>
            Gets a numeric nullable value measuring this method body maximum nesting scopes depth.
            </summary>
      <remarks>
        <i>
          <u>Methods IL Nesting Depth code metric description:</u>
        </i>
        <br />
            The metric Nesting Depth for a method is the maximum number of encapsulated scopes inside the body of the method. The metric <i>IL Nesting Depth</i> is computed from the IL code. Values computed are similar to what we would expect by computing them from the C# or VB.NET source code.<br />
            A testing condition with <i>N</i> conditions, such as <i>if( i &gt; 9 &amp;&amp; i &lt; 12)</i>, is considered as <i>N</i> scopes because it is possible to decompose such conditions into <i>N</i> atomic conditions.<br />
            When a method has a large number of case statements corresponding to a switch, the C# and VB.NET compiler generally produce optimizations while generating the IL. In such case, the <i>IL Nesting Depth</i> corresponding value might be slightly higher to what you would expect.<br /><br /><i><u>Recommendations:</u></i><br />
            Methods with a <i>IL Nesting Depth</i> value higher than 4 are hard to understand and maintain. Methods with a <i>IL Nesting Depth</i> value higher than 8 are extremely complex and should be split in smaller methods (except if they are automatically generated by a tool).<br /><br /></remarks>
      <returns>
        <i>null</i> if this method is declared in a third-party assembly.<br /><i>null</i> if this method is abstract.<br />
            Otherwise returns this method body maximum nesting scopes depth.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.NbOverloads">
      <summary>
            Gets the number of overloads of this method or this constructor. Gets 1 if this method is not overloaded. Gets null if this method is declared in a third-party assembly.
            </summary>
      <remarks>
        <i>
          <u>Recommendations:</u>
        </i>
        <br />
            Methods where <i>NbOverloads</i> is higher than 6 might be a problem to maintain and provoke higher coupling than necessary.<br />
            This might also reveal a potential misused of the C# and VB.NET language that supports object initialization since versions C#v3 and VB9. This language feature helps reducing the number of constructors of a class.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.NbParameters">
      <summary>
            Gets the number of parameters of a method. <i>ref</i> and <i>out</i> parameters are also counted. The <i>this</i> reference passed to instance methods in IL is not counted as a parameter.
            </summary>
      <remarks>
        <i>
          <u>Recommendations:</u>
        </i>
        <br />
            Methods where <i>NbParameters</i> is higher than 5 might be painful to call and might degrade performance. You should prefer using additional properties/fields to the declaring type to handle numerous states.<br />
            Another alternative is to provide a class or structure dedicated to handle arguments passing. For example see the class <i>System.Diagnostics.ProcessStartInfo</i> and the method <i>System.Diagnostics.Process.Start(ProcessStartInfo)</i>.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.NbVariables">
      <summary>
            Gets the number of variables declared in the body of this method. Gets null if this methods is abstract or if it is declared in a third-party assembly.
            </summary>
      <remarks>
        <i>
          <u>Recommendations:</u>
        </i>
        <br />
            Methods where <i>NbVariables</i> is higher than 8 are hard to understand and maintain.<br />
            Methods where <i>NbVariables</i> is higher than 15 are extremely complex and should be split in smaller methods (except if they are automatically generated by a tool).
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.NbMethodsCalled">
      <summary>
            Gets the number of methods this method is calling. Gets null if this method is declared in a third-party assembly.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.NbMethodsCallingMe">
      <summary>
            Gets the number of methods that call this method.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.Rank">
      <summary>
            Gets a numeric nullable value assessing this method rank, computed by the original <a href="http://www.sirgroane.net/google-page-rank/" target="_blank">Google Parge Rank</a> algorithm.
            </summary>
      <remarks>
            A homothety of center 0.15 is applied to make it so that the average of all application methods.<i>Rank</i> is 1.<br /><br /><i><u>Recommendations:</u></i><br />
            Methods with high rank should be more carefully tested because bugs in such methods will likely be more catastrophic.<br /><br /></remarks>
      <returns>
        <i>null</i> if this method is declared in a third-party assembly.<br />
            Otherwise returns this method <see cref="P:NDepend.CodeModel.IMethod.Rank" /> numeric value.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage">
      <summary>
            Gets a numeric nullable value measuring the percentage of branch coverage by tests for this method.
            </summary>
      <remarks>
            Branch coverage is a more accurate measure of code coverage than <see cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" /> because it compensates for method complexity.<br />
            Since branch coverage is generated from the underlying opcodes, it often does not map cleanly to source code.<br />
            This means that it might be difficult to take branch coverage values and determine how to write tests that will improve coverage.<br /><br /><i><u>Availability:</u></i><br />
            Branch coverage is only available if your coverage data are imported from <a href="http://www.ncover.com/" target="_blank">NCover</a> coverage files and if the metric <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" /> is available for this method.
            </remarks>
    </member>
    <member name="T:NDepend.CodeModel.INamespace">
      <summary>
            Represents a namespace declared in an application assembly, or declared in a third-party assembly and used by the application code.
            </summary>
      <remarks>
            If <i>N</i> assemblies declare the same namespace, there are <i>N</i><see cref="T:NDepend.CodeModel.INamespace" /> objects with a common <see cref="P:NDepend.CodeModel.ICodeElement.Name" /> value, one object for each assembly that declares the namespace.<br /></remarks>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.ParentAssembly">
      <summary>
            Gets the parent assembly of this namespace.
            </summary>
      <remarks>
            This property getter has a constant time complexity.
            </remarks>
      <getter>
        <ensures description="returned assembly object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.ChildTypes">
      <summary>
            Gets a sequence of types declared in this namespace. If this namespace is declared in a third-party assembly, gets only types used by the application.
            </summary>
      <remarks>
            The result include classes, structures, interfaces, enumerations and delegates classes.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.INamespace.ChildTypes" />.Count)</i> time complexity.
            </remarks>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.ChildMethods">
      <summary>
            Gets a sequence of methods declared in this namespace. If this namespace is declared in a third-party assembly, gets only methods used by the application.
            </summary>
      <remarks>
            The result includes methods, constructors, class constructors, property getter and setters, event adders and removers.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.INamespace.ChildMethods" />.Count)</i> time complexity.
            </remarks>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.ChildFields">
      <summary>
            Gets a sequence of fields declared in this namespace. If this namespace is declared in a third-party assembly, gets only fields used by the application.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.INamespace.ChildFields" />.Count)</i> time complexity.
            </remarks>
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.ChildNamespaces">
      <summary>
            Gets a sequence of child namespaces of this namespace. For example child namespaces of the namespace <i>AA.BB</i> could be <i>AA.BB.CC</i> and <i>AA.BB.CC.DD</i>.
            </summary>
      <remarks>
            The anonymous namespace doesn't have any child namespace.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.INamespace.ParentAssembly" />.<see cref="P:NDepend.CodeModel.INamespace.ChildNamespaces" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.INamespace.DirectChildNamespaces" />
      <seealso cref="P:NDepend.CodeModel.INamespace.ParentNamespaces" />
      <seealso cref="P:NDepend.CodeModel.INamespace.ParentNamespace" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.DirectChildNamespaces">
      <summary>
            Gets a sequence of direct child namespaces of this namespace. For example child namespaces of the namespace <i>AA.BB</i> could be <i>AA.BB.CC</i> but not <i>AA.BB.CC.DD</i>.
            </summary>
      <remarks>
            The anonymous namespace doesn't have any direct child namespace.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.INamespace.ParentAssembly" />.<see cref="P:NDepend.CodeModel.INamespace.ChildNamespaces" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.INamespace.ChildNamespaces" />
      <seealso cref="P:NDepend.CodeModel.INamespace.ParentNamespaces" />
      <seealso cref="P:NDepend.CodeModel.INamespace.ParentNamespace" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.ParentNamespaces">
      <summary>
            Gets a sequence of parent namespaces of this namespace. For example parent namespaces of the namespace <i>AA.BB.CC</i> could be <i>AA.BB</i> and <i>AA</i>.
            </summary>
      <remarks>
            The anonymous namespace doesn't have any parent namespace.<br />
            If the namespace <i>AA.BB</i> doesn't contain any type, it is not shown as a parent namespace of <i>AA.BB.CC</i>. Indeed, if a namespace doesn't contain any type, the NDepend code model doesn't contain an associated <i>INamespace</i> object.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.INamespace.ParentAssembly" />.<see cref="P:NDepend.CodeModel.INamespace.ChildNamespaces" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.INamespace.ChildNamespaces" />
      <seealso cref="P:NDepend.CodeModel.INamespace.DirectChildNamespaces" />
      <seealso cref="P:NDepend.CodeModel.INamespace.ParentNamespace" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.ParentNamespace">
      <summary>
            Gets the parent namespaces of this namespace. Gets <i>null</i> if no parent namespace is found. For example the parent namespace of the namespace <i>AA.BB.CC</i> could be <i>AA.BB</i> but not <i>AA</i>.
            </summary>
      <remarks>
            The anonymous namespace doesn't have any parent namespace.<br />
            If the namespace <i>AA.BB</i> doesn't contain any type, it is not shown as a parent namespace of <i>AA.BB.CC</i>. Indeed, if a namespace doesn't contain any type, the NDepend code model doesn't contain an associated <i>INamespace</i> object. In such case <i>AA</i> is deemed as being the direct parent namespace of <i>AA.BB.CC</i>.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.INamespace.ParentAssembly" />.<see cref="P:NDepend.CodeModel.INamespace.ChildNamespaces" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.INamespace.ChildNamespaces" />
      <seealso cref="P:NDepend.CodeModel.INamespace.DirectChildNamespaces" />
      <seealso cref="P:NDepend.CodeModel.INamespace.ParentNamespaces" />
    </member>
    <member name="P:NDepend.CodeModel.INamespace.ContainsTypeDependencyCycle">
      <summary>
            Gets a value indicating whether this namespace contains a dependency cycle between its <see cref="P:NDepend.CodeModel.INamespace.ChildTypes" />. Gets <i>null</i> if this namespace is declared in a third-party assembly.
            </summary>
      <remarks>
            The result of this property getter is lazy computed.<br /> 
            The first time it is called it has a <i>O(this.<see cref="P:NDepend.CodeModel.INamespace.ChildTypes" />.Count ^2)</i> time complexity.<br />
            Further calls result in a constant time complexity.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.NamespacesUsed">
      <summary>
            Gets a sequence of namespaces that this namespace is using. If this namespace is declared in a third-party assembly, gets an empty sequence.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.INamespace.NamespacesUsed" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.INamespace.NamespacesUsingMe" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.NamespacesUsingMe">
      <summary>
            Gets a sequence of namespaces that are using this namespace.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.INamespace.NamespacesUsingMe" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.INamespace.NamespacesUsed" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.IsPublic">
      <summary>
            Gets a value indicating whether this namespace contains at least one public type.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.IsInternal">
      <summary>
            Gets a value indicating whether this namespace contains only internal types.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.CouldBeInternal">
      <summary>
            Gets a value indicating whether this namespace has at least one child public type, but is not used by any namespace declared in another assembly.
            </summary>
      <remarks>
            A public code element can be declared as <i>internal</i> if it is not used outside of the assembly it is declared in.<br />
            When analyzing a framework, many of public members will be considered as <see cref="P:NDepend.CodeModel.INamespace.CouldBeInternal" /> because there is no analyzed client code using them.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.NbMethods">
      <summary>
            Gets the number of methods declared in types of this namespace. Gets null if this namespace is declared in a third-party assembly.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.NbFields">
      <summary>
            Gets the number of fields declared in types of this namespace. Gets null if this namespace is declared in a third-party assembly.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.NbTypes">
      <summary>
            Gets the number of types declared in this namespace. Gets null if this namespace is declared in a third-party assembly.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.NbNamespacesUsed">
      <summary>
            Gets the number of namespaces this namespace is using. Gets null if this namespace is declared in a third-party assembly.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.INamespace.NbNamespacesUsingMe">
      <summary>
            Gets the number of namespaces that use this namespace.
            </summary>
    </member>
    <member name="T:NDepend.CodeModel.ISourceFile">
      <summary>
            Represents a source file of the analyzed application.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.ISourceFile.FilePath">
      <summary>
            Gets this absolute source file path object.
            </summary>
      <remarks>
            This property cannot be used in CQLinq context because <see cref="T:NDepend.Path.IAbsoluteFilePath" /> is not supported by CQLinq.
            </remarks>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned path object is not empty" csharp="!result.IsEmpty" vb="Not result.IsEmpty">!result.IsEmpty</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ISourceFile.FilePathString">
      <summary>
            Gets a string that contains this absolute source file path, like <i>"C:\Dir\FileName.cs"</i>.
            </summary>
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned string is not empty" csharp="result.Length &gt; 0" vb="result.Length &gt; 0">result.Length &gt; 0</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ISourceFile.DirectoryPath">
      <summary>
            Gets a string that contains this absolute source file's parent directory path, like <i>"C:\Dir"</i> for the source file <i>"C:\Dir\FileName.cs"</i>.
            </summary>
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned string is not empty" csharp="result.Length &gt; 0" vb="result.Length &gt; 0">result.Length &gt; 0</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ISourceFile.FileName">
      <summary>
            Gets a string that contains this source file name, like <i>"FileName.cs"</i> for the source file <i>"C:\Dir\FileName.cs"</i>.
            </summary>
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned string is not empty" csharp="result.Length &gt; 0" vb="result.Length &gt; 0">result.Length &gt; 0</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ISourceFile.FileNameWithoutExtension">
      <summary>
            Gets a string that contains this source file name without extension, like <i>"FileName"</i> for the source file <i>"C:\Dir\FileName.cs"</i>.
            </summary>
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned string is not empty" csharp="result.Length &gt; 0" vb="result.Length &gt; 0">result.Length &gt; 0</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ISourceFile.FileNameExtension">
      <summary>
            Gets a string that contains this source file name extension, like <i>".cs"</i> for the source file <i>"C:\Dir\FileName.cs"</i>.
            </summary>
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ISourceFile.Language">
      <summary>
            Gets this source file language, infered from the source file extension.
            </summary>
    </member>
    <member name="T:NDepend.CodeModel.ISourceFileLine">
      <summary>
            Represents a 1-based line number in a source file of the analyzed application.
            </summary>
      <remarks>
            This interface is useful to represents a source file declaration of a code element, <see cref="T:NDepend.CodeModel.ICodeElement" />.<see cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" />.<br />
            Such a declaration can be opened with the extension method <see cref="T:NDepend.CodeModel.ExtensionMethodsTooling" />.<see cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryOpenSource(NDepend.CodeModel.ICodeElement)" />.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.ISourceFileLine.SourceFile">
      <summary>
            Gets the source file object.
            </summary>
      <getter>
        <ensures description="returned source file object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.ISourceFileLine.Line">
      <summary>
            Gets the 1-based line number in the source file.
            </summary>
    </member>
    <member name="T:NDepend.CodeModel.IType">
      <summary>
            Represents a type declared in an application assembly, or declared in a third-party assembly and used by the application code.
            </summary>
    </member>
    <member name="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)">
      <summary>Returns a value indicating whether this type derives <i> directly or indirectly</i> from <paramref name="baseClass" />.</summary>
      <param name="baseClass">The base class to derive from.</param>
      <remarks>
            For any type <i>T</i>, <i>T.DeriveFrom(T)</i> returns false.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.DepthOfInheritance" />)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
      <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
      <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
      <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <requires description="the baseClass object must not null" csharp="baseClass != null" vb="baseClass &lt;&gt; Nothing">baseClass != null</requires>
    </member>
    <member name="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)">
      <summary>Returns a nullable numeric value equals to this type depth of inheritance, relative to <paramref name="baseClass" />. Returns <i>null</i> if this type doesn't derive from <paramref name="baseClass" />.</summary>
      <param name="baseClass">The base class.</param>
      <remarks>
            For any type <i>T</i>, <i>T.DepthOfDeriveFrom(T)</i> returns 0.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.DepthOfInheritance" />)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
      <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
      <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
      <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
    </member>
    <member name="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)">
      <summary>Returns a value indicating whether this type implements <paramref name="interface" />.</summary>
      <param name="interface">The interface to implement.</param>
      <remarks>
            This method has a constant time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.InterfacesImplemented" />
      <seealso cref="P:NDepend.CodeModel.IType.TypesThatImplementMe" />
      <seealso cref="P:NDepend.CodeModel.IType.NbInterfacesImplemented" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplement(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAll(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.Implement(NDepend.CodeModel.IType,System.String)" />
      <requires description="the @interface object must not null" csharp="interface != null" vb="interface &lt;&gt; Nothing">interface != null</requires>
    </member>
    <member name="P:NDepend.CodeModel.IType.TypesUsed">
      <summary>
            Gets a sequence of types that this type is using. If this type is declared in a third-party assembly, gets an empty sequence.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.TypesUsed" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.TypesUsingMe" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.TypesUsingMe">
      <summary>
            Gets a sequence of types that are using this type.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.TypesUsingMe" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.TypesUsed" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.ContainsMethodDependencyCycle">
      <summary>
            Gets a value indicating whether this type contains a dependency cycle between its <see cref="P:NDepend.CodeModel.IType.MethodsAndContructors" />. Gets <i>null</i> if this type is declared in a third-party assembly.
            </summary>
      <remarks>
            The result of this property getter is lazy computed.<br /> 
            The first time it is called it has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.MethodsAndContructors" />.Count ^2)</i> time complexity.<br />
            Further calls result in a constant time complexity.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IType.DirectNestedTypes">
      <summary>
            Gets a sequence of types nested in this type. The sequence doesn't contain types nested in types nested in this type.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.TypesUsed" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.NestedTypes" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.NestedTypes">
      <summary>
            Gets a sequence of types nested in this type, or nested in a type nested in this type (recursive).
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.TypesUsed" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.DirectNestedTypes" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.Constructors">
      <summary>
            Gets a sequence of constructors of this type. The sequence doesn't contain class constructor.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.MethodsAndContructors" />
      <seealso cref="P:NDepend.CodeModel.IType.InstanceMethodsAndContructors" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.Methods">
      <summary>
            Gets a sequence of methods of this type. The sequence doesn't contain constructors nor class constructors but contain properties getters and setters, and events adders and removers.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.InstanceMethods" />
      <seealso cref="P:NDepend.CodeModel.IType.StaticMethods" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.MethodsAndContructors">
      <summary>
            Gets a sequence of methods and constructors of this type. The sequence also contains properties getters and setters, and events adders and removers.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.InstanceMethodsAndContructors" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.Fields">
      <summary>
            Gets a sequence of fields of this type.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.InstanceFields" />
      <seealso cref="P:NDepend.CodeModel.IType.StaticFields" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.Members">
      <summary>
            Gets a sequence of members of this type. The sequence contains constructors, methods and fields, but doesn't contain nested types. See <see cref="P:NDepend.CodeModel.IType.DirectNestedTypes" /> and <see cref="P:NDepend.CodeModel.IType.NestedTypes" />.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.InstanceMembers" />
      <seealso cref="P:NDepend.CodeModel.IType.StaticMembers" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.ClassConstructor">
      <summary>
            Gets the <see cref="T:NDepend.CodeModel.IMethod" /> object representing this class constructor, if any, otherwise gets <i>null</i>.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IType.StaticMethods">
      <summary>
            Gets a sequence of static methods of this type. The sequence doesn't contain the class constructor (if any) but contain static properties getters and setters, and static events adders and removers.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.Methods" />
      <seealso cref="P:NDepend.CodeModel.IType.InstanceMethods" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.StaticFields">
      <summary>
            Gets a sequence of static fields of this type.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.Fields" />
      <seealso cref="P:NDepend.CodeModel.IType.InstanceFields" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.StaticMembers">
      <summary>
            Gets a sequence of static members of this type. The sequence contains the class constructor (if any), static methods and fields, but doesn't contain nested types. See <see cref="P:NDepend.CodeModel.IType.DirectNestedTypes" /> and <see cref="P:NDepend.CodeModel.IType.NestedTypes" />.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.Members" />
      <seealso cref="P:NDepend.CodeModel.IType.InstanceMembers" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.InstanceMethods">
      <summary>
            Gets a sequence of non-static methods of this type. The sequence doesn't contain non-static constructors but contain non-static properties getters and setters, and non-static events adders and removers.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.Methods" />
      <seealso cref="P:NDepend.CodeModel.IType.StaticMethods" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.InstanceMethodsAndContructors">
      <summary>
            Gets a sequence of non-static methods and constructors of this type. The sequence also contains non-static properties getters and setters, and non-static events adders and removers.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.MethodsAndContructors" />
      <seealso cref="P:NDepend.CodeModel.IType.ClassConstructor" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.InstanceFields">
      <summary>
            Gets a sequence of non-static fields of this type.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.Fields" />
      <seealso cref="P:NDepend.CodeModel.IType.StaticFields" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.InstanceMembers">
      <summary>
            Gets a sequence of non-static members of this type. The sequence contains non-static constructors, non-static methods and non-static fields, but doesn't contain nested types. See <see cref="P:NDepend.CodeModel.IType.DirectNestedTypes" /> and <see cref="P:NDepend.CodeModel.IType.NestedTypes" />.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.Members" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.Members" />
      <seealso cref="P:NDepend.CodeModel.IType.StaticMembers" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.BaseClass">
      <summary>
            Gets the <see cref="T:NDepend.CodeModel.IType" /> object representing the base class of this class, if any, otherwise gets <i>null</i>.
            </summary>
      <remarks>
            Interfaces or the class <i>System.Object</i> don't have a base class.<br />
            This property getter has a constant time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
      <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
      <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
    </member>
    <member name="P:NDepend.CodeModel.IType.BaseClasses">
      <summary>
            Gets a sequence of all base classes of this class. The sequence is empty if this type doesn't have any base class.
            </summary>
      <remarks>
            Interfaces or the class <i>System.Object</i> don't have any base class.<br />
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.DepthOfInheritance" />)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
      <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
      <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <getter>
        <ensures description="returned sequence is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeModel.IType.DirectDerivedTypes">
      <summary>
            Gets a sequence of types that derives directly from this type. The sequence is empty if this type has no derived type.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
      <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
      <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.DerivedTypes" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
    </member>
    <member name="P:NDepend.CodeModel.IType.DerivedTypes">
      <summary>
            Gets a sequence of all types derived from this type. The sequence is empty if this type has no derived type.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.DerivedTypes" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.IType.BaseClass" />
      <seealso cref="P:NDepend.CodeModel.IType.BaseClasses" />
      <seealso cref="M:NDepend.CodeModel.IType.DeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.IType.DepthOfDeriveFrom(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.DirectDerivedTypes" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatDirectlyDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFrom(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.DepthOfDeriveFromAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />
    </member>
    <member name="P:NDepend.CodeModel.IType.InterfacesImplemented">
      <summary>
            Gets a sequence of interfaces implemented by this type. The sequence returned is empty if this type doesn't implement any interface.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<see cref="P:NDepend.CodeModel.IType.InterfacesImplemented" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.TypesThatImplementMe" />
      <seealso cref="P:NDepend.CodeModel.IType.NbInterfacesImplemented" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplement(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAll(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.Implement(NDepend.CodeModel.IType,System.String)" />
    </member>
    <member name="P:NDepend.CodeModel.IType.TypesThatImplementMe">
      <summary>
            If this type is an interface, gets a sequence of types implementing this interface, otherwise gets an empty sequence.
            </summary>
      <remarks>
            This property getter has a <i>O(this.<seealso cref="P:NDepend.CodeModel.IType.TypesUsingMe" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="M:NDepend.CodeModel.IType.Implement(NDepend.CodeModel.IType)" />
      <seealso cref="P:NDepend.CodeModel.IType.InterfacesImplemented" />
      <seealso cref="P:NDepend.CodeModel.IType.NbInterfacesImplemented" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplement(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},NDepend.CodeModel.IType)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAll(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsSequenceUsage.ThatImplementAny(System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType},System.Collections.Generic.IEnumerable{NDepend.CodeModel.IType})" />
      <seealso cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.Implement(NDepend.CodeModel.IType,System.String)" />
    </member>
    <member name="P:NDepend.CodeModel.IType.IsGeneric">
      <summary>
            Gets a value indicating whether this type is a generic type.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.IsAbstract">
      <summary>
            Gets a value indicating whether this type is an abstract class or an interface.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.IsClass">
      <summary>
            Gets a value indicating whether this type is a class.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.IsStructure">
      <summary>
            Gets a value indicating whether this type is a structure.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.IsEnumeration">
      <summary>
            Gets a value indicating whether this type is an enumeration.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.IsInterface">
      <summary>
            Gets a value indicating whether this type is an interface.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.IsDelegate">
      <summary>
            Gets a value indicating whether this type is a delegate class, deriving from <i>System.MulticastDelegate</i>.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.IsExceptionClass">
      <summary>
            Gets a value indicating whether this type is an exception class, deriving from <i>System.Exception</i>.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.IsAttributeClass">
      <summary>
            Gets a value indicating whether this type is an attribute class, deriving from <i>System.Attribute</i>.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.IsSealed">
      <summary>
            Gets a value indicating whether this class is declared with the <i>sealed</i> keyword in C#, <i>NotInheritable</i> keyword in VB.NET.
            </summary>
      <remarks>
            Structures and necessarily marked as sealed.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IType.IsNested">
      <summary>
            Gets a value indicating whether this type is nested in a parent type.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.IsSerializable">
      <summary>
            Gets a value indicating whether this type is serializable.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.IsUsingBoxing">
      <summary>
            Gets a value indicating whether this type contains at least a method with an IL body that uses the <b>box</b> IL instruction.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.IsUsingUnboxing">
      <summary>
            Gets a value indicating whether this type contains at least a method with an IL body that uses the <b>unbox</b> IL instruction.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.IsUsingPointers">
      <summary>
            Gets a value indicating whether this type contains at least a method that contains <i>unsafe code</i> that is using some pointers.
            </summary>
      <remarks>
            VB.NET does not support <i>unsafe code</i> but C# does.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IType.IsUsingPinning">
      <summary>
            Gets a value indicating whether this type contains at least a method that contains <i>unsafe code</i> that is using <i>pinning</i>.
            </summary>
      <remarks>
            VB.NET does not support <i>unsafe code</i> but C# does.<br />
            In C#, <i>pinning</i> is generated through the <i>fixed</i> keyword.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IType.HasFinalizer">
      <summary>
            Gets a value indicating whether this type contains a finalizer method.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.IsImmutable">
      <summary>
            Gets a value indicating whether this type is <i>immutable</i>. A type is considered as <i>immutable</i> if its instance fields cannot be modified once an instance has been built by a constructor.
            </summary>
      <remarks>
        <ul>
          <li>A stateless type (i.e a type without any instance field) is considered as immutable.</li>
          <li>A type with at least one non-private instance field is considered as mutable, because such a field can be eventually modified outside the type.</li>
          <li>A class that derives directly or indirectly from a mutable type is considered as mutable.</li>
          <li>Enumerations, static types, types defined in third-party assemblies and delegate classes are never considered as immutable. Although these types might match the definition of immutability, considering them as immutable would introduce noise when searching for immutable types.</li>
          <li>Particularly, classes that derive directly or indirectly from a class defined in a third-party assembly that is not the <i>System.Object class</i>, is never considered as immutable.</li>
          <li>Using the <i>readonly</i> C# keyword (<i>ReadOnly</i> in VB.NET) on your own instance field is a good way to achieve immutability.</li>
          <li>Notice that if a type <i>T</i> has some instance fields that are of reference type, the object pointed by such a reference might be modified without breaking the immutability of <i>T</i>. We are talking of <b>shallow immutability</b>.</li>
        </ul>
            It is still possible to break immutability by using the <i>ref</i> C# keyword (<i>ByRef</i> in VB.NET) to allow a tier method to modify the state of an instance field.<br />
            As .NET framework designers considered that the immutability of the class <i>System.String</i> can be broken using advanced means such as reflection or unsafe code, you should consider that using the C# keyword <i>ref</i> or reflection or unsafe code are <i>advanced</i> means to break immutability of your own types.<br />
            Immutable types are especially useful when you have to deal with multi-threading application. Indeed, accesses to instances of immutable types don’t need to be synchronized because such objects can’t be modified; hence all accesses are read-only accesses.<br />
            To enforce your classes and structures immutability, see the attribute class <see cref="T:NDepend.Attributes.ImmutableAttribute" />.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IType.CyclomaticComplexity">
      <summary>
            Gets a numeric nullable value measuring this type child methods additive source code complexity.
            </summary>
      <remarks>
        <i>
          <u>Types Cyclomatic Complexity code metric description:</u>
        </i>
        <br />
            Adapted to the Object-Oriented world, the <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.CyclomaticComplexity" /> (CC) metric is also defined for classes and structures as the sum of its methods CC.<br /><br /><i><u>Availability:</u></i><br />
            A non-null numeric value is returned for types with methods where<br /></remarks>
      <returns>
        <i>null</i> if this type is declared in a third-party assembly.<br /><i>null</i> if this type has no method where <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.CyclomaticComplexity" /> is available.<br /><i>null</i> if the PDB file of this type parent's assembly, hasen't been found.<br /><i>null</i> if the source code file path referenced from the PDB file cannot be found.<br /><i>null</i> if the source code of this type is written with a programming language different than C#.<br />
            Otherwise returns this type child methods additive source code complexity.<br />
            More information on this can be found at: <a href="http://www.ndepend.com/Doc_CI_Inputs.aspx" target="_blank">Understanding NDepend Analysis Inputs</a></returns>
    </member>
    <member name="P:NDepend.CodeModel.IType.ILCyclomaticComplexity">
      <summary>
            Gets a numeric nullable value measuring this type child methods additive IL code complexity.
            </summary>
      <remarks>
        <i>
          <u>Types IL Cyclomatic Complexity code metric description:</u>
        </i>
        <br />
            Adapted to the Object-Oriented world, the <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.ILCyclomaticComplexity" /> (ILCC) metric is also defined for classes and structures as the sum of its methods ILCC.<br /><br /><i><u>Availability:</u></i><br />
            A non-null numeric value is returned for types with methods where <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.ILCyclomaticComplexity" /> is available.<br /></remarks>
      <returns>
        <i>null</i> if this type is declared in a third-party assembly.<br /><i>null</i> if this type has no method with <see cref="T:NDepend.CodeModel.IMethod" />.<see cref="P:NDepend.CodeModel.IMethod.ILCyclomaticComplexity" /> available.<br />
            Otherwise returns this type child methods additive IL code complexity.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IType.NbMethods">
      <summary>
            Gets the number of methods of this type. Gets null if this type is declared in a third-party assembly.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.NbFields">
      <summary>
            Gets the number of fields of this type. Gets null if this type is declared in a third-party assembly.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.SizeOfInst">
      <summary>
            Gets a numeric nullable value measuring this type's instance object footprint, measured in bytes.
            </summary>
      <remarks>
        <i>
          <u>Size of Instance code metric description:</u>
        </i>
        <br />
        <i>SizeOfInst</i> for a class or a structure is defined as the sum of <see cref="T:NDepend.CodeModel.IField" />.<see cref="P:NDepend.CodeModel.IField.SizeOfInst" /> values of its fields plus the size of instances of its base class.<br /><i>SizeOfInst</i> for a generic type might be erroneous because we cannot statically know the footprint of parameter types (except when they have the <i>class</i> constraint).<br /><i>SizeOfInst</i> for an enumeration is equal to the size of instances of the underlying numeric primitive type. It is computed from the enumeration's <i>value__</i> instance field (all enumerations have such a field when compiled in IL).<br /><i>SizeOfInst</i> for a static class or an interface is null.<br /><br /><i><u>Recommendations:</u></i><br />
            Types where <i>SizeOfInst</i> is higher than 64 might degrade performance (depending on the number of instances created at runtime) and might be hard to maintain.<br />
            However this is not a rule since sometime there are no alternatives. For example, the <i>SizeOfInst</i> value for the <i>System.Net.NetworkInformation.SystemIcmpV6Statistics</i> .NET framework class is 2064 bytes.<br />
            Non-static and non-generic types where <i>SizeOfInst</i> is equal to 0 indicate stateless types that might eventually be turned into static classes.<br /><br /></remarks>
      <returns>
        <i>null</i> if this type is declared in a third-party assembly.<br /><i>null</i> if this type is static or is an interface.<br />
            Otherwise returns this type <see cref="P:NDepend.CodeModel.IType.SizeOfInst" /> numeric value.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IType.DepthOfInheritance">
      <summary>
            Gets a numeric nullable value measuring this type's depth of inheritance.
            </summary>
      <remarks>
            The depth of inheritance for a class directly deriving from <i>System.Object</i> class is equal to 1.<br />
            The depth of inheritance for a structure is equal to 2 since it derives from <i>System.ValueType</i> that derives from <i>System.Object</i>.<br />
            The depth of inheritance for an enumeration is equal to 3 since it derives from <i>System.Enum</i> that derives from <i>System.ValueType</i> that derives from <i>System.Object</i>.<br /><br /><i><u>Recommendations:</u></i><br />
            Types where <i>DepthOfInheritance</i> is higher or equal than 6 might be hard to maintain. However this is not a rule since sometime your classes might inherit from third-party classes that have a high depth of inheritance.<br />
            For example, the average depth of inheritance for .NET Framework classes that derive from <i>System.Windows.Forms.Control</i> is 5.3.<br /></remarks>
      <returns>
        <i>null</i> if this type is declared in a third-party assembly.<br /><i>null</i> if this type is static or is an interface.<br />
            Otherwise returns this type <see cref="P:NDepend.CodeModel.IType.DepthOfInheritance" /> numeric value.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IType.NbChildren">
      <summary>
            Gets a numeric nullable value counting this class's number of derived classes, or this interface number of implementer types.
            </summary>
      <returns>
        <i>null</i> if this type is declared in a third-party assembly.<br /><i>null</i> if this type is static, is a structure or is an enumeration.<br />
            Otherwise returns this type <see cref="P:NDepend.CodeModel.IType.NbChildren" /> numeric value.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IType.NbInterfacesImplemented">
      <summary>
            Gets a numeric value counting this class's number of implemented interfaces, or this interface number of extended interfaces.
            </summary>
      <remarks>
            For derived class, the sum of interfaces implemented by base class(es) is also counted.
            </remarks>
    </member>
    <member name="P:NDepend.CodeModel.IType.NbTypesUsed">
      <summary>
            Gets the number of types this type is using. Gets null if this type is declared in a third-party assembly.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.NbTypesUsingMe">
      <summary>
            Gets the number of types that use this type.
            </summary>
    </member>
    <member name="P:NDepend.CodeModel.IType.ABT">
      <summary>
            Gets the <i>Association Between Classes</i> for this type, computed as the number of members of others types it directly uses in the body of its child methods.
            </summary>
      <returns>
        <i>null</i> if this type is declared in a third-party assembly.<br />
            Otherwise returns this type <see cref="P:NDepend.CodeModel.IType.ABT" /> numeric value.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IType.Rank">
      <summary>
            Gets a numeric nullable value assessing this type rank, computed by the original <a href="http://www.sirgroane.net/google-page-rank/" target="_blank">Google Parge Rank</a> algorithm.
            </summary>
      <remarks>
            When discovering a legacy application, type ranking naturally sorts application types by an order of importance. Hence this code metric can help focusing on most relevant types first.<br />
            A homothety of center 0.15 is applied to make it so that the average of all application types.<i>Rank</i> is 1.<br /><br /><i><u>Recommendations:</u></i><br />
            Types with high rank should be more carefully tested because bugs in such types will likely be more catastrophic.<br /></remarks>
      <returns>
        <i>null</i> if this type is declared in a third-party assembly.<br />
            Otherwise returns this type <see cref="P:NDepend.CodeModel.IType.Rank" /> numeric value.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IType.LCOM">
      <summary>
            Gets a numeric nullable value assessing the class members cohesion, through the standard <i>Lack of Cohesion Of Methods</i> code metric.
            </summary>
      <remarks>
            The single responsibility principle states that a class should not have more than one reason to change. Such a class is said to be cohesive.<br />
            A high LCOM value generally pinpoints a poorly cohesive class. There are two LCOM metrics.<br /><ul><li>The LCOM takes its values in the range [0-1].</li><li>The LCOM HS defined by <see cref="P:NDepend.CodeModel.IType.LCOMHS" /> (<i>HS</i> stands for <i>Henderson-Sellers</i>) takes its values in the range [0-2]. A LCOM HS value highest than 1 should be considered alarming.</li></ul>
            Here are algorithms used by NDepend to compute LCOM metrics:<br /><ul><li>LCOM = 1 - (sum(MF)/M*F)</li><li>LCOM HS = (M - sum(MF)/F)(M-1)</li></ul>
            Where:<br /><ul><li>M is the number of methods in class (both static and instance methods are counted, it includes also constructors, properties getters/setters, events add/remove methods).</li><li>F is the number of instance fields in the class.</li><li>MF is the number of methods of the class accessing a particular instance field.</li><li>Sum(MF) is the sum of MF over all instance fields of the class.</li></ul>
            The underlying idea behind these formulas can be stated as follow: a class is utterly cohesive if all its methods use all its instance fields, which means that sum(MF)=M*F and then LCOM = 0 and LCOMHS = 0.<br /><br /><i><u>Recommendations:</u></i><br />
            Types where LCOM &gt; 0.8 and NbFields &gt; 10 and NbMethods &gt;10 might be problematic. However, it is difficult to avoid such non-cohesive types. <br />
            Types where LCOMHS &gt; 1.0 and NbFields &gt; 10 and NbMethods &gt;10 should be avoided. Note that this constraint is stronger (hence easier to satisfy) than the constraint types where LCOM &gt; 0.8 and NbFields &gt; 10 and NbMethods &gt;10.<br /></remarks>
      <returns>
        <i>null</i> if this type is declared in a third-party assembly.<br /><i>null</i> if this type is an interface or an enumeration.<br />
            Otherwise returns this type <see cref="P:NDepend.CodeModel.IType.LCOM" /> numeric value.<br /></returns>
    </member>
    <member name="P:NDepend.CodeModel.IType.LCOMHS">
      <summary>
            Gets a numeric nullable value assessing the class members cohesion, through the standard <i>Lack of Cohesion Of Methods Henderson-Sellers</i> code metric.
            </summary>
      <remarks>
            See the <see cref="P:NDepend.CodeModel.IType.LCOM" /> code metric definition for detailled explanations on the <i>Lack of Cohesion Of Methods Henderson-Sellers</i> code metric.<br /></remarks>
      <returns>
        <i>null</i> if this type is declared in a third-party assembly.<br /><i>null</i> if this type is an interface or an enumeration.<br />
            Otherwise returns this type <see cref="P:NDepend.CodeModel.IType.LCOMHS" /> numeric value.<br /></returns>
    </member>
    <member name="T:NDepend.CodeModel.SourceFileLanguage">
      <summary>
            Represents the programming <see cref="P:NDepend.CodeModel.ISourceFile.Language" /> of a <see cref="T:NDepend.CodeModel.ISourceFile" /> object.
            </summary>
    </member>
    <member name="F:NDepend.CodeModel.SourceFileLanguage.Other">
      <summary>Other</summary>
    </member>
    <member name="F:NDepend.CodeModel.SourceFileLanguage.CSharp">
      <summary>CSharp</summary>
    </member>
    <member name="F:NDepend.CodeModel.SourceFileLanguage.VBNet">
      <summary>VBNet</summary>
    </member>
    <member name="F:NDepend.CodeModel.SourceFileLanguage.Cpp">
      <summary>Cpp</summary>
    </member>
    <member name="F:NDepend.CodeModel.SourceFileLanguage.Java">
      <summary>Java</summary>
    </member>
    <member name="F:NDepend.CodeModel.SourceFileLanguage.Xaml">
      <summary>Xaml</summary>
    </member>
    <member name="F:NDepend.CodeModel.SourceFileLanguage.FSharp">
      <summary>FSharp</summary>
    </member>
    <member name="T:NDepend.Reserved.CQLinq.ICQLinqExecutionContext">
      <summary>
            The CQLinq <b>context</b> represents the single input of a CQLinq query execution.<br />
            This interface is reserved for CQLinq implementation usage and is not intended to be used in your code.
            </summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.CodeBase">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.JustMyCode">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.CompareContext">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.UniqueLoop">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate0">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate1">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate2">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate3">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate4">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate5">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate6">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate7">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate8">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate9">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate10">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate11">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate12">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate13">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate14">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate15">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate16">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate17">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate18">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate19">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate20">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate21">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate22">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate23">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate24">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate25">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate26">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate27">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate28">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate29">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate30">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Predicate31">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator0">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator1">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator2">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator3">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator4">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator5">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator6">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator7">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator8">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator9">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator10">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator11">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator12">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator13">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator14">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator15">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator16">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator17">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator18">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator19">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator20">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator21">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator22">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator23">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator24">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator25">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator26">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator27">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator28">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator29">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator30">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="P:NDepend.Reserved.CQLinq.ICQLinqExecutionContext.Evaluator31">
      <summary>This property getter is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="T:NDepend.Reserved.Linq.ObjectHidden">
      <summary>This class is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="T:NDepend.Reserved.Linq.QueryableImpl`1">
      <summary>This class is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="M:NDepend.Reserved.Linq.QueryableImpl`1.#ctor(NDepend.Reserved.Linq.QueryProviderBase)">
      <summary>This constructor is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="M:NDepend.Reserved.Linq.QueryableImpl`1.#ctor(NDepend.Reserved.Linq.QueryProviderBase,System.Linq.Expressions.Expression)">
      <summary>This constructor is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="M:NDepend.Reserved.Linq.QueryableImpl`1.GetEnumerator">
      <summary>This method is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="T:NDepend.Reserved.Linq.UniqueLoopObject">
      <summary>This class is reserved for CQLinq implementation usage and is not intended to be used in your code.</summary>
    </member>
    <member name="T:NDepend.CodeQuery.IController">
      <summary>
            Changes to a hierarchy of code query objects are made through an instance of <see cref="T:NDepend.CodeQuery.IController" />.
            </summary>
      <remarks>
            A <see cref="T:NDepend.CodeQuery.IController" /> object is obtained from the method <see cref="T:NDepend.CodeQuery.ExtensionMethodsQuery" />.<see cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CreateQueriesController(NDepend.CodeQuery.IGroupOfGroups)" />(<see cref="T:NDepend.CodeQuery.IGroupOfGroups" />).<br />
            A <see cref="T:NDepend.CodeQuery.IQuery" />, <see cref="T:NDepend.CodeQuery.IGroup" />, <see cref="T:NDepend.CodeQuery.IGroupOfGroups" /> or <see cref="T:NDepend.CodeQuery.IController" /> object is bound to the thread that created it.<br />
            In other words, a code query object cannot be used from a thread different than the thread that created it, else an InvalidOperationException is thrown.<br />
            This limitation is due to the fact that the hierarchy of code queries object must be immutable from the point of view of any query object.<br />
            However the changes made to the hierarchy of code queries object are centralized in a thread bounded state.<br />
            Doing so, garantees the impossibility of a hierarchy of code queries corrupted state.
            </remarks>
    </member>
    <member name="M:NDepend.CodeQuery.IController.CreateQuery(System.Boolean,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Create a new query object.
            </summary>
      <param name="isActive">The new query activation.</param>
      <param name="queryString">The query string.</param>
      <param name="displayStatInReport">A boolean value that indicates whether the code rule is violated, the code rule matched code elements are listed into the report.</param>
      <param name="displayListInReport">A boolean value that indicates whether the code rule is violated, the code rule matched code elements statistics are shown into the report.</param>
      <param name="displaySelectionViewInReport">A boolean value that indicates whether the code rule is violated, the code rule matched code elements are shown in a treemap picture embedded into the report.</param>
      <param name="isCriticalRule">A boolean value that indicates whether the code rule is critical or not.</param>
      <requires description="queryString must not be null" csharp="queryString != null" vb="queryString &lt;&gt; Nothing">queryString != null</requires>
      <ensures description="returned query object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.IController.CreateGroup(System.String,System.Boolean,System.Boolean,System.Collections.Generic.ICollection{NDepend.CodeQuery.IQuery},System.Collections.Generic.ICollection{NDepend.CodeQuery.IGroup})">
      <summary>
            Creates a new group object.
            </summary>
      <param name="name">The group name.</param>
      <param name="isActive">The group activation.</param>
      <param name="shownInReport">A boolean value that indicates whether all child rules and queries of this group are shown in report. In Queries Explorer panel, such group is highlighted in a orange box.</param>
      <param name="childQueries">A collection of child queries.</param>
      <param name="childGroups">A collection of child groups.</param>
      <requires description="name must not be null" csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires description="name must not be empty" csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
      <requires description="childQueries must not be null" csharp="childQueries != null" vb="childQueries &lt;&gt; Nothing">childQueries != null</requires>
      <requires description="childGroups must not be null" csharp="childGroups != null" vb="childGroups &lt;&gt; Nothing">childGroups != null</requires>
      <ensures description="returned group object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.IController.IsUnderRootParent(NDepend.CodeQuery.IGroupOfGroups,System.String@)">
      <summary>
            Gets a value indicating whether <paramref name="groupOfGroups" /> is under <see cref="T:NDepend.CodeQuery.IController" />.<see cref="P:NDepend.CodeQuery.IController.RootParent" />.
            </summary>
      <param name="groupOfGroups">The group of groups.</param>
      <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
      <remarks>
            Alternatively you can test if <paramref name="groupOfGroups" />.<see name="IQueriesSet.RootParent" /> is equal to this.<see cref="P:NDepend.CodeQuery.IController.RootParent" /></remarks>
      <requires description="group must not be null" csharp="groupOfGroups != null" vb="groupOfGroups &lt;&gt; Nothing">groupOfGroups != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.IsUnderRootParent(NDepend.CodeQuery.IGroup,System.String@)">
      <summary>
            Gets a value indicating whether <paramref name="group" /> is under <see cref="T:NDepend.CodeQuery.IController" />.<see cref="P:NDepend.CodeQuery.IController.RootParent" />.
            </summary>
      <param name="group">The group.</param>
      <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
      <remarks>
            Alternatively you can test if <paramref name="group" />.<see name="IQueriesSet.RootParent" /> is equal to this.<see cref="P:NDepend.CodeQuery.IController.RootParent" /></remarks>
      <requires description="group must not be null" csharp="group != null" vb="group &lt;&gt; Nothing">group != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.IsUnderRootParent(NDepend.CodeQuery.IQuery,System.String@)">
      <summary>
            Gets a value indicating whether <paramref name="query" /> is under <see cref="T:NDepend.CodeQuery.IController" />.<see cref="P:NDepend.CodeQuery.IController.RootParent" />.
            </summary>
      <param name="query">The query.</param>
      <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
      <remarks>
            Alternatively you can test if <paramref name="query" />.<see name="IQuery.RootParent" /> is equal to this.<see cref="P:NDepend.CodeQuery.IController.RootParent" /></remarks>
      <requires description="group must not be null" csharp="query != null" vb="query &lt;&gt; Nothing">query != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.CanChangeGroupName(NDepend.CodeQuery.IGroup,System.String@)">
      <summary>Gets a value indicating whether <paramref name="group" />.<see cref="P:NDepend.CodeQuery.IGroup.Name" /> can be changed.</summary>
      <param name="group">The group on which to change the name.</param>
      <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
      <remarks>If group.<see cref="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode" /> its name cannot be changed.</remarks>
      <requires description="group must not be null" csharp="group != null" vb="group &lt;&gt; Nothing">group != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.CanSetGroupName(NDepend.CodeQuery.IGroup,System.String,System.String@)">
      <summary>Gets a value indicating whether <paramref name="group" /> name can be changed to <paramref name="newName" />.</summary>
      <param name="group">The group on which to change the name.</param>
      <param name="newName">The new name to assign to the group.</param>
      <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
      <remarks>
            An empty <paramref name="newName" /> is not accepted and if another group already has the name <paramref name="newName" />, it is not accepted neither.
            </remarks>
      <requires description="group must not be null" csharp="group != null" vb="group &lt;&gt; Nothing">group != null</requires>
      <requires description="newName must not be null" csharp="newName != null" vb="newName &lt;&gt; Nothing">newName != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.DoChangeGroupName(NDepend.CodeQuery.IGroup,System.String)">
      <summary>Change <paramref name="group" />.<see cref="P:NDepend.CodeQuery.IGroup.Name" /> to <paramref name="newName" />.</summary>
      <param name="group">The group on which to change the name.</param>
      <param name="newName">The new name to assign to the group.</param>
      <exception cref="T:System.ArgumentException">
            Can't perform the group renaming operation on these arguments.<br />
            Please check arguments with the method <see cref="M:NDepend.CodeQuery.IController.CanSetGroupName(NDepend.CodeQuery.IGroup,System.String,System.String@)" /> before calling this method.
            </exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="group must not be null" csharp="group != null" vb="group &lt;&gt; Nothing">group != null</requires>
      <requires description="newName must not be null" csharp="newName != null" vb="newName &lt;&gt; Nothing">newName != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.CanChangeGroupActivation(NDepend.CodeQuery.IGroup,System.String@)">
      <summary>
            Gets a value indicating whether <paramref name="group" />.<see cref="P:NDepend.CodeQuery.IGroup.IsActive" /> can be changed.
            </summary>
      <param name="group">The group on which to change the activation.</param>
      <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
      <remarks>If group.<see cref="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode" /> its activation cannot be changed.</remarks>
      <requires description="group must not be null" csharp="group != null" vb="group &lt;&gt; Nothing">group != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.DoChangeGroupActivation(NDepend.CodeQuery.IGroup,System.Boolean)">
      <summary>Change <paramref name="group" />.<see cref="P:NDepend.CodeQuery.IGroup.IsActive" />  to <paramref name="active" />.</summary>
      <param name="group">The group on which to change the name.</param>
      <param name="active">The new activation boolean state of the group.</param>
      <exception cref="T:System.ArgumentException">
            Can't perform the group activation changing operation on these arguments.<br />
            Please check arguments with the method <see cref="M:NDepend.CodeQuery.IController.CanChangeGroupActivation(NDepend.CodeQuery.IGroup,System.String@)" /> before calling this method.
            </exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="group must not be null" csharp="group != null" vb="group &lt;&gt; Nothing">group != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.CanChangeGroupShownInReport(NDepend.CodeQuery.IGroup,System.String@)">
      <summary>
            Gets a value indicating whether <paramref name="group" />.<see cref="P:NDepend.CodeQuery.IGroup.ShownInReport" /> can be changed.
            </summary>
      <param name="group">The group on which to change the flag <see cref="P:NDepend.CodeQuery.IGroup.ShownInReport" />.</param>
      <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
      <remarks>If group.<see cref="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode" /> its value <see cref="P:NDepend.CodeQuery.IGroup.ShownInReport" /> cannot be changed.</remarks>
      <requires description="group must not be null" csharp="group != null" vb="group &lt;&gt; Nothing">group != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.DoChangeGroupShownInReport(NDepend.CodeQuery.IGroup,System.Boolean)">
      <summary>Change <paramref name="group" />.<see cref="P:NDepend.CodeQuery.IGroup.ShownInReport" /> to <paramref name="shownInReport" />.</summary>
      <param name="group">The group on which to change the flag <see cref="P:NDepend.CodeQuery.IGroup.ShownInReport" />.</param>
      <param name="shownInReport">The new <see cref="P:NDepend.CodeQuery.IGroup.ShownInReport" /> boolean state of the group.</param>
      <exception cref="T:System.ArgumentException">
            Can't perform the group flag changing operation on these arguments.<br />
            Please check arguments with the method <see cref="M:NDepend.CodeQuery.IController.CanChangeGroupShownInReport(NDepend.CodeQuery.IGroup,System.String@)" /> before calling this method.
            </exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="group must not be null" csharp="group != null" vb="group &lt;&gt; Nothing">group != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.CanChangeQueryActivation(NDepend.CodeQuery.IQuery,System.String@)">
      <summary>
            Gets a value indicating whether <paramref name="query" />.<see cref="P:NDepend.CodeQuery.IGroup.IsActive" /> can be changed.
            </summary>
      <param name="query">The query on which to change the activation.</param>
      <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
      <remarks>If query.<see cref="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode" /> its activation cannot be changed.</remarks>
      <requires description="query must not be null" csharp="query != null" vb="query &lt;&gt; Nothing">query != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.DoChangeQueryActivation(NDepend.CodeQuery.IQuery,System.Boolean)">
      <summary>Change <paramref name="query" />.<see cref="P:NDepend.CodeQuery.IQuery.IsActive" /> to <paramref name="active" />.</summary>
      <param name="query">The query on which to change the name.</param>
      <param name="active">The new activation boolean state of the query.</param>
      <exception cref="T:System.ArgumentException">
            Can't perform the query activation changing operation on these arguments.<br />
            Please check arguments with the method <see cref="M:NDepend.CodeQuery.IController.CanChangeQueryActivation(NDepend.CodeQuery.IQuery,System.String@)" /> before calling this method.
            </exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="query must not be null" csharp="query != null" vb="query &lt;&gt; Nothing">query != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.DoUpdateQueryObject(NDepend.CodeQuery.IQuery,NDepend.CodeQuery.IQuery)">
      <summary>Update <paramref name="oldQuery" /> object with <paramref name="newQuery" /> object.</summary>
      <param name="oldQuery">The old object representing the query.</param>
      <param name="newQuery">The new object representing the query.</param>
      <exception cref="T:System.ArgumentException">
            Can't perform the query update operation on these arguments.<br />
            Please check <paramref name="oldQuery" /> with the method <see cref="M:NDepend.CodeQuery.IController.IsUnderRootParent(NDepend.CodeQuery.IQuery,System.String@)" /> before calling this method.
            </exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="oldQuery must not be null" csharp="oldQuery != null" vb="oldQuery &lt;&gt; Nothing">oldQuery != null</requires>
      <requires description="newQuery must not be null" csharp="newQuery != null" vb="newQuery &lt;&gt; Nothing">newQuery != null</requires>
      <requires description="newQuery.Parent must be null" csharp="newQuery.Parent == null" vb="newQuery.Parent = Nothing">newQuery.Parent == null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.CanInsertGroupUnder(NDepend.CodeQuery.IGroupOfGroups,System.String@)">
      <summary>
            Gets a value indicating whether a group can be inserted under <paramref name="setParent" />.
            </summary>
      <param name="setParent">The parent set under which a group might be inserted.</param>
      <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
      <remarks>If setParent.<see cref="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode" /> a group cannot be inserted under it.</remarks>
      <requires description="oldQuery must not be null" csharp="setParent != null" vb="setParent &lt;&gt; Nothing">setParent != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.DoInsertGroup(NDepend.CodeQuery.IGroup,NDepend.CodeQuery.IGroupOfGroups,System.Int32)">
      <summary>Insert <paramref name="groupToInsert" /> under <paramref name="oldSetParent" />.</summary>
      <param name="groupToInsert">The group to insert.</param>
      <param name="oldSetParent">The parent set under which the group is inserted.</param>
      <param name="index">The index in <paramref name="oldSetParent" /> children groups, at which <paramref name="groupToInsert" /> is inserted.</param>
      <exception cref="T:System.ArgumentException">
            Can't perform the insertion operation on these arguments.<br />
            Please check <paramref name="oldSetParent" /> with the method <see cref="M:NDepend.CodeQuery.IController.CanInsertGroupUnder(NDepend.CodeQuery.IGroupOfGroups,System.String@)" /> before calling this method.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> must be a positive or zero integer, lower or equals to <paramref name="oldSetParent" />.<see cref="P:NDepend.CodeQuery.IGroupOfGroups.ChildGroupsCount" />.</exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="groupToInsert must not be null" csharp="groupToInsert != null" vb="groupToInsert &lt;&gt; Nothing">groupToInsert != null</requires>
      <requires description="groupToInsert.Parent must be null" csharp="groupToInsert.Parent == null" vb="groupToInsert.Parent = Nothing">groupToInsert.Parent == null</requires>
      <requires description="oldSetParent must not be null" csharp="oldSetParent != null" vb="oldSetParent &lt;&gt; Nothing">oldSetParent != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.DoAddGroup(NDepend.CodeQuery.IGroup,NDepend.CodeQuery.IGroupOfGroups)">
      <summary>Add <paramref name="groupToAdd" /> under <paramref name="oldSetParent" />.</summary>
      <param name="groupToAdd">The group to add.</param>
      <param name="oldSetParent">The parent set under which the group is added.</param>
      <exception cref="T:System.ArgumentException">
            Can't perform the insertion operation on these arguments.<br />
            Please check <paramref name="oldSetParent" /> with the method <see cref="M:NDepend.CodeQuery.IController.CanInsertGroupUnder(NDepend.CodeQuery.IGroupOfGroups,System.String@)" /> before calling this method.
            </exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="groupToAdd must not be null" csharp="groupToAdd != null" vb="groupToAdd &lt;&gt; Nothing">groupToAdd != null</requires>
      <requires description="groupToAdd.Parent must be null" csharp="groupToAdd.Parent == null" vb="groupToAdd.Parent = Nothing">groupToAdd.Parent == null</requires>
      <requires description="oldSetParent must not be null" csharp="oldSetParent != null" vb="oldSetParent &lt;&gt; Nothing">oldSetParent != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.CanDeleteGroup(NDepend.CodeQuery.IGroup,System.String@)">
      <summary>Gets a value indicating whether <paramref name="groupToDelete" /> can be deleted.</summary>
      <param name="groupToDelete">The group to delete.</param>
      <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
      <remarks>If groupToDelete.<see cref="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode" />, the group cannot be deleted.</remarks>
      <requires description="group must not be null" csharp="groupToDelete != null" vb="groupToDelete &lt;&gt; Nothing">groupToDelete != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.MessageBoxToDemandGroupDeletion(NDepend.CodeQuery.IGroup)">
      <summary>Ask the user through a message box, if he really wishes to delete <paramref name="groupToDelete" />.</summary>
      <returns>true if the user wishes to delete the group, otherwise returns false.</returns>
      <param name="groupToDelete">The group to delete.</param>
      <requires description="group must not be null" csharp="groupToDelete != null" vb="groupToDelete &lt;&gt; Nothing">groupToDelete != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.DoDeleteGroup(NDepend.CodeQuery.IGroup)">
      <summary>Do delete <paramref name="groupToDelete" />.</summary>
      <param name="groupToDelete">The group to delete.</param>
      <exception cref="T:System.ArgumentException">
            Can't perform the deletion operation on these arguments.<br />
            Please check <paramref name="groupToDelete" /> with the method <see cref="M:NDepend.CodeQuery.IController.CanDeleteGroup(NDepend.CodeQuery.IGroup,System.String@)" /> before calling this method.
            </exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="group must not be null" csharp="groupToDelete != null" vb="groupToDelete &lt;&gt; Nothing">groupToDelete != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.CanDeleteQuery(NDepend.CodeQuery.IQuery,System.String@)">
      <summary>Gets a value indicating whether <paramref name="queryToDelete" /> can be deleted.</summary>
      <param name="queryToDelete">The query to delete.</param>
      <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
      <remarks>If queryToDelete.<see cref="P:NDepend.CodeQuery.IQuery.IsExtractedFromCode" />, the query cannot be deleted.</remarks>
      <requires description="query must not be null" csharp="queryToDelete != null" vb="queryToDelete &lt;&gt; Nothing">queryToDelete != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.MessageBoxToDemandQueryDeletion(NDepend.CodeQuery.IQuery)">
      <summary>Ask the user through a message box, if he really wishes to delete <paramref name="queryToDelete" />.</summary>
      <returns>true if the user wishes to delete the query, otherwise returns false.</returns>
      <param name="queryToDelete">The query to delete.</param>
      <requires description="query must not be null" csharp="queryToDelete != null" vb="queryToDelete &lt;&gt; Nothing">queryToDelete != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.DoDeleteQuery(NDepend.CodeQuery.IQuery)">
      <summary>Do delete <paramref name="queryToDelete" />.</summary>
      <param name="queryToDelete">The query to delete.</param>
      <exception cref="T:System.ArgumentException">
            Can't perform the deletion operation on these arguments.<br />
            Please check <paramref name="queryToDelete" /> with the method <see cref="M:NDepend.CodeQuery.IController.CanDeleteQuery(NDepend.CodeQuery.IQuery,System.String@)" /> before calling this method.
            </exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="query must not be null" csharp="queryToDelete != null" vb="queryToDelete &lt;&gt; Nothing">queryToDelete != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.CanInsertQueryUnder(NDepend.CodeQuery.IGroup,System.String@)">
      <summary>
            Gets a value indicating whether a query can be inserted under <paramref name="groupParent" />.
            </summary>
      <param name="groupParent">The parent group under which a query might be inserted.</param>
      <param name="failureReason">If false is returned, contains the plain-english explanation of the failure.</param>
      <remarks>If <paramref name="groupParent" />.<see cref="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode" /> a query cannot be inserted under it.</remarks>
      <requires description="group must not be null" csharp="groupParent != null" vb="groupParent &lt;&gt; Nothing">groupParent != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.DoInsertQuery(NDepend.CodeQuery.IQuery,NDepend.CodeQuery.IGroup,System.Int32)">
      <summary>Insert <paramref name="queryToInsert" /> under <paramref name="groupParentOldObj" />.</summary>
      <param name="queryToInsert">The query to insert.</param>
      <param name="groupParentOldObj">The parent group under which the query is inserted.</param>
      <param name="index">The index in <paramref name="groupParentOldObj" /> children queries, at which <paramref name="queryToInsert" /> is inserted.</param>
      <exception cref="T:System.ArgumentException">
            Can't perform the insertion operation on these arguments.<br />
            Please check <paramref name="queryToInsert" /> with the method <see cref="M:NDepend.CodeQuery.IController.CanInsertQueryUnder(NDepend.CodeQuery.IGroup,System.String@)" /> before calling this method.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> must be a positive or zero integer, lower or equals to <paramref name="groupParentOldObj" />.<see cref="P:NDepend.CodeQuery.IGroup.ChildQueriesCount" />.</exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="query must not be null" csharp="queryToInsert != null" vb="queryToInsert &lt;&gt; Nothing">queryToInsert != null</requires>
      <requires description="query.Parent must be null" csharp="queryToInsert.Parent == null" vb="queryToInsert.Parent = Nothing">queryToInsert.Parent == null</requires>
      <requires description="groupParentOldObj must not be null" csharp="groupParentOldObj != null" vb="groupParentOldObj &lt;&gt; Nothing">groupParentOldObj != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IController.DoAddQuery(NDepend.CodeQuery.IQuery,NDepend.CodeQuery.IGroup)">
      <summary>Add <paramref name="queryToAdd" /> under <paramref name="groupParentOldObj" />.</summary>
      <param name="queryToAdd">The query to add.</param>
      <param name="groupParentOldObj">The group under which the query is added.</param>
      <exception cref="T:System.ArgumentException">
            Can't perform the insertion operation on these arguments.<br />
            Please check <paramref name="queryToAdd" /> with the method <see cref="M:NDepend.CodeQuery.IController.CanInsertQueryUnder(NDepend.CodeQuery.IGroup,System.String@)" /> before calling this method.
            </exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="query must not be null" csharp="queryToAdd != null" vb="queryToAdd &lt;&gt; Nothing">queryToAdd != null</requires>
      <requires description="query.Parent must be null" csharp="queryToAdd.Parent == null" vb="queryToAdd.Parent = Nothing">queryToAdd.Parent == null</requires>
      <requires description="groupParentOldObj must not be null" csharp="groupParentOldObj != null" vb="groupParentOldObj &lt;&gt; Nothing">groupParentOldObj != null</requires>
    </member>
    <member name="P:NDepend.CodeQuery.IController.RootParent">
      <summary>
            Gets the root parent on which the controller does changes.
            </summary>
      <getter>
        <ensures description="returned group of groups object is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.IGroup">
      <summary>
            Represents a group of code queries and groups. A <see cref="T:NDepend.CodeQuery.IGroup" /> object can be created with the method <see cref="T:NDepend.CodeQuery.IController" />.<see cref="M:NDepend.CodeQuery.IController.CreateGroup(System.String,System.Boolean,System.Boolean,System.Collections.Generic.ICollection{NDepend.CodeQuery.IQuery},System.Collections.Generic.ICollection{NDepend.CodeQuery.IGroup})" />.
            </summary>
      <remarks>
            A <see cref="T:NDepend.CodeQuery.IQuery" />, <see cref="T:NDepend.CodeQuery.IGroup" />, <see cref="T:NDepend.CodeQuery.IGroupOfGroups" /> or <see cref="T:NDepend.CodeQuery.IController" /> object is bound to the thread that created it.<br />
            In other words, a code query object cannot be used from a thread different than the thread that created it, else an InvalidOperationException is thrown.<br />
            This limitation is due to the fact that the hierarchy of code queries object must be immutable from the point of view of any query object.<br />
            However the changes made to the hierarchy of code queries object are centralized in a thread bounded state.<br />
            Doing so, garantees the impossibility of a hierarchy of code queries corrupted state.
            </remarks>
    </member>
    <member name="T:NDepend.CodeQuery.IGroupOfGroups">
      <summary>
            Represents a group of groups. <see cref="T:NDepend.CodeQuery.IGroup" /> implements <see cref="T:NDepend.CodeQuery.IGroupOfGroups" /> since it is both a group of groups and also, a group of queries.
            </summary>
      <remarks>
            A <see cref="T:NDepend.CodeQuery.IQuery" />, <see cref="T:NDepend.CodeQuery.IGroup" />, <see cref="T:NDepend.CodeQuery.IGroupOfGroups" /> or <see cref="T:NDepend.CodeQuery.IController" /> object is bound to the thread that created it.<br />
            In other words, a code query object cannot be used from a thread different than the thread that created it, else an InvalidOperationException is thrown.<br />
            This limitation is due to the fact that the hierarchy of code queries object must be immutable from the point of view of any query object.<br />
            However the changes made to the hierarchy of code queries object are centralized in a thread bounded state.<br />
            Doing so, garantees the impossibility of a hierarchy of code queries corrupted state.
            </remarks>
    </member>
    <member name="M:NDepend.CodeQuery.IGroupOfGroups.ContainsGroup(NDepend.CodeQuery.IGroup)">
      <summary>Gets a value indicating whether this group of groups contains <paramref name="group" />.</summary>
      <param name="group">The group to locate in this <see cref="T:NDepend.CodeQuery.IGroupOfGroups" />.</param>
      <requires description="group must not be null" csharp="group != null" vb="group &lt;&gt; Nothing">group != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IGroupOfGroups.GetGroupAt(System.Int32)">
      <summary>
            Returns the group at the <paramref name="index" /> position in this.<see cref="P:NDepend.CodeQuery.IGroupOfGroups.ChildGroups" />.
            </summary>
      <param name="index">The index position.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> must be a positive or zero integer, strictly lower than this.<see cref="P:NDepend.CodeQuery.IGroupOfGroups.ChildGroupsCount" />.</exception>
    </member>
    <member name="M:NDepend.CodeQuery.IGroupOfGroups.IndexOfGroup(NDepend.CodeQuery.IGroup)">
      <summary>
            Determines the index of a specific group in this.<see cref="P:NDepend.CodeQuery.IGroupOfGroups.ChildGroups" />.
            </summary>
      <remarks>If this group of groups deosn't contain <paramref name="group" />, the value -1 is returned.</remarks>
      <param name="group">The group to locate in this.<see cref="P:NDepend.CodeQuery.IGroupOfGroups.ChildGroups" />.</param>
      <requires description="group must not be null" csharp="group != null" vb="group &lt;&gt; Nothing">group != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IGroupOfGroups.AddGroup(NDepend.CodeQuery.IGroup)">
      <summary>
            Add <paramref name="groupToAdd" /> to this group of groups children.
            </summary>
      <param name="groupToAdd">The group to add.</param>
      <returns>The new group of groups object representing this group of groups.</returns>
      <remarks>Since code query objects are immutable, the old group of groups object have been replaced in the parent hierarchy by the new returned group of groups object.</remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="groupToAdd" /> must be different than this group of groups.</exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="group must not be null" csharp="groupToAdd != null" vb="groupToAdd &lt;&gt; Nothing">groupToAdd != null</requires>
      <requires description="group must have no parent" csharp="groupToAdd.Parent == null" vb="groupToAdd.Parent = Nothing">groupToAdd.Parent == null</requires>
      <ensures description="returned group of groups is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.IGroupOfGroups.RemoveGroup(NDepend.CodeQuery.IGroup)">
      <summary>
            Remove <paramref name="groupToRemove" /> from this group of groups children.
            </summary>
      <param name="groupToRemove">The group to remove.</param>
      <returns>The new group of groups object representing this group of groups.</returns>
      <remarks>Since code query objects are immutable, the old group of groups object have been replaced in the parent hierarchy by the new returned group of groups object.</remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="groupToRemove" /> must be different than this group of groups.<br />
            Also, this group of groups must contain <paramref name="groupToRemove" />.
            </exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="newGroup must not be null" csharp="groupToRemove != null" vb="groupToRemove &lt;&gt; Nothing">groupToRemove != null</requires>
      <ensures description="returned group of groups is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.IGroupOfGroups.ReplaceGroup(NDepend.CodeQuery.IGroup,NDepend.CodeQuery.IGroup)">
      <summary>
            Replace <paramref name="groupToReplace" /> with <paramref name="newGroup" />.
            </summary>
      <param name="groupToReplace">The group to replace.</param>
      <param name="newGroup">The group that replaces <paramref name="groupToReplace" />.</param>
      <returns>The new group of groups object representing this group of groups.</returns>
      <remarks>Since code query objects are immutable, the old group of groups object have been replaced in the parent hierarchy by the new returned group of groups object.</remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="groupToReplace" /> and <paramref name="newGroup" /> must both be different than this group of groups.<br />
            Also <paramref name="groupToReplace" /> must be a child group of this group of groups and <paramref name="newGroup" /> must not be a child group of this group of groups.
            </exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="groupToReplace must not be null" csharp="groupToReplace != null" vb="groupToReplace &lt;&gt; Nothing">groupToReplace != null</requires>
      <requires description="newGroup must not be null" csharp="newGroup != null" vb="newGroup &lt;&gt; Nothing">newGroup != null</requires>
      <ensures description="returned group of groups is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.IGroupOfGroups.MoveGroupToIndex(System.Int32,NDepend.CodeQuery.IGroup)">
      <summary>
            Move <paramref name="groupToMove" /> to the position specified by <paramref name="index" />.
            </summary>
      <param name="index">The new <paramref name="groupToMove" /> position under this group of groups child groups.</param>
      <param name="groupToMove">The group to move.</param>
      <returns>The new group of groups object representing this group of groups.</returns>
      <remarks>Since code query objects are immutable, the old group of groups object have been replaced in the parent hierarchy by the new returned group of groups object.</remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> must be a positive or zero integer, and <paramref name="index" /> must be strictly lower than this.<see cref="P:NDepend.CodeQuery.IGroupOfGroups.ChildGroupsCount" />.
            </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="groupToMove" /> must be different than this group of groups.<br />
            Also <paramref name="groupToMove" /> must be a child group of this group of groups.
            </exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="group must not be null" csharp="groupToMove != null" vb="groupToMove &lt;&gt; Nothing">groupToMove != null</requires>
      <ensures description="returned group of groups is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.IGroupOfGroups.AddRange(System.Collections.Generic.IEnumerable{NDepend.CodeQuery.IGroup})">
      <summary>
            Add a sequence of groups to this group of groups children.
            </summary>
      <param name="groups">The sequence of groups to add.</param>
      <returns>The new group of groups object representing this group of groups.</returns>
      <remarks>Since code query objects are immutable, the old group of groups object have been replaced in the parent hierarchy by the new returned group of groups object.</remarks>
      <remarks>If <paramref name="groups" /> contains some group that already have this group of groups for parent, the algorithm don't add them a second time.</remarks>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="groups must not be null" csharp="groups != null" vb="groups &lt;&gt; Nothing">groups != null</requires>
      <ensures description="returned group of groups is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.IGroupOfGroups.CloneDeep">
      <summary>
            Clone this group of groups and all its child groups and child queries recurively.
            </summary>
      <returns>This group of groups cloned.</returns>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <ensures description="returned group of groups is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:NDepend.CodeQuery.IGroupOfGroups.RootParent">
      <summary>
            Gets the root parent. Returns this if this.<see cref="P:NDepend.CodeQuery.IGroupOfGroups.IsRootParent" />. Returns null if the group of groups has no root parent. 
            </summary>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
    </member>
    <member name="P:NDepend.CodeQuery.IGroupOfGroups.IsRootParent">
      <summary>Gets a value indicating whether this group of groups is a root parent.</summary>
    </member>
    <member name="P:NDepend.CodeQuery.IGroupOfGroups.ChildGroups">
      <summary>Gets the collection of child groups.</summary>
      <getter>
        <ensures description="returned collection is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeQuery.IGroupOfGroups.ChildGroupsCount">
      <summary>Gets the child groups count.</summary>
      <getter>
        <ensures description="returned integer is positive or zero" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeQuery.IGroupOfGroups.AllQueriesRecursive">
      <summary>
            Gets all queries under this <see cref="T:NDepend.CodeQuery.IGroupOfGroups" />, and also under child groups, recursively.
            </summary>
      <getter>
        <ensures description="returned collection is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeQuery.IGroupOfGroups.AllGroupsRecursive">
      <summary>
            Gets all groups under this <see cref="T:NDepend.CodeQuery.IGroupOfGroups" />, and also under child groups, recursively.
            </summary>
      <getter>
        <ensures description="returned collection is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:NDepend.CodeQuery.IGroup.SetName(System.String)">
      <summary>Set the group name to <paramref name="newName" />.</summary>
      <param name="newName">The new group name.</param>
      <returns>The new group object representing this group.</returns>
      <remarks>Since code query objects are immutable, the old group object have been replaced in the parent hierarchy by the new returned group object.</remarks>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="group name must not be null" csharp="newName != null" vb="newName &lt;&gt; Nothing">newName != null</requires>
      <requires description="group name must not be empty" csharp="newName.Length &gt; 0" vb="newName.Length &gt; 0">newName.Length &gt; 0</requires>
      <ensures description="returned group is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.IGroup.SetIsActive(System.Boolean)">
      <summary>Set the group activation to <paramref name="newIsActive" />.</summary>
      <param name="newIsActive">The new group activation.</param>
      <returns>The new group object representing this group.</returns>
      <remarks>Since code query objects are immutable, the old group object have been replaced in the parent hierarchy by the new returned group object.</remarks>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <ensures description="returned group is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.IGroup.SetShownInReport(System.Boolean)">
      <summary>Set the group <see cref="P:NDepend.CodeQuery.IGroup.ShownInReport" /> state to <paramref name="newShownInReport" />.</summary>
      <param name="newShownInReport">The new group <see cref="P:NDepend.CodeQuery.IGroup.ShownInReport" /> state.</param>
      <returns>The new group object representing this group.</returns>
      <remarks>Since code query objects are immutable, the old group object have been replaced in the parent hierarchy by the new returned group object.</remarks>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <ensures description="returned group is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.IGroup.ContainsQuery(NDepend.CodeQuery.IQuery)">
      <summary>Gets a value indicating whether this group contains <paramref name="query" />.</summary>
      <param name="query">The query to locate in this <see cref="T:NDepend.CodeQuery.IGroup" />.</param>
      <requires description="query must not be null" csharp="query != null" vb="query &lt;&gt; Nothing">query != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IGroup.GetQueryAt(System.Int32)">
      <summary>
            Returns the query at the <paramref name="index" /> position in this.<see cref="P:NDepend.CodeQuery.IGroup.ChildQueries" />.
            </summary>
      <param name="index">The index position.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> must be a positive or zero integer, strictly lower than this.<see cref="P:NDepend.CodeQuery.IGroup.ChildQueriesCount" />.</exception>
    </member>
    <member name="M:NDepend.CodeQuery.IGroup.IndexOfQuery(NDepend.CodeQuery.IQuery)">
      <summary>
            Determines the index of a specific query in this.<see cref="P:NDepend.CodeQuery.IGroup.ChildQueries" />.
            </summary>
      <remarks>If this group of groups deosn't contain <paramref name="query" />, the value -1 is returned.</remarks>
      <param name="query">The query to locate in this.<see cref="P:NDepend.CodeQuery.IGroup.ChildQueries" />.</param>
      <requires description="query must not be null" csharp="query != null" vb="query &lt;&gt; Nothing">query != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IGroup.AddQuery(NDepend.CodeQuery.IQuery)">
      <summary>
            Add <paramref name="queryToAdd" /> to this group child queries.
            </summary>
      <param name="queryToAdd">The query to add.</param>
      <returns>The new group object representing this group.</returns>
      <remarks>Since code query objects are immutable, the old group object have been replaced in the parent hierarchy by the new returned group object.</remarks>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="queryToAdd must not be null" csharp="queryToAdd != null" vb="queryToAdd &lt;&gt; Nothing">queryToAdd != null</requires>
      <requires description="queryToAdd.Parent must be null" csharp="queryToAdd.Parent == null" vb="queryToAdd.Parent = Nothing">queryToAdd.Parent == null</requires>
      <ensures description="returned group is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.IGroup.RemoveQuery(NDepend.CodeQuery.IQuery)">
      <summary>
            Remove <paramref name="queryToRemove" /> to this group child queries.
            </summary>
      <param name="queryToRemove">The query to remove.</param>
      <returns>The new group object representing this group.</returns>
      <remarks>Since code query objects are immutable, the old group object have been replaced in the parent hierarchy by the new returned group object.</remarks>
      <exception cref="T:System.ArgumentException">This group muts contain <paramref name="queryToRemove" />.</exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="queryToRemove must not be null" csharp="queryToRemove != null" vb="queryToRemove &lt;&gt; Nothing">queryToRemove != null</requires>
      <ensures description="returned group is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.IGroup.ReplaceQuery(NDepend.CodeQuery.IQuery,NDepend.CodeQuery.IQuery)">
      <summary>
            Replace <paramref name="queryToReplace" /> with <paramref name="newQuery" />.
            </summary>
      <param name="queryToReplace">The query to replace.</param>
      <param name="newQuery">The query that replaces <paramref name="queryToReplace" />.</param>
      <returns>The new group object representing this group.</returns>
      <remarks>Since code query objects are immutable, the old group object have been replaced in the parent hierarchy by the new returned group object.</remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="queryToReplace" /> must be a child query of this group and <paramref name="newQuery" /> must not be a child query of this group.
            </exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="queryToReplace must not be null" csharp="queryToReplace != null" vb="queryToReplace &lt;&gt; Nothing">queryToReplace != null</requires>
      <requires description="newQuery must not be null" csharp="newQuery != null" vb="newQuery &lt;&gt; Nothing">newQuery != null</requires>
      <ensures description="returned group is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.IGroup.MoveQueryToIndex(System.Int32,NDepend.CodeQuery.IQuery)">
      <summary>
            Move <paramref name="queryToMove" /> to the position specified by <paramref name="index" />.
            </summary>
      <param name="index">The new <paramref name="queryToMove" /> position under this group child queries.</param>
      <param name="queryToMove">The query to move.</param>
      <returns>The new group object representing this group.</returns>
      <remarks>Since code query objects are immutable, the old group object have been replaced in the parent hierarchy by the new returned group object.</remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> must be a positive or zero integer, and <paramref name="index" /> must be strictly lower than this.<see cref="P:NDepend.CodeQuery.IGroup.ChildQueriesCount" />.
            </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="queryToMove" /> must be a child query of this group.
            </exception>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <requires description="queryToMove must not be null" csharp="queryToMove != null" vb="queryToMove &lt;&gt; Nothing">queryToMove != null</requires>
      <ensures description="returned group is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:NDepend.CodeQuery.IGroup.Parent">
      <summary>
            Gets the parent group. Returns null if the group has no parent group.
            </summary>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
    </member>
    <member name="P:NDepend.CodeQuery.IGroup.Name">
      <summary>
            Gets this group name.
            </summary>
      <getter>
        <ensures description="returned group name is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned group name is not empty" csharp="result.Length &gt; 0" vb="result.Length &gt; 0">result.Length &gt; 0</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeQuery.IGroup.IsActive">
      <summary>
            Gets a value indicating whether this group is activated.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.IGroup.ShownInReport">
      <summary>
            Gets a value indicating whether this group's child queries are shown in report, in a dedicated section.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode">
      <summary>
            Gets a value indicating whether this group has been created for queries extracted from code, with the attribute <see cref="T:NDepend.Attributes.CodeRuleAttribute" />.
            </summary>
      <remarks>
            When this.IsExtractedFromCode is true, the group name is the namespace that contains the code elements tagged with <see cref="T:NDepend.Attributes.CodeRuleAttribute" />.<br />
            For anonymous namespace,  the group name is the parent assembly name that contains the code elements tagged with <see cref="T:NDepend.Attributes.CodeRuleAttribute" />.
            </remarks>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <seealso cref="T:NDepend.Attributes.CodeRuleAttribute" />
      <see cref="P:NDepend.CodeQuery.IQuery.IsExtractedFromCode" />
    </member>
    <member name="P:NDepend.CodeQuery.IGroup.ChildQueries">
      <summary>Gets the collection of child queries.</summary>
      <getter>
        <ensures description="returned collection of queries is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeQuery.IGroup.ChildQueriesCount">
      <summary>Gets the child queries count.</summary>
      <getter>
        <ensures description="returned integer is positive or zero" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.IQuery">
      <summary>
            Represents a code query. A <see cref="T:NDepend.CodeQuery.IQuery" /> object can be created with the method <see cref="T:NDepend.CodeQuery.IController" />.<see cref="M:NDepend.CodeQuery.IController.CreateQuery(System.Boolean,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />.
            </summary>
      <remarks>
            A <see cref="T:NDepend.CodeQuery.IQuery" />, <see cref="T:NDepend.CodeQuery.IGroup" />, <see cref="T:NDepend.CodeQuery.IGroupOfGroups" /> or <see cref="T:NDepend.CodeQuery.IController" /> object is bound to the thread that created it.<br />
            In other words, a code query object cannot be used from a thread different than the thread that created it, else an InvalidOperationException is thrown.<br />
            This limitation is due to the fact that the hierarchy of code queries object must be immutable from the point of view of any query object.<br />
            However the changes made to the hierarchy of code queries object are centralized in a thread bounded state.<br />
            Doing so, garantees the impossibility of a hierarchy of code queries corrupted state.
            </remarks>
    </member>
    <member name="M:NDepend.CodeQuery.IQuery.EqualsTo(NDepend.CodeQuery.IQuery)">
      <summary>
            Returns true if this query and <paramref name="queryToCompareWith" /> have same value for <see cref="P:NDepend.CodeQuery.IQuery.QueryString" />, <see cref="P:NDepend.CodeQuery.IQuery.IsActive" />, <see cref="P:NDepend.CodeQuery.IQuery.DisplayListInReport" />, <see cref="P:NDepend.CodeQuery.IQuery.DisplaySelectionViewInReport" />, <see cref="P:NDepend.CodeQuery.IQuery.DisplayStatInReport" />, <see cref="P:NDepend.CodeQuery.IQuery.IsCriticalRule" />.
            </summary>
      <remarks>
        <see cref="P:NDepend.CodeQuery.IQuery.IsExtractedFromCode" /> is not taken account for this equality operation.</remarks>
      <param name="queryToCompareWith">The query to compare with.</param>
      <requires description="queryToCompareWith must not be null." csharp="queryToCompareWith != null" vb="queryToCompareWith &lt;&gt; Nothing">queryToCompareWith != null</requires>
    </member>
    <member name="M:NDepend.CodeQuery.IQuery.Clone">
      <summary>
            Returns a new query where values for <see cref="P:NDepend.CodeQuery.IQuery.QueryString" />, <see cref="P:NDepend.CodeQuery.IQuery.IsActive" />, <see cref="P:NDepend.CodeQuery.IQuery.DisplayListInReport" />, <see cref="P:NDepend.CodeQuery.IQuery.DisplaySelectionViewInReport" />, <see cref="P:NDepend.CodeQuery.IQuery.DisplayStatInReport" />, <see cref="P:NDepend.CodeQuery.IQuery.IsCriticalRule" /> have been cloned.
            </summary>
      <remarks>The state <see cref="P:NDepend.CodeQuery.IQuery.IsExtractedFromCode" /> is not cloned.</remarks>
      <ensures description="returned query is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.CodeQuery.IQuery.SetIsActive(System.Boolean)">
      <summary>
            Returns a new <see cref="T:NDepend.CodeQuery.IQuery" /> object cloned from this object, where <see cref="P:NDepend.CodeQuery.IQuery.IsActive" /> value is set to <paramref name="isActive" />, if this value for <see cref="P:NDepend.CodeQuery.IQuery.IsActive" /> is different than <paramref name="isActive" />. Otherwise returns this <see cref="T:NDepend.CodeQuery.IQuery" />.
            </summary>
      <param name="isActive">The new value for <see cref="P:NDepend.CodeQuery.IQuery.IsActive" />.</param>
      <remarks>
            The default value is true.<br /> 
            Since the queries hierarchy is an immutable hierarchical structure, this methods changes the hierarchy of objects if this value for <see cref="P:NDepend.CodeQuery.IQuery.IsActive" /> is different than <paramref name="isActive" />.
            </remarks>
      <returns>The new query object representing this query.</returns>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
      <ensures description="returned query is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:NDepend.CodeQuery.IQuery.Parent">
      <summary>
            Gets the parent group. Returns null if the query has no parent group.
            </summary>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
    </member>
    <member name="P:NDepend.CodeQuery.IQuery.RootParent">
      <summary>
            Gets the root parent. Returns null if the query has no root parent.
            </summary>
      <exception cref="T:System.InvalidOperationException">A code query object cannot be used from a thread different than the thread that created it.</exception>
    </member>
    <member name="P:NDepend.CodeQuery.IQuery.IsActive">
      <summary>
            Gets a value that indicates whether the query is active.
            </summary>
      <remarks>
            The default value is true.
            </remarks>
    </member>
    <member name="P:NDepend.CodeQuery.IQuery.IsExtractedFromCode">
      <summary>
            Gets a value that indicates whether the query has been extracted from code.
            </summary>
      <remarks>
            A code query can be extracted from code thanks to <see cref="T:NDepend.Attributes.CodeRuleAttribute" />.
            </remarks>
      <seealso cref="T:NDepend.Attributes.CodeRuleAttribute" />
      <see cref="P:NDepend.CodeQuery.IGroup.IsExtractedFromCode" />
    </member>
    <member name="P:NDepend.CodeQuery.IQuery.DisplayListInReport">
      <summary>
            Gets a value that indicates whether if the code rule is violated, the code rule matched code elements are listed into the report.
            </summary>
      <remarks>
            The default value is true.
            </remarks>
    </member>
    <member name="P:NDepend.CodeQuery.IQuery.DisplayStatInReport">
      <summary>
            Gets a value that indicates whether if the code rule is violated, the code rule matched code elements statistics are shown into the report.
            </summary>
      <remarks>
            The default value is true.
            </remarks>
    </member>
    <member name="P:NDepend.CodeQuery.IQuery.DisplaySelectionViewInReport">
      <summary>
            Gets a value that indicates whether if the code rule is violated, the code rule matched code elements are shown in a treemap picture embedded into the report.
            </summary>
      <remarks>
            The default value is false.
            </remarks>
    </member>
    <member name="P:NDepend.CodeQuery.IQuery.IsCriticalRule">
      <summary>
            Gets a value that indicates whether the code rule is critical or not.
            </summary>
      <remarks>
            The default value is false.<br />
            A critical code rule is useful to break the build process once the rule is violated.<br />
            More information at: <a href="http://www.ndepend.com/Doc_CI_CriticalRule.aspx">Critical Rules and Build Failure</a></remarks>
    </member>
    <member name="P:NDepend.CodeQuery.IQuery.QueryString">
      <summary>
            Gets the CQLinq or CQL code rule string or query string.
            </summary>
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.IQueryCompilationError">
      <summary>
            Represents a query compilation error.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryCompilationError.Description">
      <summary>
            Gets the description of the error.
            </summary>
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryCompilationError.SubStringStartPos">
      <summary>
            Gets the start position of the error highlight in the string <see cref="T:NDepend.CodeQuery.IQueryCompiled" />.<see cref="P:NDepend.CodeQuery.IQueryCompiled.OriginalQueryString" />.
            </summary>
      <getter>
        <ensures description="returned integer is positive or zero" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryCompilationError.SubStringLength">
      <summary>
            Gets the length of the error highlight in the string <see cref="T:NDepend.CodeQuery.IQueryCompiled" />.<see cref="P:NDepend.CodeQuery.IQueryCompiled.OriginalQueryString" />.
            </summary>
      <getter>
        <ensures description="returned integer is positive or zero" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.IQueryCompiled">
      <summary>
            Represents the result of a query compilation no matter whether it was a successful compilation or not.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryCompiled.OriginalQueryString">
      <summary>
            Gets the original code query string. 
            </summary>
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryCompiled.KindOfCodeQuerySyntax">
      <summary>
            Gets the kind of code query syntax.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryCompiled.KindOfCodeQueryExpression">
      <summary>
            Gets the kind of code query expression.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryCompiled.HasErrors">
      <summary>
            Gets a value indicating whether the code query has been compiled sucessfully or not.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryCompiled.QueryCompiledSuccess">
      <summary>
            Gets this object casted as a <see cref="T:NDepend.CodeQuery.IQueryCompiledSuccess" /> object if the code query has been compiled sucessfully, else gets null.
            </summary>
      <getter>
        <ensures description="returned IQueryCompiledSuccess object is not null if the query has been compiled sucessfully" csharp="result != default(decimal) || this.HasErrors" vb="result &lt;&gt; Nothing OrElse Me.HasErrors">result != default(decimal) || this.HasErrors</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryCompiled.QueryCompiledError">
      <summary>
            Gets this object casted as a <see cref="T:NDepend.CodeQuery.IQueryCompiledError" /> object if the code query hasn't been compiled sucessfully, else gets null.
            </summary>
      <getter>
        <ensures description="returned IQueryCompiledError object is not null if the query hasn't been compiled sucessfully" csharp="result != default(decimal) || !this.HasErrors" vb="result &lt;&gt; Nothing OrElse Not Me.HasErrors">result != default(decimal) || !this.HasErrors</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.IQueryCompiledError">
      <summary>
            Represents the result of a query compilation that failed.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryCompiledError.Errors">
      <summary>
            Gets a collection of errors.
            </summary>
      <getter>
        <ensures description="returned collection of errors is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.IQueryCompiledSuccess">
      <summary>
            Represents the result of a query that has been compiled successfully.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryCompiledSuccess.CodeBaseOnWhichToExecute">
      <summary>
            Gets the code base on which the code query has been compiled against.
            </summary>
      <remarks>
            If the query has been compiled in a comparison context, the returned code base is ICompareContext.<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" />.
            </remarks>
      <getter>
        <ensures description="returned code base is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryCompiledSuccess.CompareContextOnWhichToExecute">
      <summary>
            Gets the <see cref="T:NDepend.CodeModel.ICompareContext" /> object on which the code query has been compiled against. Gets null if the code query has been compiled against a code base.
            </summary>
      <remarks>
            If the query has been compiled in a comparison context, the returned code base is ICompareContext.<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" />.
            </remarks>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCompareContext">
      <summary>
            Gets a value indicating whether this code query relies on a <see cref="T:NDepend.CodeModel.ICompareContext" /> object.
            </summary>
      <remarks>
            The returned value is independant from the fact that <see cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.CompareContextOnWhichToExecute" /> is null or not.<br />
            A code query that relies on a compare context and that is executed without a compare context won't return a useful result.<br />
            In such situation, at query runtime an empty <see cref="T:NDepend.CodeModel.ICompareContext" /> object is provided, that returns null or false for all properties.
            </remarks>
      <seealso cref="T:NDepend.CodeModel.ICompareContext" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsHelpers.CreateCompareContextWithOlder(NDepend.CodeModel.ICodeBase,NDepend.CodeModel.ICodeBase)" />
      <seealso cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqCompare" />
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.Compile(System.String,NDepend.CodeModel.ICompareContext)" />
      <seealso cref="M:NDepend.CodeQuery.ExtensionMethodsQuery.CompileMany(System.Collections.Generic.ICollection{System.String},NDepend.CodeModel.ICompareContext)" />
      <seealso cref="M:NDepend.CodeModel.ExtensionMethodsTooling.TryCompareSourceWith(NDepend.CodeModel.ISourceFileLine,NDepend.CodeModel.ISourceFileLine)" />
    </member>
    <member name="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnJustMyCode">
      <summary>
            Gets a value indicating whether this code query relies on the <i>JustMyCode</i> set.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCodeCoverageData">
      <summary>
            Gets a value indicating whether this code query relies on the code coverage data.
            </summary>
      <remarks>
            Code coverage data is deemed to be used if the query use any of this property getter: <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" />, <see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" /> or <see cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" />
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />
      <seealso cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" />
      <seealso cref="P:NDepend.CodeModel.ICodeBase.CoverageDataAvailable" />
      <seealso cref="T:NDepend.Project.IProjectCoverage" />
    </member>
    <member name="P:NDepend.CodeQuery.IQueryCompiledSuccess.KindOfMatch">
      <summary>
            Gets the kind of code element matched, <see cref="F:NDepend.CodeQuery.RecordCellType.Method" />, <see cref="F:NDepend.CodeQuery.RecordCellType.Field" />, <see cref="F:NDepend.CodeQuery.RecordCellType.Type" />, <see cref="F:NDepend.CodeQuery.RecordCellType.Namespace" />, <see cref="F:NDepend.CodeQuery.RecordCellType.Assembly" />, or <see cref="F:NDepend.CodeQuery.RecordCellType.NullableDouble" /> if the result will be a single scalar (<see cref="T:NDepend.CodeQuery.IQueryExecutionSuccessResult" />.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" />).
            </summary>
      <getter>
        <ensures description="the kind of match is restrained to CQLinq capabilities" csharp="result == (decimal)1 || result == (decimal)2 || result == (decimal)3 || result == (decimal)4 || result == (decimal)5 || result == (decimal)34" vb="result = ((NDepend.CodeQuery.RecordCellType)1) OrElse result = ((NDepend.CodeQuery.RecordCellType)2) OrElse result = ((NDepend.CodeQuery.RecordCellType)3) OrElse result = ((NDepend.CodeQuery.RecordCellType)4) OrElse result = ((NDepend.CodeQuery.RecordCellType)5) OrElse result = ((NDepend.CodeQuery.RecordCellType)34)">result == (decimal)1 || result == (decimal)2 || result == (decimal)3 || result == (decimal)4 || result == (decimal)5 || result == (decimal)34</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.IQueryExecutionSuccessResult">
      <summary>
            Represents a code query sucessful execution result. Such an object is obtained from a <see cref="T:NDepend.CodeQuery.IQueryExecutionResult" /> with <see cref="P:NDepend.CodeQuery.IQueryExecutionResult.Status" /> equals to <i>true</i>.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.CodeBaseOnWhichQueryHasBeenExecuted">
      <summary>
            Gets the code base on which the code query has been executed.
            </summary>
      <remarks>
            If the query has been executed in a comparison context, the returned code base is ICompareContext.<see cref="P:NDepend.CodeModel.ICompareContext.NewerCodeBase" />.
            </remarks>
      <getter>
        <ensures description="returned code base is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.OriginalQueryString">
      <summary>
            Gets the original code query string.
            </summary>
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsARuleViolated">
      <summary>
            Gets a value indicating whether the code query is a rule and is violated.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records">
      <summary>
            Gets records result.
            </summary>
      <remarks>
            If <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" /> is true, the collection returned is empty.
            </remarks>
      <seealso cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.MatchedCodeElements" />
      <getter>
        <ensures description="returned collection is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult">
      <summary>
            Gets a value indicating whether the code query returned a single scalar result.
            </summary>
      <remarks>
            Only CQLinq queries can return a scalar result through aggregation operators like Count() or Sum().<br />
            In such case <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" /> is an empty collection.
            </remarks>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.SingleScalarValue">
      <summary>
            Gets the single scalar result returned by the query.
            </summary>
      <remarks>
            Only CQLinq queries can return a scalar result through aggregation operators like Count() or Sum().<br />
            If <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" /> is false, this property returns null.<br />
            If <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" /> is true, this property might returns null if the CQLinq aggregation operation returned null.
            </remarks>
      <seealso cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" />
    </member>
    <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.TargetCodeElements">
      <summary>
            Gets code elements referenced in the query itself, like the code element named "XYZ" in "from t in Types where t.IsUsing("XYZ") select t".
            </summary>
      <remarks>
            If a wildcard match expression is used, like "X*YZ" instead of "XYZ", the returned collection contains all matched code elements.<br />
            Targets code elements can be matched by following extension methods declared in <see cref="N:NDepend.Reserved.CQLinq" />.<see cref="T:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency" />:<br /><see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedBy(NDepend.CodeModel.IUsed,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedByAssembly(NDepend.CodeModel.IUsed,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedByNamespace(NDepend.CodeModel.IUsed,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedByType(NDepend.CodeModel.IUsed,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsedByMethod(NDepend.CodeModel.IUsed,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsedBy(NDepend.CodeModel.IUsed,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsedBy(NDepend.CodeModel.IUsed,System.String)" />, <br /><see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsing(NDepend.CodeModel.IUser,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingAssembly(NDepend.CodeModel.IUser,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingNamespace(NDepend.CodeModel.IUser,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingType(NDepend.CodeModel.IUser,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingMethod(NDepend.CodeModel.IUser,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsUsingField(NDepend.CodeModel.IUser,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfIsUsing(NDepend.CodeModel.IUser,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.IsIndirectlyUsing(NDepend.CodeModel.IUser,System.String)" />, <br /><see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.ReturnTypeIs(NDepend.CodeModel.IMethod,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.FieldTypeIs(NDepend.CodeModel.IField,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.AssignField(NDepend.CodeModel.IMethod,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfAssignField(NDepend.CodeModel.IMethod,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.CreateA(NDepend.CodeModel.IMethod,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfCreateA(NDepend.CodeModel.IMethod,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.HasAttribute(NDepend.CodeModel.IAttributeTarget,System.String)" />, <br /><see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DeriveFrom(NDepend.CodeModel.IType,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.DepthOfDeriveFrom(NDepend.CodeModel.IType,System.String)" />, <see cref="M:NDepend.Reserved.CQLinq.ExtensionMethodsCQLinqDependency.Implement(NDepend.CodeModel.IType,System.String)" /></remarks>
      <getter>
        <ensures description="returned collection is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.MatchedCodeElements">
      <summary>
            Gets a collection of code elements matched by the code query. If <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" /> is <i>true</i> gets an empty collection.
            </summary>
      <remarks>
            This method is a facility to avoid extracting matched code elements from this.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" /> first column.<br />
            This extension method has a <i>O(this.<see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" />.Count)</i> time complexity.
            </remarks>
      <seealso cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Records" />
      <getter>
        <ensures description="returned collection is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.ColumnsNames">
      <summary>
            Returns columns' names of the result records.
            </summary>
      <remarks>
            If <see cref="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.IsSingleScalarResult" /> is true, the returned array contains one string "Value".
            </remarks>
      <getter>
        <ensures description="returned array is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.CodeQuery.IQueryExecutionSuccessResult.Description">
      <summary>
            Returns a brief description of the result, such as "12 methods matched" or "Single scalar result : 2 match".
            </summary>
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.KindOfCodeQueryExpression">
      <summary>
            Identifies the kind of code query expression.
            </summary>
    </member>
    <member name="F:NDepend.CodeQuery.KindOfCodeQueryExpression.SyntaxError">
      <summary>SyntaxError</summary>
    </member>
    <member name="F:NDepend.CodeQuery.KindOfCodeQueryExpression.Query">
      <summary>Query</summary>
    </member>
    <member name="F:NDepend.CodeQuery.KindOfCodeQueryExpression.Rule">
      <summary>Rule</summary>
    </member>
    <member name="F:NDepend.CodeQuery.KindOfCodeQueryExpression.NotMyCode">
      <summary>NotMyCode</summary>
    </member>
    <member name="T:NDepend.CodeQuery.KindOfCodeQuerySyntax">
      <summary>
            Defines a code query syntax, CQLinq or CQL.
            </summary>
    </member>
    <member name="F:NDepend.CodeQuery.KindOfCodeQuerySyntax.CQLinq">
      <summary>CQLinq</summary>
    </member>
    <member name="F:NDepend.CodeQuery.KindOfCodeQuerySyntax.CQL">
      <summary>CQL</summary>
    </member>
    <member name="T:NDepend.CodeQuery.RecordCellType">
      <summary>
            Represents the type of the object <see cref="F:NDepend.CodeQuery.RecordCellValue.m_UntypedValue" />.
            </summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Unknow">
      <summary>Unknow</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Method">
      <summary>Method</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Field">
      <summary>Field</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Type">
      <summary>Type</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Namespace">
      <summary>Namespace</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Assembly">
      <summary>Assembly</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Methods">
      <summary>Methods</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Fields">
      <summary>Fields</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Types">
      <summary>Types</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Namespaces">
      <summary>Namespaces</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Assemblies">
      <summary>Assemblies</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Visibility">
      <summary>Visibility</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.String">
      <summary>String</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Bool">
      <summary>Bool</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.NullableBool">
      <summary>NullableBool</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Byte">
      <summary>Byte</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.NullableByte">
      <summary>NullableByte</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.SByte">
      <summary>SByte</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.NullableSByte">
      <summary>NullableSByte</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Short">
      <summary>Short</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.NullableShort">
      <summary>NullableShort</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.UShort">
      <summary>UShort</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.NullableUShort">
      <summary>NullableUShort</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Int">
      <summary>Int</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.NullableInt">
      <summary>NullableInt</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.UInt">
      <summary>UInt</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.NullableUInt">
      <summary>NullableUInt</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Long">
      <summary>Long</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.NullableLong">
      <summary>NullableLong</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.ULong">
      <summary>ULong</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.NullableULong">
      <summary>NullableULong</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Float">
      <summary>Float</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.NullableFloat">
      <summary>NullableFloat</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Double">
      <summary>Double</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.NullableDouble">
      <summary>NullableDouble</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.Decimal">
      <summary>Decimal</summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellType.NullableDecimal">
      <summary>NullableDecimal</summary>
    </member>
    <member name="T:NDepend.DotNet.IAssemblyInfo">
      <summary>
            Represents information about the assembly that is defined by its main module file path <see cref="P:NDepend.DotNet.IAssemblyInfo.FilePath" />.
            </summary>
    </member>
    <member name="P:NDepend.DotNet.IAssemblyInfo.FileNameWithoutExtension">
      <summary>
            Gets the assembly main module file name without the ".dll" or ".exe" extension.
            </summary>
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned string is not empty" csharp="result.Length &gt; 0" vb="result.Length &gt; 0">result.Length &gt; 0</ensures>
      </getter>
    </member>
    <member name="P:NDepend.DotNet.IAssemblyInfo.FilePath">
      <summary>
            Gets the assembly main module file path.
            </summary>
      <getter>
        <ensures description="returned path is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned path is not empty" csharp="!result.IsEmpty" vb="Not result.IsEmpty">!result.IsEmpty</ensures>
      </getter>
    </member>
    <member name="P:NDepend.DotNet.IAssemblyInfo.Version">
      <summary>
            Gets the assembly version, the version specified with the System.Reflection.AssemblyVersionAttribute attribute.
            </summary>
      <getter>
        <ensures description="returned version is not null" csharp="result != (decimal)null" vb="result &lt;&gt; ((System.Version)Nothing) ">result != (decimal)null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.DotNet.IAssemblyInfo.IsStrongNamed">
      <summary>
            Gets a value indicating whether this assembly is strong named or not.
            </summary>
    </member>
    <member name="P:NDepend.DotNet.IAssemblyInfo.PDBAvailable">
      <summary>
            Gets a value indicating whether this assembly corresponding PDB file is available or not.
            </summary>
    </member>
    <member name="P:NDepend.DotNet.IAssemblyInfo.TargetRuntime">
      <summary>
            Gets the assembly target runtime version.
            </summary>
      <getter>
        <ensures description="returned version is not null" csharp="result != (decimal)null" vb="result &lt;&gt; ((System.Version)Nothing) ">result != (decimal)null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.DotNet.IAssemblyInfo.PlatformTarget">
      <summary>
            Gets the assembly platform target value.
            </summary>
    </member>
    <member name="P:NDepend.DotNet.IAssemblyInfo.AssembliesReferences">
      <summary>
            Gets a collection of assemblies references, representing assemblies referenced by this assembly.
            </summary>
      <getter>
        <ensures description="returned collection is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.DotNet.IAssemblyReference">
      <summary>
            Represents an assembly reference, extracted from an <see cref="T:NDepend.DotNet.IAssemblyInfo" /> object referencing others assemblies through <see cref="P:NDepend.DotNet.IAssemblyInfo.AssembliesReferences" />.
            </summary>
    </member>
    <member name="P:NDepend.DotNet.IAssemblyReference.FileNameWithoutExtension">
      <summary>
            Gets this assembly reference name.
            </summary>
      <getter>
        <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned string is not empty" csharp="result.Length &gt; 0" vb="result.Length &gt; 0">result.Length &gt; 0</ensures>
      </getter>
    </member>
    <member name="P:NDepend.DotNet.IAssemblyReference.Version">
      <summary>
            Gets this assembly reference version.
            </summary>
      <getter>
        <ensures description="returned version is not null" csharp="result != (decimal)null" vb="result &lt;&gt; ((System.Version)Nothing) ">result != (decimal)null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.DotNet.IDotNetManager">
      <summary>
            Exposes base operations concerning the .NET platforms versions installed, including getting .NET Fx installation directories. An instance of IDotNetManager can be obtained from the property <see cref="T:NDepend.NDependServicesProvider" />.<see cref="P:NDepend.NDependServicesProvider.DotNetManager" />.
            </summary>
    </member>
    <member name="M:NDepend.DotNet.IDotNetManager.IsInstalled(NDepend.DotNet.DotNetProfile,System.Version)">
      <summary>
            Returns true if the .NET profile version specified is installed on the current machine, otherwise returns false.
            </summary>
      <param name="dotNetProfile">The .NET profile target.</param>
      <param name="version">The version demanded, only the version major and minor numbers are taken account.</param>
      <requires description="version must not be null" csharp="version != (decimal)null" vb="version &lt;&gt; ((System.Version)Nothing) ">version != (decimal)null</requires>
    </member>
    <member name="M:NDepend.DotNet.IDotNetManager.GetDotNetProfileVersionsInstalled(NDepend.DotNet.DotNetProfile)">
      <summary>
            Gets the versions installed on the machine, for the specified .NET profile.<br /></summary>
      <returns>
            A sequence a versions of the profile supported on the current machine.<br />
            An empty sequence if no version of <paramref name="dotNetProfile" /> is installed on the current machine.
            </returns>
      <remarks>
            Versions are returned in decreased order, highest version installed first. <br />
            Notes that NDepend needs at least .NET framework v3.5 to run, so the returned version for the <see cref="F:NDepend.DotNet.DotNetProfile.DotNetFramework" /> profile must include v3.5 or above. <br />
            Only the version major and minor numbers are taken account.
            </remarks>
      <param name="dotNetProfile">The .NET profile target.</param>
      <ensures description="returned sequence is not null but can be empty" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.DotNet.IDotNetManager.GetDotNetProfileDirectories(NDepend.DotNet.DotNetProfile,System.Version)">
      <summary>
            Gets a sequence of directory paths containing assemblies of the <paramref name="dotNetProfile" />, specified <paramref name="version" />.
            </summary>
      <returns>
            Directory paths containing assemblies of the <paramref name="dotNetProfile" />, specified <paramref name="version" />.<br />
            An empty sequence if <paramref name="version" /> is not supported.<br />
            Some directories are returned even if <paramref name="version" /> of <paramref name="dotNetProfile" /> is not installed. In such case directories deosn't exist.
            </returns>
      <remarks>
            Only the version major and minor numbers are taken account.<br /></remarks>
      <param name="dotNetProfile">The .NET profile target.</param>
      <param name="version">The version demanded, only the version major and minor numbers are taken account.</param>
      <requires description="version must not be null" csharp="version != (decimal)null" vb="version &lt;&gt; ((System.Version)Nothing) ">version != (decimal)null</requires>
      <ensures description="returned sequence is not null but can be empty" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.DotNet.IDotNetManager.IsAssembly(NDepend.Path.IAbsoluteFilePath)">
      <summary>
            Returns true if the file specified is a main module of a .NET assembly.
            </summary>
      <param name="filePath">The path to the file to test whether it is a main module assembly.</param>
      <requires description="path must not be null" csharp="filePath != null" vb="filePath &lt;&gt; Nothing">filePath != null</requires>
      <requires description="path must not be epty" csharp="!filePath.IsEmpty" vb="Not filePath.IsEmpty">!filePath.IsEmpty</requires>
    </member>
    <member name="M:NDepend.DotNet.IDotNetManager.GetAssemblyInfo(NDepend.Path.IAbsoluteFilePath)">
      <summary>
            Returns assembly information if the file specified is a main module of a .NET assembly, otherwise returns null.
            </summary>
      <param name="filePath">The path to the main module file of a .NET assembly.</param>
    </member>
    <member name="T:NDepend.DotNet.PlatformTarget">
      <summary>
            Represents the platform target option for a .NET assembly.
            </summary>
    </member>
    <member name="F:NDepend.DotNet.PlatformTarget.Unknow">
      <summary>Unknow</summary>
    </member>
    <member name="F:NDepend.DotNet.PlatformTarget.AnyCPU">
      <summary>AnyCPU</summary>
    </member>
    <member name="F:NDepend.DotNet.PlatformTarget.x86">
      <summary>x86</summary>
    </member>
    <member name="F:NDepend.DotNet.PlatformTarget.Itanium">
      <summary>Itanium</summary>
    </member>
    <member name="F:NDepend.DotNet.PlatformTarget.x64">
      <summary>x64</summary>
    </member>
    <member name="T:NDepend.DotNet.VisualStudio.IVisualStudioManager">
      <summary>
            Exposes base operations concerning Visual Studio files, including getting debug assemblies built from a VS solution. A IVisualStudioManager object can be obtained from the property <see cref="T:NDepend.NDependServicesProvider" />.<see cref="P:NDepend.NDependServicesProvider.VisualStudioManager" />.
            </summary>
    </member>
    <member name="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.GetAssembliesFromVisualStudioSolutionOrProject(NDepend.Path.IAbsoluteFilePath)">
      <summary>
            Returns the collection of assemblies file paths compiled in Debug mode, from the Visual Studio solution or project file path.
            </summary>
      <param name="visualStudioSolutionOrProjectFilePath">The path to the Visual Studio solution or project file path.</param>
      <exception cref="T:System.IO.FileNotFoundException">
        <paramref name="visualStudioSolutionOrProjectFilePath" /> doesn't refer to an existing file.</exception>
      <requires description="inputed path cannot be null" csharp="visualStudioSolutionOrProjectFilePath != null" vb="visualStudioSolutionOrProjectFilePath &lt;&gt; Nothing">visualStudioSolutionOrProjectFilePath != null</requires>
      <requires description="inputed path cannot be empty" csharp="!visualStudioSolutionOrProjectFilePath.IsEmpty" vb="Not visualStudioSolutionOrProjectFilePath.IsEmpty">!visualStudioSolutionOrProjectFilePath.IsEmpty</requires>
      <ensures description="returned collection is not null but can be empty" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.GetMostRecentlyUsedVisualStudioSolutionOrProject(NDepend.DotNet.VisualStudio.VisualStudioVersion)">
      <summary>
            Returns the collection of most recently used Visual Studio solutions or projects file paths, for the specified <paramref name="visualStudioVersion" />.
            </summary>
      <remarks>
            This list is stored in the registry and is used by the Start Page of Visual Studio.
            Returns an empty collection if the specified Visual Studio version is not installed.
            </remarks>
      <param name="visualStudioVersion">The Visual Studio version.</param>
      <ensures description="returned collection is not null but can be empty" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.IsVisualStudioVersionIntalled(NDepend.DotNet.VisualStudio.VisualStudioVersion)">
      <summary>
            Returns true if the specified Visual Studio version is installed on the current machine.
            </summary>
      <param name="visualStudioVersion">The Visual Studio version.</param>
    </member>
    <member name="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.ShowDialogSelectVisualStudioSolutionsOrProjects(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)">
      <summary>
            Shows a dialog that lets the user select one or several Visual Studio solutions or projects files.
            </summary>
      <param name="visualStudioSolutionsOrProjectsFilePaths">Visual Studio solutions or projects file paths choosen.</param>
      <returns>True if the user clicked OK, False if the user clicked Cancel</returns>
      <exception cref="T:System.Threading.ThreadStateException">This operation needs the current thread to be a STA thread. To do so, just tag your Main() method with the [STAThread] attribute.</exception>
      <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
      <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
      <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogChooseAnExistingProject(NDepend.Project.IProject@)" />
      <seealso cref="M:NDepend.Analysis.IAnalysisManager.ShowDialogBuildComparison(NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@,NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@)" />
      <ensures description="returned collection is not null if this method returns true" csharp="result ⇒ visualStudioSolutionsOrProjectsFilePaths != null" vb="result Implies visualStudioSolutionsOrProjectsFilePaths &lt;&gt; Nothing">!result || visualStudioSolutionsOrProjectsFilePaths != null</ensures>
    </member>
    <member name="T:NDepend.DotNet.VisualStudio.VisualStudioVersion">
      <summary>
            Represents a Visual Studio version.
            </summary>
    </member>
    <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.Unknown">
      <summary>Unknown</summary>
    </member>
    <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.V7_2003">
      <summary>V7_2003</summary>
    </member>
    <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.V8_2005">
      <summary>V8_2005</summary>
    </member>
    <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.V9_2008">
      <summary>V9_2008</summary>
    </member>
    <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.V10_2010">
      <summary>V10_2010</summary>
    </member>
    <member name="F:NDepend.DotNet.VisualStudio.VisualStudioVersion.V11_2012">
      <summary>V11_2012</summary>
    </member>
    <member name="T:NDepend.CodeQuery.RecordCellValue">
      <summary>
            Represents a code query result record cell value.
            </summary>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellValue.m_UntypedValue">
      <summary>
            This read-only field represents an untyped object that must be down-casted in order to be used.
            </summary>
      <remarks>
            This field has no property getter for optimization reason.
            </remarks>
    </member>
    <member name="F:NDepend.CodeQuery.RecordCellValue.m_RecordCellType">
      <summary>
            This read-only field represents the type of the object <see cref="F:NDepend.CodeQuery.RecordCellValue.m_UntypedValue" />, through the enumeration <see cref="T:NDepend.CodeQuery.RecordCellType" />.
            </summary>
      <remarks>
            This field has no property getter for optimization reason.
            </remarks>
    </member>
    <member name="T:NDepend.CodeQuery.RecordBase">
      <summary>
            The base class for all records classes. A code query result is represented through a sequence of record objects.
            </summary>
      <remarks>
            Having a base class for all records classes is convenient since a code query result is made of a IEnumerable$gt;<see cref="T:NDepend.CodeQuery.RecordBase" />$lt;
            </remarks>
    </member>
    <member name="F:NDepend.CodeQuery.RecordBase.MAX_ARITY">
      <summary>
            Maximum record arity is fixed to 16, meaning a code query cannot returns records with more than 16 cells.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.RecordBase.RecordArity">
      <summary>
            Returns this record class number of cells, from one to 16 cells, this limit is defined by <see cref="F:NDepend.CodeQuery.RecordBase.MAX_ARITY" />.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.RecordBase.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, this.<see cref="P:NDepend.CodeQuery.RecordBase.RecordArity" /> - 1]</exception>
    </member>
    <member name="T:NDepend.CodeQuery.Record`1">
      <summary>
            The record generic class used for code query results made of sequence of records objects with 1 cell each.
            </summary>
      <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
    </member>
    <member name="M:NDepend.CodeQuery.Record`1.#ctor">
      <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`1" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
    <member name="F:NDepend.CodeQuery.Record`1.m_P0">
      <summary>This read-only field represents the record' cell' value of at index 0.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="P:NDepend.CodeQuery.Record`1.RecordArity">
      <summary>
            Returns this record class number of cells, which is 1.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.Record`1.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, 0]</exception>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.Record`2">
      <summary>
            The record generic class used for code query results made of sequence of records objects with 2 cells each.
            </summary>
      <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
      <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
    </member>
    <member name="M:NDepend.CodeQuery.Record`2.#ctor">
      <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`2" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
    <member name="F:NDepend.CodeQuery.Record`2.m_P0">
      <summary>This read-only field represents the record' cell' value of at index 0.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`2.m_P1">
      <summary>This read-only field represents the record' cell' value of at index 1.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="P:NDepend.CodeQuery.Record`2.RecordArity">
      <summary>
            Returns this record class number of cells, which is 2.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.Record`2.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, 1]</exception>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.Record`3">
      <summary>
            The record generic class used for code query results made of sequence of records objects with 3 cells each.
            </summary>
      <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
      <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
      <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
    </member>
    <member name="M:NDepend.CodeQuery.Record`3.#ctor">
      <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`3" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
    <member name="F:NDepend.CodeQuery.Record`3.m_P0">
      <summary>This read-only field represents the record' cell' value of at index 0.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`3.m_P1">
      <summary>This read-only field represents the record' cell' value of at index 1.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`3.m_P2">
      <summary>This read-only field represents the record' cell' value of at index 2.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="P:NDepend.CodeQuery.Record`3.RecordArity">
      <summary>
            Returns this record class number of cells, which is 3.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.Record`3.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, 2]</exception>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.Record`4">
      <summary>
            The record generic class used for code query results made of sequence of records objects with 4 cells each.
            </summary>
      <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
      <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
      <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
      <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
    </member>
    <member name="M:NDepend.CodeQuery.Record`4.#ctor">
      <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`4" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
    <member name="F:NDepend.CodeQuery.Record`4.m_P0">
      <summary>This read-only field represents the record' cell' value of at index 0.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`4.m_P1">
      <summary>This read-only field represents the record' cell' value of at index 1.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`4.m_P2">
      <summary>This read-only field represents the record' cell' value of at index 2.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`4.m_P3">
      <summary>This read-only field represents the record' cell' value of at index 3.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="P:NDepend.CodeQuery.Record`4.RecordArity">
      <summary>
            Returns this record class number of cells, which is 4.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.Record`4.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, 3]</exception>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.Record`5">
      <summary>
            The record generic class used for code query results made of sequence of records objects with 5 cells each.
            </summary>
      <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
      <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
      <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
      <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
      <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
    </member>
    <member name="M:NDepend.CodeQuery.Record`5.#ctor">
      <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`5" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
    <member name="F:NDepend.CodeQuery.Record`5.m_P0">
      <summary>This read-only field represents the record' cell' value of at index 0.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`5.m_P1">
      <summary>This read-only field represents the record' cell' value of at index 1.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`5.m_P2">
      <summary>This read-only field represents the record' cell' value of at index 2.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`5.m_P3">
      <summary>This read-only field represents the record' cell' value of at index 3.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`5.m_P4">
      <summary>This read-only field represents the record' cell' value of at index 4.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="P:NDepend.CodeQuery.Record`5.RecordArity">
      <summary>
            Returns this record class number of cells, which is 5.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.Record`5.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, 4]</exception>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.Record`6">
      <summary>
            The record generic class used for code query results made of sequence of records objects with 6 cells each.
            </summary>
      <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
      <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
      <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
      <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
      <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
      <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
    </member>
    <member name="M:NDepend.CodeQuery.Record`6.#ctor">
      <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`6" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
    <member name="F:NDepend.CodeQuery.Record`6.m_P0">
      <summary>This read-only field represents the record' cell' value of at index 0.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`6.m_P1">
      <summary>This read-only field represents the record' cell' value of at index 1.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`6.m_P2">
      <summary>This read-only field represents the record' cell' value of at index 2.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`6.m_P3">
      <summary>This read-only field represents the record' cell' value of at index 3.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`6.m_P4">
      <summary>This read-only field represents the record' cell' value of at index 4.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`6.m_P5">
      <summary>This read-only field represents the record' cell' value of at index 5.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="P:NDepend.CodeQuery.Record`6.RecordArity">
      <summary>
            Returns this record class number of cells, which is 6.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.Record`6.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, 5]</exception>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.Record`7">
      <summary>
            The record generic class used for code query results made of sequence of records objects with 7 cells each.
            </summary>
      <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
      <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
      <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
      <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
      <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
      <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
      <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
    </member>
    <member name="M:NDepend.CodeQuery.Record`7.#ctor">
      <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`7" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
    <member name="F:NDepend.CodeQuery.Record`7.m_P0">
      <summary>This read-only field represents the record' cell' value of at index 0.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`7.m_P1">
      <summary>This read-only field represents the record' cell' value of at index 1.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`7.m_P2">
      <summary>This read-only field represents the record' cell' value of at index 2.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`7.m_P3">
      <summary>This read-only field represents the record' cell' value of at index 3.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`7.m_P4">
      <summary>This read-only field represents the record' cell' value of at index 4.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`7.m_P5">
      <summary>This read-only field represents the record' cell' value of at index 5.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`7.m_P6">
      <summary>This read-only field represents the record' cell' value of at index 6.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="P:NDepend.CodeQuery.Record`7.RecordArity">
      <summary>
            Returns this record class number of cells, which is 7.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.Record`7.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, 6]</exception>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.Record`8">
      <summary>
            The record generic class used for code query results made of sequence of records objects with 8 cells each.
            </summary>
      <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
      <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
      <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
      <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
      <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
      <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
      <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
      <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
    </member>
    <member name="M:NDepend.CodeQuery.Record`8.#ctor">
      <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`8" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
    <member name="F:NDepend.CodeQuery.Record`8.m_P0">
      <summary>This read-only field represents the record' cell' value of at index 0.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`8.m_P1">
      <summary>This read-only field represents the record' cell' value of at index 1.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`8.m_P2">
      <summary>This read-only field represents the record' cell' value of at index 2.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`8.m_P3">
      <summary>This read-only field represents the record' cell' value of at index 3.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`8.m_P4">
      <summary>This read-only field represents the record' cell' value of at index 4.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`8.m_P5">
      <summary>This read-only field represents the record' cell' value of at index 5.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`8.m_P6">
      <summary>This read-only field represents the record' cell' value of at index 6.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`8.m_P7">
      <summary>This read-only field represents the record' cell' value of at index 7.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="P:NDepend.CodeQuery.Record`8.RecordArity">
      <summary>
            Returns this record class number of cells, which is 8.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.Record`8.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, 7]</exception>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.Record`9">
      <summary>
            The record generic class used for code query results made of sequence of records objects with 9 cells each.
            </summary>
      <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
      <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
      <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
      <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
      <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
      <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
      <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
      <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
      <typeparam name="T8">The type parameter of the cell at index 8.</typeparam>
    </member>
    <member name="M:NDepend.CodeQuery.Record`9.#ctor">
      <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`9" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
    <member name="F:NDepend.CodeQuery.Record`9.m_P0">
      <summary>This read-only field represents the record' cell' value of at index 0.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`9.m_P1">
      <summary>This read-only field represents the record' cell' value of at index 1.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`9.m_P2">
      <summary>This read-only field represents the record' cell' value of at index 2.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`9.m_P3">
      <summary>This read-only field represents the record' cell' value of at index 3.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`9.m_P4">
      <summary>This read-only field represents the record' cell' value of at index 4.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`9.m_P5">
      <summary>This read-only field represents the record' cell' value of at index 5.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`9.m_P6">
      <summary>This read-only field represents the record' cell' value of at index 6.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`9.m_P7">
      <summary>This read-only field represents the record' cell' value of at index 7.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`9.m_P8">
      <summary>This read-only field represents the record' cell' value of at index 8.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="P:NDepend.CodeQuery.Record`9.RecordArity">
      <summary>
            Returns this record class number of cells, which is 9.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.Record`9.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, 8]</exception>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.Record`10">
      <summary>
            The record generic class used for code query results made of sequence of records objects with 10 cells each.
            </summary>
      <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
      <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
      <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
      <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
      <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
      <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
      <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
      <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
      <typeparam name="T8">The type parameter of the cell at index 8.</typeparam>
      <typeparam name="T9">The type parameter of the cell at index 9.</typeparam>
    </member>
    <member name="M:NDepend.CodeQuery.Record`10.#ctor">
      <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`10" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
    <member name="F:NDepend.CodeQuery.Record`10.m_P0">
      <summary>This read-only field represents the record' cell' value of at index 0.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`10.m_P1">
      <summary>This read-only field represents the record' cell' value of at index 1.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`10.m_P2">
      <summary>This read-only field represents the record' cell' value of at index 2.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`10.m_P3">
      <summary>This read-only field represents the record' cell' value of at index 3.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`10.m_P4">
      <summary>This read-only field represents the record' cell' value of at index 4.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`10.m_P5">
      <summary>This read-only field represents the record' cell' value of at index 5.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`10.m_P6">
      <summary>This read-only field represents the record' cell' value of at index 6.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`10.m_P7">
      <summary>This read-only field represents the record' cell' value of at index 7.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`10.m_P8">
      <summary>This read-only field represents the record' cell' value of at index 8.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`10.m_P9">
      <summary>This read-only field represents the record' cell' value of at index 9.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="P:NDepend.CodeQuery.Record`10.RecordArity">
      <summary>
            Returns this record class number of cells, which is 10.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.Record`10.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, 9]</exception>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.Record`11">
      <summary>
            The record generic class used for code query results made of sequence of records objects with 11 cells each.
            </summary>
      <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
      <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
      <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
      <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
      <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
      <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
      <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
      <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
      <typeparam name="T8">The type parameter of the cell at index 8.</typeparam>
      <typeparam name="T9">The type parameter of the cell at index 9.</typeparam>
      <typeparam name="T10">The type parameter of the cell at index 10.</typeparam>
    </member>
    <member name="M:NDepend.CodeQuery.Record`11.#ctor">
      <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`11" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
    <member name="F:NDepend.CodeQuery.Record`11.m_P0">
      <summary>This read-only field represents the record' cell' value of at index 0.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`11.m_P1">
      <summary>This read-only field represents the record' cell' value of at index 1.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`11.m_P2">
      <summary>This read-only field represents the record' cell' value of at index 2.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`11.m_P3">
      <summary>This read-only field represents the record' cell' value of at index 3.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`11.m_P4">
      <summary>This read-only field represents the record' cell' value of at index 4.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`11.m_P5">
      <summary>This read-only field represents the record' cell' value of at index 5.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`11.m_P6">
      <summary>This read-only field represents the record' cell' value of at index 6.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`11.m_P7">
      <summary>This read-only field represents the record' cell' value of at index 7.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`11.m_P8">
      <summary>This read-only field represents the record' cell' value of at index 8.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`11.m_P9">
      <summary>This read-only field represents the record' cell' value of at index 9.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`11.m_P10">
      <summary>This read-only field represents the record' cell' value of at index 10.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="P:NDepend.CodeQuery.Record`11.RecordArity">
      <summary>
            Returns this record class number of cells, which is 11.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.Record`11.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, 10]</exception>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.Record`12">
      <summary>
            The record generic class used for code query results made of sequence of records objects with 12 cells each.
            </summary>
      <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
      <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
      <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
      <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
      <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
      <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
      <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
      <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
      <typeparam name="T8">The type parameter of the cell at index 8.</typeparam>
      <typeparam name="T9">The type parameter of the cell at index 9.</typeparam>
      <typeparam name="T10">The type parameter of the cell at index 10.</typeparam>
      <typeparam name="T11">The type parameter of the cell at index 11.</typeparam>
    </member>
    <member name="M:NDepend.CodeQuery.Record`12.#ctor">
      <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`12" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
    <member name="F:NDepend.CodeQuery.Record`12.m_P0">
      <summary>This read-only field represents the record' cell' value of at index 0.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`12.m_P1">
      <summary>This read-only field represents the record' cell' value of at index 1.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`12.m_P2">
      <summary>This read-only field represents the record' cell' value of at index 2.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`12.m_P3">
      <summary>This read-only field represents the record' cell' value of at index 3.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`12.m_P4">
      <summary>This read-only field represents the record' cell' value of at index 4.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`12.m_P5">
      <summary>This read-only field represents the record' cell' value of at index 5.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`12.m_P6">
      <summary>This read-only field represents the record' cell' value of at index 6.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`12.m_P7">
      <summary>This read-only field represents the record' cell' value of at index 7.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`12.m_P8">
      <summary>This read-only field represents the record' cell' value of at index 8.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`12.m_P9">
      <summary>This read-only field represents the record' cell' value of at index 9.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`12.m_P10">
      <summary>This read-only field represents the record' cell' value of at index 10.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`12.m_P11">
      <summary>This read-only field represents the record' cell' value of at index 11.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="P:NDepend.CodeQuery.Record`12.RecordArity">
      <summary>
            Returns this record class number of cells, which is 12.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.Record`12.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, 11]</exception>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.Record`13">
      <summary>
            The record generic class used for code query results made of sequence of records objects with 13 cells each.
            </summary>
      <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
      <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
      <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
      <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
      <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
      <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
      <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
      <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
      <typeparam name="T8">The type parameter of the cell at index 8.</typeparam>
      <typeparam name="T9">The type parameter of the cell at index 9.</typeparam>
      <typeparam name="T10">The type parameter of the cell at index 10.</typeparam>
      <typeparam name="T11">The type parameter of the cell at index 11.</typeparam>
      <typeparam name="T12">The type parameter of the cell at index 12.</typeparam>
    </member>
    <member name="M:NDepend.CodeQuery.Record`13.#ctor">
      <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`13" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
    <member name="F:NDepend.CodeQuery.Record`13.m_P0">
      <summary>This read-only field represents the record' cell' value of at index 0.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`13.m_P1">
      <summary>This read-only field represents the record' cell' value of at index 1.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`13.m_P2">
      <summary>This read-only field represents the record' cell' value of at index 2.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`13.m_P3">
      <summary>This read-only field represents the record' cell' value of at index 3.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`13.m_P4">
      <summary>This read-only field represents the record' cell' value of at index 4.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`13.m_P5">
      <summary>This read-only field represents the record' cell' value of at index 5.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`13.m_P6">
      <summary>This read-only field represents the record' cell' value of at index 6.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`13.m_P7">
      <summary>This read-only field represents the record' cell' value of at index 7.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`13.m_P8">
      <summary>This read-only field represents the record' cell' value of at index 8.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`13.m_P9">
      <summary>This read-only field represents the record' cell' value of at index 9.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`13.m_P10">
      <summary>This read-only field represents the record' cell' value of at index 10.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`13.m_P11">
      <summary>This read-only field represents the record' cell' value of at index 11.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`13.m_P12">
      <summary>This read-only field represents the record' cell' value of at index 12.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="P:NDepend.CodeQuery.Record`13.RecordArity">
      <summary>
            Returns this record class number of cells, which is 13.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.Record`13.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, 12]</exception>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.Record`14">
      <summary>
            The record generic class used for code query results made of sequence of records objects with 14 cells each.
            </summary>
      <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
      <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
      <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
      <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
      <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
      <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
      <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
      <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
      <typeparam name="T8">The type parameter of the cell at index 8.</typeparam>
      <typeparam name="T9">The type parameter of the cell at index 9.</typeparam>
      <typeparam name="T10">The type parameter of the cell at index 10.</typeparam>
      <typeparam name="T11">The type parameter of the cell at index 11.</typeparam>
      <typeparam name="T12">The type parameter of the cell at index 12.</typeparam>
      <typeparam name="T13">The type parameter of the cell at index 13.</typeparam>
    </member>
    <member name="M:NDepend.CodeQuery.Record`14.#ctor">
      <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`14" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
    <member name="F:NDepend.CodeQuery.Record`14.m_P0">
      <summary>This read-only field represents the record' cell' value of at index 0.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`14.m_P1">
      <summary>This read-only field represents the record' cell' value of at index 1.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`14.m_P2">
      <summary>This read-only field represents the record' cell' value of at index 2.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`14.m_P3">
      <summary>This read-only field represents the record' cell' value of at index 3.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`14.m_P4">
      <summary>This read-only field represents the record' cell' value of at index 4.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`14.m_P5">
      <summary>This read-only field represents the record' cell' value of at index 5.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`14.m_P6">
      <summary>This read-only field represents the record' cell' value of at index 6.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`14.m_P7">
      <summary>This read-only field represents the record' cell' value of at index 7.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`14.m_P8">
      <summary>This read-only field represents the record' cell' value of at index 8.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`14.m_P9">
      <summary>This read-only field represents the record' cell' value of at index 9.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`14.m_P10">
      <summary>This read-only field represents the record' cell' value of at index 10.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`14.m_P11">
      <summary>This read-only field represents the record' cell' value of at index 11.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`14.m_P12">
      <summary>This read-only field represents the record' cell' value of at index 12.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`14.m_P13">
      <summary>This read-only field represents the record' cell' value of at index 13.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="P:NDepend.CodeQuery.Record`14.RecordArity">
      <summary>
            Returns this record class number of cells, which is 14.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.Record`14.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, 13]</exception>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.Record`15">
      <summary>
            The record generic class used for code query results made of sequence of records objects with 15 cells each.
            </summary>
      <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
      <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
      <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
      <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
      <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
      <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
      <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
      <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
      <typeparam name="T8">The type parameter of the cell at index 8.</typeparam>
      <typeparam name="T9">The type parameter of the cell at index 9.</typeparam>
      <typeparam name="T10">The type parameter of the cell at index 10.</typeparam>
      <typeparam name="T11">The type parameter of the cell at index 11.</typeparam>
      <typeparam name="T12">The type parameter of the cell at index 12.</typeparam>
      <typeparam name="T13">The type parameter of the cell at index 13.</typeparam>
      <typeparam name="T14">The type parameter of the cell at index 14.</typeparam>
    </member>
    <member name="M:NDepend.CodeQuery.Record`15.#ctor">
      <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`15" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
    <member name="F:NDepend.CodeQuery.Record`15.m_P0">
      <summary>This read-only field represents the record' cell' value of at index 0.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`15.m_P1">
      <summary>This read-only field represents the record' cell' value of at index 1.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`15.m_P2">
      <summary>This read-only field represents the record' cell' value of at index 2.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`15.m_P3">
      <summary>This read-only field represents the record' cell' value of at index 3.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`15.m_P4">
      <summary>This read-only field represents the record' cell' value of at index 4.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`15.m_P5">
      <summary>This read-only field represents the record' cell' value of at index 5.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`15.m_P6">
      <summary>This read-only field represents the record' cell' value of at index 6.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`15.m_P7">
      <summary>This read-only field represents the record' cell' value of at index 7.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`15.m_P8">
      <summary>This read-only field represents the record' cell' value of at index 8.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`15.m_P9">
      <summary>This read-only field represents the record' cell' value of at index 9.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`15.m_P10">
      <summary>This read-only field represents the record' cell' value of at index 10.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`15.m_P11">
      <summary>This read-only field represents the record' cell' value of at index 11.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`15.m_P12">
      <summary>This read-only field represents the record' cell' value of at index 12.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`15.m_P13">
      <summary>This read-only field represents the record' cell' value of at index 13.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`15.m_P14">
      <summary>This read-only field represents the record' cell' value of at index 14.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="P:NDepend.CodeQuery.Record`15.RecordArity">
      <summary>
            Returns this record class number of cells, which is 15.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.Record`15.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, 14]</exception>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.CodeQuery.Record`16">
      <summary>
            The record generic class used for code query results made of sequence of records objects with 16 cells each.
            </summary>
      <typeparam name="T0">The type parameter of the cell at index 0.</typeparam>
      <typeparam name="T1">The type parameter of the cell at index 1.</typeparam>
      <typeparam name="T2">The type parameter of the cell at index 2.</typeparam>
      <typeparam name="T3">The type parameter of the cell at index 3.</typeparam>
      <typeparam name="T4">The type parameter of the cell at index 4.</typeparam>
      <typeparam name="T5">The type parameter of the cell at index 5.</typeparam>
      <typeparam name="T6">The type parameter of the cell at index 6.</typeparam>
      <typeparam name="T7">The type parameter of the cell at index 7.</typeparam>
      <typeparam name="T8">The type parameter of the cell at index 8.</typeparam>
      <typeparam name="T9">The type parameter of the cell at index 9.</typeparam>
      <typeparam name="T10">The type parameter of the cell at index 10.</typeparam>
      <typeparam name="T11">The type parameter of the cell at index 11.</typeparam>
      <typeparam name="T12">The type parameter of the cell at index 12.</typeparam>
      <typeparam name="T13">The type parameter of the cell at index 13.</typeparam>
      <typeparam name="T14">The type parameter of the cell at index 14.</typeparam>
      <typeparam name="T15">The type parameter of the cell at index 15.</typeparam>
    </member>
    <member name="M:NDepend.CodeQuery.Record`16.#ctor">
      <summary>
            Create an instance of <see cref="T:NDepend.CodeQuery.Record`16" />. This constructor is not intended to be used in your code.
            </summary>
            Parameterless ctor to call Activator.CreateInstance() on it. Further ctor call are made from CreateBrotherInstance().
        </member>
    <member name="F:NDepend.CodeQuery.Record`16.m_P0">
      <summary>This read-only field represents the record' cell' value of at index 0.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`16.m_P1">
      <summary>This read-only field represents the record' cell' value of at index 1.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`16.m_P2">
      <summary>This read-only field represents the record' cell' value of at index 2.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`16.m_P3">
      <summary>This read-only field represents the record' cell' value of at index 3.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`16.m_P4">
      <summary>This read-only field represents the record' cell' value of at index 4.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`16.m_P5">
      <summary>This read-only field represents the record' cell' value of at index 5.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`16.m_P6">
      <summary>This read-only field represents the record' cell' value of at index 6.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`16.m_P7">
      <summary>This read-only field represents the record' cell' value of at index 7.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`16.m_P8">
      <summary>This read-only field represents the record' cell' value of at index 8.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`16.m_P9">
      <summary>This read-only field represents the record' cell' value of at index 9.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`16.m_P10">
      <summary>This read-only field represents the record' cell' value of at index 10.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`16.m_P11">
      <summary>This read-only field represents the record' cell' value of at index 11.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`16.m_P12">
      <summary>This read-only field represents the record' cell' value of at index 12.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`16.m_P13">
      <summary>This read-only field represents the record' cell' value of at index 13.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`16.m_P14">
      <summary>This read-only field represents the record' cell' value of at index 14.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="F:NDepend.CodeQuery.Record`16.m_P15">
      <summary>This read-only field represents the record' cell' value of at index 15.</summary>
      <remarks>This field has no property getter for optimization reason.</remarks>
    </member>
    <member name="P:NDepend.CodeQuery.Record`16.RecordArity">
      <summary>
            Returns this record class number of cells, which is 16.
            </summary>
    </member>
    <member name="P:NDepend.CodeQuery.Record`16.Item(System.Int32)">
      <summary>
            Returns this record cell value, for the cell defined at the zero-based index <paramref name="index" />.
            </summary>
      <param name="index">The zero-based index of the cell.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not in the range [0, 15]</exception>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.NDependServicesProvider">
      <summary>
            Create an instance of this class once in your program, to obtain NDepend.API services managers objects.
            </summary>
      <remarks>
            If you prefer you can technically create several instances of this class since it is stateless.
            </remarks>
    </member>
    <member name="P:NDepend.NDependServicesProvider.ProjectManager">
      <summary>
            Gets a <see cref="T:NDepend.Project.IProjectManager" /> object.
            </summary>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.NDependServicesProvider.AnalysisManager">
      <summary>
            Gets a <see cref="T:NDepend.Analysis.IAnalysisManager" /> object.
            </summary>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.NDependServicesProvider.VisualStudioManager">
      <summary>
            Gets a <see cref="T:NDepend.DotNet.VisualStudio.IVisualStudioManager" /> object.
            </summary>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.NDependServicesProvider.DotNetManager">
      <summary>
            Gets a <see cref="T:NDepend.DotNet.IDotNetManager" /> object.
            </summary>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.Path.ExtensionMethodsOnPathsCollection">
      <summary>
            Extension methods helpers on collection of paths.
            </summary>
    </member>
    <member name="M:NDepend.Path.ExtensionMethodsOnPathsCollection.ContainsSamePathsThan``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``0})">
      <summary>
            Determine if this collection1 and collection2 contain the same set of paths.
            </summary>
      <remarks>
            Collections can contain null or empty paths.
            </remarks>
      <typeparam name="T">The path type, any interface type implementing IPath</typeparam>
      <param name="collection1">This collection of paths.</param>
      <param name="collection2">The other collection of paths.</param>
      <returns>
            true if collection2 contains the same set of path than this collection1.
            true also, if this collection1 and collection2 are both null.
            true also, if this collection1 and collection2 are both empty.
            </returns>
    </member>
    <member name="M:NDepend.Path.ExtensionMethodsOnPathsCollection.TryGetCommonRootDirectory(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteDirectoryPath},NDepend.Path.IAbsoluteDirectoryPath@)">
      <summary>
            Find the common root directory of all directories of this collection.
            </summary>
      <remarks>
            A return value indicates whether a common root directory has been found.
            A common root directory cannot be found if at least two directories path on two different drives are in this collection.
            If the collection contains one null or empty path, a common root directory cannot be found.
            </remarks>
      <param name="collection">This collection of directories absolute paths.</param>
      <param name="commonRootDirectory">The common root directory if it has been found.</param>
      <returns>
            true if a common root directory has been found, else returns false.
            </returns>
      <requires description="collection must not be null" csharp="collection != null" vb="collection &lt;&gt; Nothing">collection != null</requires>
    </member>
    <member name="T:NDepend.Path.IDirectoryPath">
      <summary>
            Represents a path to a directory on file system.
            </summary>
      <remarks>
            The path can be relative or absolute.
            The extension method <see cref="M:NDepend.Path.PathHelpers.ToDirectoryPath(System.String)" /> can be called to create a new IDirectoryPath object from a string.
            </remarks>
    </member>
    <member name="T:NDepend.Path.IPath">
      <summary>
            Represents a path, absolute or relative, to a file or to a directory.
            </summary>
      <remarks>
            Equals(), ToString() and GetHashCode() operations are overriden from System.Object and are supported by all paths objects.
            Equals() and GetHashCode() are string case insensitive.
            </remarks>
    </member>
    <member name="M:NDepend.Path.IPath.HasThisPathMode(NDepend.Path.PathMode)">
      <summary>Gets a value indicating whether this path has the path mode (relative or absolute) <paramref name="pathMode" /></summary>
      <remarks>
            Since the the <paramref name="pathMode" /> value can be variable, this method can favor a generic way of coding in certain situations, by replacing calls to <see cref="P:NDepend.Path.IPath.IsAbsolutePath" /> and <see cref="P:NDepend.Path.IPath.IsRelativePath" />.
            </remarks>
      <returns>
            true if this path is a relative path and <paramref name="pathMode" /> is equal to <see cref="F:NDepend.Path.PathMode.Relative" />,
            true if this path is an absolute path and <paramref name="pathMode" /> is equal to <see cref="F:NDepend.Path.PathMode.Absolute" />,
            else returns false.
            </returns>
    </member>
    <member name="M:NDepend.Path.IPath.NotEquals(System.Object)">
      <summary>Returns true if obj is null, is not an IPath, or is an IPath representing a different path than this path (case insensitive).</summary>
      <remarks>
            This method is the opposite of the IPath.Equals() method, overriden from System.Object.
            It can be used to make the negation in !Equals more obvious.
            </remarks>
    </member>
    <member name="P:NDepend.Path.IPath.IsEmpty">
      <summary>Gets a value indicating whether this path is an empty path.</summary>
      <returns>true if this path is an empty path, else returns false.</returns>
      <seealso cref="F:NDepend.Path.PathHelpers.EmptyAbsoluteDirectoryPath" />
      <seealso cref="F:NDepend.Path.PathHelpers.EmptyAbsoluteFilePath" />
      <seealso cref="F:NDepend.Path.PathHelpers.EmptyRelativeDirectoryPath" />
      <seealso cref="F:NDepend.Path.PathHelpers.EmptyRelativeFilePath" />
    </member>
    <member name="P:NDepend.Path.IPath.IsAbsolutePath">
      <summary>Gets a value indicating whether this path is an absolute path.</summary>
      <remarks>
            An absolute path can be down-casted to <see cref="T:NDepend.Path.IAbsolutePath" />.
            A <see cref="T:NDepend.Path.IAbsolutePath" /> can be down-casted to a <see cref="T:NDepend.Path.IAbsoluteFilePath" /> or (exclusive) a <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" />.
            </remarks>
      <returns>true if this path is an absolute path, else returns false.</returns>
    </member>
    <member name="P:NDepend.Path.IPath.IsRelativePath">
      <summary>Gets a value indicating whether this path is a relative path.</summary>
      <remarks>
            A relative path can be down-casted to <see cref="T:NDepend.Path.IRelativePath" />.
            A <see cref="T:NDepend.Path.IRelativePath" /> can be down-casted to a <see cref="T:NDepend.Path.IRelativeFilePath" /> or (exclusive) a <see cref="T:NDepend.Path.IRelativeDirectoryPath" />.
            </remarks>
      <returns>true if this path is a relative path, else returns false.</returns>
    </member>
    <member name="P:NDepend.Path.IPath.IsDirectoryPath">
      <summary>Gets a value indicating whether this path is a directory path.</summary>
      <remarks>
            A relative path can be down-casted to <see cref="T:NDepend.Path.IDirectoryPath" />.
            A <see cref="T:NDepend.Path.IDirectoryPath" /> can be down-casted to a <see cref="T:NDepend.Path.IRelativeDirectoryPath" /> or (exclusive) a <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" />.
            </remarks>
      <returns>true if this path is a directory path, else returns false.</returns>
    </member>
    <member name="P:NDepend.Path.IPath.IsFilePath">
      <summary>Gets a value indicating whether this path is a file path.</summary>
      <remarks>
            A relative path can be down-casted to <see cref="T:NDepend.Path.IFilePath" />.
            A <see cref="T:NDepend.Path.IFilePath" /> can be down-casted to a <see cref="T:NDepend.Path.IRelativeFilePath" /> or (exclusive) a <see cref="T:NDepend.Path.IAbsoluteFilePath" />.
            </remarks>
      <returns>true if this path is a file path, else returns false.</returns>
    </member>
    <member name="P:NDepend.Path.IPath.ParentDirectoryPath">
      <summary>Returns the parent directory path.</summary>
      <exception cref="T:System.InvalidOperationException">
            This path doesn't have a parent directory path.
            Root directories representing a drive, like C: or D: don't have a parent directory path.
            Relative path like ".\" or "..\" don't have a parent directory path.
            An empty path don't have a parent directory path.
            A non-empty file path necessarily have a parent directory path.
            </exception>
    </member>
    <member name="P:NDepend.Path.IPath.HasParentDirectory">
      <summary>Gets a value indicating whether this path has a parent directory path</summary>
      <remarks>
            Root directories representing a drive, like C: or D: don't have a parent directory path.
            Relative path like ".\" or "..\" don't have a parent directory path.
            An empty path don't have a parent directory path.
            A non-empty file path necessarily have a parent directory path.
            </remarks>
      <returns>true if this path has a parent directory path, else returns false.</returns>
    </member>
    <member name="P:NDepend.Path.IDirectoryPath.DirectoryName">
      <summary>
            Gets a string representing the directory name.
            </summary>
      <remarks>
            If the directory is a root volume, like C:, returns an empty string.
            </remarks>
      <returns>
            The directory name.
            </returns>
    </member>
    <member name="T:NDepend.Path.IAbsoluteDirectoryPath">
      <summary>
            Represents an absolute path to a directory on file system.
            </summary>
      <remarks>
            The path represented can exist or not.
            The extension method <see cref="M:NDepend.Path.PathHelpers.ToAbsoluteDirectoryPath(System.String)" /> can be called to create a new IAbsoluteDirectoryPath object from a string.
            </remarks>
    </member>
    <member name="T:NDepend.Path.IAbsolutePath">
      <summary>
            Represents an absolute path to a file or directory on file system.
            </summary>
    </member>
    <member name="M:NDepend.Path.IAbsolutePath.OnSameDriveThan(NDepend.Path.IAbsolutePath)">
      <summary>
            Gets a value indicating whether this absolute path is on the same drive as <paramref name="pathAbsoluteOther" />.
            </summary>
      <param name="pathAbsoluteOther">The other absolute path.</param>
      <returns>true if this absolute path is on the same drive as <paramref name="pathAbsoluteOther" />, else returns false.</returns>
    </member>
    <member name="M:NDepend.Path.IAbsolutePath.GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
      <summary>
            Returns a new relative path representing this relative path to <paramref name="pivotDirectory" />.
            </summary>
      <remarks>
            If this path is "C:\Dir1\Dir2\File.txt" and <paramref name="pivotDirectory" /> is "C:\Dir1\Dir3", the returned relative directory is a IRelativeFilePath "..\Dir2\File.txt".
            If this path is "C:\Dir1\Dir2" and <paramref name="pivotDirectory" /> is "C:\Dir1\Dir3", the returned relative directory is a IRelativeDirectoryPath "..\Dir2".
            This method is hidden in <see cref="T:NDepend.Path.IAbsoluteFilePath" /> and <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" /> to get a typed result.
            This file or directory nor <paramref name="pivotDirectory" /> need to exist for this operation to complete properly.
            </remarks>
      <param name="pivotDirectory">The pivot directory from which the relative path is computed.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="pivotDirectory" /> is not on the same drive as this file's drive.</exception>
      <exception cref="T:System.InvalidOperationException">This file directory path is empty.</exception>
      <requires description="pivotDirectory must not be null" csharp="pivotDirectory != null" vb="pivotDirectory &lt;&gt; Nothing">pivotDirectory != null</requires>
      <requires description="pivotDirectory must not be empty" csharp="!pivotDirectory.IsEmpty" vb="Not pivotDirectory.IsEmpty">!pivotDirectory.IsEmpty</requires>
    </member>
    <member name="M:NDepend.Path.IAbsolutePath.CanGetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
      <summary>
            Gets a value indicating whether a relative path representing this path can be computed from <paramref name="pivotDirectory" />.
            </summary>
      <remarks>
            A relative path cannot be resolved from a null or empty <paramref name="pivotDirectory" />. 
            Also, a relative path cannot be computed if <paramref name="pivotDirectory" /> is not on the same drive as this absolute path's drive.
            </remarks>
      <param name="pivotDirectory">The pivot directory from which the absolute path should be computed.</param>
      <returns>true if a relative path representing this path can be computed from <paramref name="pivotDirectory" />, else returns false.</returns>
    </member>
    <member name="P:NDepend.Path.IAbsolutePath.Drive">
      <summary>
            Returns an <see cref="T:NDepend.Path.IDrive" /> object representing the drive of this absolute path.
            </summary>
      <exception cref="T:System.InvalidOperationException">is thrown if this absolute path is empty</exception>
    </member>
    <member name="P:NDepend.Path.IAbsolutePath.Exists">
      <summary>
            Gets a value indicating whether the file or directory represented by this absolute path exists.
            </summary>
      <returns>
            true if the file or directory represented by this absolute path exists.
            </returns>
    </member>
    <member name="M:NDepend.Path.IAbsoluteDirectoryPath.GetBrotherFileWithName(System.String)">
      <summary>
            Returns a new absolute file path representing a file with name <paramref name="fileName" />, located in the parent's directory of this directory.
            </summary>
      <remarks>This directory nor the returned file need to exist for this operation to complete properly.</remarks>
      <param name="fileName">The brother file name.</param>
      <exception cref="T:System.InvalidOperationException">This absolute directory path is empty or doesn't have a parent directory.</exception>
      <requires description="fileName must not be null" csharp="fileName != null" vb="fileName &lt;&gt; Nothing">fileName != null</requires>
      <requires description="fileName must not be empty" csharp="fileName.Length &gt; 0" vb="fileName.Length &gt; 0">fileName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.IAbsoluteDirectoryPath.GetBrotherDirectoryWithName(System.String)">
      <summary>
            Returns a new absolute directory path representing a directory with name <paramref name="directoryName" />, located in the parent's directory of this directory.
            </summary>
      <remarks>This directory nor the returned directory need to exist for this operation to complete properly.</remarks>
      <param name="directoryName">The brother directory name.</param>
      <exception cref="T:System.InvalidOperationException">This absolute directory path is empty or doesn't have a parent directory.</exception>
      <requires description="directoryName must not be null" csharp="directoryName != null" vb="directoryName &lt;&gt; Nothing">directoryName != null</requires>
      <requires description="directoryName must not be empty" csharp="directoryName.Length &gt; 0" vb="directoryName.Length &gt; 0">directoryName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.IAbsoluteDirectoryPath.GetChildFileWithName(System.String)">
      <summary>
            Returns a new absolute file path representing a file with name <paramref name="fileName" />, located in this directory.
            </summary>
      <remarks>This directory nor the returned file need to exist for this operation to complete properly.</remarks>
      <param name="fileName">The child file name.</param>
      <exception cref="T:System.InvalidOperationException">This absolute directory path is empty.</exception>
      <requires description="fileName must not be null" csharp="fileName != null" vb="fileName &lt;&gt; Nothing">fileName != null</requires>
      <requires description="fileName must not be empty" csharp="fileName.Length &gt; 0" vb="fileName.Length &gt; 0">fileName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.IAbsoluteDirectoryPath.GetChildDirectoryWithName(System.String)">
      <summary>
            Returns a new absolute directory path representing a directory with name <paramref name="directoryName" />, located in this directory.
            </summary>
      <remarks>This directory nor the returned directory need to exist for this operation to complete properly.</remarks>
      <param name="directoryName">The child directory name.</param>
      <exception cref="T:System.InvalidOperationException">This absolute directory path is empty or doesn't have a parent directory.</exception>
      <requires description="directoryName must not be null" csharp="directoryName != null" vb="directoryName &lt;&gt; Nothing">directoryName != null</requires>
      <requires description="directoryName must not be empty" csharp="directoryName.Length &gt; 0" vb="directoryName.Length &gt; 0">directoryName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.IAbsoluteDirectoryPath.IsChildDirectoryOf(NDepend.Path.IAbsoluteDirectoryPath)">
      <summary>
            Gets a value indicating whether this directory is a child directory of <paramref name="parentDirectory" />.
            </summary>
      <remarks>This directory nor <paramref name="parentDirectory" /> need to exist for this operation to complete properly.</remarks>
      <param name="parentDirectory">The parent directory.</param>
      <returns>true of this directory is a child directory of <paramref name="parentDirectory" />, else false.</returns>
      <requires description="parentDir must not be null" csharp="parentDirectory != null" vb="parentDirectory &lt;&gt; Nothing">parentDirectory != null</requires>
      <requires description="parentDir must not be empty" csharp="!parentDirectory.IsEmpty" vb="Not parentDirectory.IsEmpty">!parentDirectory.IsEmpty</requires>
    </member>
    <member name="M:NDepend.Path.IAbsoluteDirectoryPath.GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
      <summary>
            Compute this directory as relative from <paramref name="pivotDirectory" />. If this directory is "C:\Dir1\Dir2" and <paramref name="pivotDirectory" /> is "C:\Dir1\Dir3", the returned relative directory is "..\Dir2".
            </summary>
      <remarks>
            This directory nor <paramref name="pivotDirectory" /> need to exist for this operation to complete properly.
            </remarks>
      <param name="pivotDirectory">The pivot directory from which the relative path is computed.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="pivotDirectory" /> is not on the same drive as this directory's drive.</exception>
      <exception cref="T:System.InvalidOperationException">This absolute directory path is empty.</exception>
      <returns>A new relative directory path representing this directory relative to <paramref name="pivotDirectory" />.</returns>
      <requires description="pivotDirectory must not be null" csharp="pivotDirectory != null" vb="pivotDirectory &lt;&gt; Nothing">pivotDirectory != null</requires>
      <requires description="pivotDirectory must not be empty" csharp="!pivotDirectory.IsEmpty" vb="Not pivotDirectory.IsEmpty">!pivotDirectory.IsEmpty</requires>
    </member>
    <member name="P:NDepend.Path.IAbsoluteDirectoryPath.DirectoryInfo">
      <summary>
            Returns a DirectoryInfo object representing this absolute directory path.
            </summary>
      <exception cref="T:System.IO.DirectoryNotFoundException">This absolute directory path doesn't refer to an existing directory.</exception>
      <exception cref="T:System.InvalidOperationException">This absolute directory path is empty.</exception>
      <seealso cref="P:NDepend.Path.IAbsolutePath.Exists" />
    </member>
    <member name="P:NDepend.Path.IAbsoluteDirectoryPath.ChildrenFilesPath">
      <summary>
            Returns a collection of file paths absolute matching files contained in this directory.
            </summary>
      <exception cref="T:System.IO.DirectoryNotFoundException">This absolute directory path doesn't refer to an existing directory.</exception>
      <exception cref="T:System.InvalidOperationException">This absolute directory path is empty.</exception>
      <seealso cref="P:NDepend.Path.IAbsolutePath.Exists" />
    </member>
    <member name="P:NDepend.Path.IAbsoluteDirectoryPath.ChildrenDirectoriesPath">
      <summary>
            Returns a collection of directory paths absolute matching directories contained in this directory.
            </summary>
      <exception cref="T:System.IO.DirectoryNotFoundException">This absolute directory path doesn't refer to an existing directory.</exception>
      <exception cref="T:System.InvalidOperationException">This absolute directory path is empty.</exception>
      <seealso cref="P:NDepend.Path.IAbsolutePath.Exists" />
    </member>
    <member name="P:NDepend.Path.IAbsoluteDirectoryPath.ParentDirectoryPath">
      <summary>
            Returns a new absolute directory path refering to the parent directory of this directory.
            </summary>
      <remarks>
            This directory nor its parent directory need to exist for this operation to complete properly.
            Only root directories representing a drive, like C: or D: don't have a parent directory path.
            </remarks>
      <exception cref="T:System.InvalidOperationException">This absolute directory path is empty or doesn't have a parent directory.</exception>
    </member>
    <member name="T:NDepend.Path.IRelativeDirectoryPath">
      <summary>
            Represents a relative directory path.
            </summary>
      <remarks>
            The extension method <see cref="M:NDepend.Path.PathHelpers.ToRelativeDirectoryPath(System.String)" /> can be called to create a new IRelativeDirectoryPath object from a string.
            </remarks>
    </member>
    <member name="T:NDepend.Path.IRelativePath">
      <summary>
            Represents a relative path to a file or directory. 
            </summary>
    </member>
    <member name="M:NDepend.Path.IRelativePath.GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
      <summary>
            A new absolute path representing this relative path resolved from <paramref name="pivotDirectory" />.
            </summary>
      <remarks>
            If this path is "..\Dir2\File.txt" and <paramref name="pivotDirectory" /> is "C:\Dir1\Dir3", the returned relative file is "C:\Dir1\Dir2\File.txt".
            If this path is "..\Dir2" and <paramref name="pivotDirectory" /> is "C:\Dir1\Dir3", the returned relative file is "C:\Dir1\Dir2".
            This method is hidden in <see cref="T:NDepend.Path.IAbsoluteFilePath" /> and <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" /> to get a typed result.
            The returned file or directory path nor <paramref name="pivotDirectory" /> need to exist for this operation to complete properly.
            </remarks>
      <param name="pivotDirectory">The pivot directory from which the absolute path is computed.</param>
      <exception cref="T:System.ArgumentException">
            An absolute path cannot be resolved from <paramref name="pivotDirectory" />. 
            This can happen for example if <paramref name="pivotDirectory" /> is "C:\Dir1" and this relative path is "..\..\Dir2".
            </exception>
      <exception cref="T:System.InvalidOperationException">This relative file path is empty.</exception>
      <returns>A new absolute file path representing this relative file resolved from <paramref name="pivotDirectory" />.</returns>
      <requires description="pivotDirectory must not be null" csharp="pivotDirectory != null" vb="pivotDirectory &lt;&gt; Nothing">pivotDirectory != null</requires>
      <requires description="pivotDirectory must not be empty" csharp="!pivotDirectory.IsEmpty" vb="Not pivotDirectory.IsEmpty">!pivotDirectory.IsEmpty</requires>
    </member>
    <member name="M:NDepend.Path.IRelativePath.CanGetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
      <summary>
            Gets a value indicating whether this relative path can be resolved from <paramref name="pivotDirectory" />.
            </summary>
      <remarks>
            An absolute path cannot be resolved from a null or empty <paramref name="pivotDirectory" />. 
            Also, an absolute path cannot be resolved for example if <paramref name="pivotDirectory" /> is "C:\Dir1" and this relative path is "..\..\Dir2".
            </remarks>
      <param name="pivotDirectory">The pivot directory from which the absolute path should be computed.</param>
      <returns>true if this relative path can be resolved from <paramref name="pivotDirectory" />, else returns false.</returns>
    </member>
    <member name="M:NDepend.Path.IRelativeDirectoryPath.GetBrotherFileWithName(System.String)">
      <summary>
            Returns a new relative file path representing a file with name <paramref name="fileName" />, located in the parent's directory of this directory.
            </summary>
      <param name="fileName">The brother file name.</param>
      <exception cref="T:System.InvalidOperationException">This relative directory path is empty or doesn't have a parent directory.</exception>
      <requires description="fileName is null" csharp="fileName != null" vb="fileName &lt;&gt; Nothing">fileName != null</requires>
      <requires description="fileName must not be empty" csharp="fileName.Length &gt; 0" vb="fileName.Length &gt; 0">fileName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.IRelativeDirectoryPath.GetBrotherDirectoryWithName(System.String)">
      <summary>
            Returns a new relative directory path representing a directory with name <paramref name="directoryName" />, located in the parent's directory of this directory.
            </summary>
      <param name="directoryName">The brother directory name.</param>
      <exception cref="T:System.InvalidOperationException">This relative directory path is empty or doesn't have a parent directory.</exception>
      <requires description="directoryName is null" csharp="directoryName != null" vb="directoryName &lt;&gt; Nothing">directoryName != null</requires>
      <requires description="directoryName must not be empty" csharp="directoryName.Length &gt; 0" vb="directoryName.Length &gt; 0">directoryName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.IRelativeDirectoryPath.GetChildFileWithName(System.String)">
      <summary>
            Returns a new relative file path representing a file with name <paramref name="fileName" />, located in this directory.
            </summary>
      <param name="fileName">The child file name.</param>
      <exception cref="T:System.InvalidOperationException">This relative directory path is empty.</exception>
      <requires description="fileName is null" csharp="fileName != null" vb="fileName &lt;&gt; Nothing">fileName != null</requires>
      <requires description="fileName must not be empty" csharp="fileName.Length &gt; 0" vb="fileName.Length &gt; 0">fileName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.IRelativeDirectoryPath.GetChildDirectoryWithName(System.String)">
      <summary>
            Returns a new relative directory path representing a directory with name <paramref name="directoryName" />, located in this directory.
            </summary>
      <param name="directoryName">The child directory name.</param>
      <exception cref="T:System.InvalidOperationException">This absolute directory path is empty.</exception>
      <requires description="directoryName is null" csharp="directoryName != null" vb="directoryName &lt;&gt; Nothing">directoryName != null</requires>
      <requires description="directoryName must not be empty" csharp="directoryName.Length &gt; 0" vb="directoryName.Length &gt; 0">directoryName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.IRelativeDirectoryPath.GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
      <summary>
            Resolve this relative directory from <paramref name="pivotDirectory" />. If this directory is "..\Dir2" and <paramref name="pivotDirectory" /> is "C:\Dir1\Dir3", the returned absolute directory is "C:\Dir1\Dir2".
            </summary>
      <remarks>
            The returned directory nor <paramref name="pivotDirectory" /> need to exist for this operation to complete properly.
            </remarks>
      <param name="pivotDirectory">The pivot directory from which the absolute path is computed.</param>
      <exception cref="T:System.InvalidOperationException">This relative directory path is empty.</exception>
      <exception cref="T:System.ArgumentException">
            An absolute path cannot be resolved from <paramref name="pivotDirectory" />. 
            This can happen for example if <paramref name="pivotDirectory" /> is "C:\Dir1" and this relative directory path is "..\..\Dir2".
            </exception>
      <returns>A new absolute directory path representing this relative directory resolved from <paramref name="pivotDirectory" />.</returns>
      <requires description="pivotDirectory is null" csharp="pivotDirectory != null" vb="pivotDirectory &lt;&gt; Nothing">pivotDirectory != null</requires>
      <requires description="pivotDirectory must not be empty" csharp="!pivotDirectory.IsEmpty" vb="Not pivotDirectory.IsEmpty">!pivotDirectory.IsEmpty</requires>
    </member>
    <member name="T:NDepend.Path.IDrive">
      <summary>
            Represents a drive on file system.
            </summary>
    </member>
    <member name="M:NDepend.Path.IDrive.NotEquals(System.Object)">
      <summary>Returns true if obj is null, is not an IDrive, or is an IDrive representing a different drive than this drive (case insensitive).</summary>
    </member>
    <member name="P:NDepend.Path.IDrive.Letter">
      <summary>
            Returns the letter character of this drive.
            </summary>
      <remarks>
            The letter returned can be upper or lower case.
            </remarks>
    </member>
    <member name="P:NDepend.Path.IDrive.DriveInfo">
      <summary>
            Returns a DriveInfo object representing this drive.
            </summary>
      <exception cref="T:System.IO.DriveNotFoundException">This drive doesn't refer to an existing drive.</exception>
      <seealso cref="P:NDepend.Path.IAbsoluteDirectoryPath.DirectoryInfo" />
      <seealso cref="P:NDepend.Path.IAbsoluteFilePath.FileInfo" />
    </member>
    <member name="T:NDepend.Path.IFilePath">
      <summary>
            Represents a path to a file on file system.
            </summary>
      <remarks>
            The path can be relative or absolute.
            In case of an absolute IFilePath, the path represented can exist or not.
            The extension method <see cref="M:NDepend.Path.PathHelpers.ToFilePath(System.String)" /> can be called to create a new IFilePath object from a string.
            </remarks>
    </member>
    <member name="M:NDepend.Path.IFilePath.HasExtension(System.String)">
      <summary>
            Gets a value indicating whether this file name has the extension, <paramref name="extension" />.
            </summary>
      <param name="extension">The file extension. It must begin with a dot followed by one or many characters.</param>
      <returns>true if this file name has the extension, <paramref name="extension" />.</returns>
      <requires description="extension must not be null" csharp="extension != null" vb="extension &lt;&gt; Nothing">extension != null</requires>
      <requires description="extension must have at least two characters" csharp="extension.Length &gt;= 2" vb="extension.Length &gt;= 2">extension.Length &gt;= 2</requires>
      <requires description="extension first character must be a dot" csharp="extension.Chars[0] == '.'" vb="extension.Chars[0] = '.'">extension.Chars[0] == '.'</requires>
    </member>
    <member name="P:NDepend.Path.IFilePath.FileName">
      <summary>
            Gets a string representing the file name with its extension if any.
            </summary>
      <returns>
            Returns the file name with its extension if any.
            </returns>
    </member>
    <member name="P:NDepend.Path.IFilePath.FileNameWithoutExtension">
      <summary>
            Gets a string representing the file name without its extension if any.
            </summary>
      <returns>
            Returns the file name without its extension if any.
            </returns>
    </member>
    <member name="P:NDepend.Path.IFilePath.FileExtension">
      <summary>
            Gets a string representing the file name extension.
            </summary>
      <returns>
            Returns the file name extension if any, else returns an empty string.
            </returns>
    </member>
    <member name="T:NDepend.Path.IAbsoluteFilePath">
      <summary>
            Represents an absolute path to a file on file system.
            </summary>
      <remarks>
            The path represented can exist or not.
            The extension method <see cref="M:NDepend.Path.PathHelpers.ToAbsoluteFilePath(System.String)" /> can be called to create a new IAbsoluteFilePath object from a string.
            </remarks>
    </member>
    <member name="M:NDepend.Path.IAbsoluteFilePath.GetBrotherFileWithName(System.String)">
      <summary>
            Returns a new absolute file path refering to a file with name <paramref name="fileName" />, located in the same directory as this file.
            </summary>
      <remarks>This file nor the returned file need to exist for this operation to complete properly.</remarks>
      <param name="fileName">The brother file name</param>
      <exception cref="T:System.InvalidOperationException">This absolute file path is empty.</exception>
      <requires description="fileName must not be null" csharp="fileName != null" vb="fileName &lt;&gt; Nothing">fileName != null</requires>
      <requires description="fileName must not be empty" csharp="fileName.Length &gt; 0" vb="fileName.Length &gt; 0">fileName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.IAbsoluteFilePath.GetBrotherDirectoryWithName(System.String)">
      <summary>
            Returns a new absolute directory path representing a directory with name <paramref name="directoryName" />, located in the same directory as this file.
            </summary>
      <remarks>This file nor the returned directory need to exist for this operation to complete properly.</remarks>
      <param name="directoryName">The brother directory name.</param>
      <exception cref="T:System.InvalidOperationException">This absolute file path is empty.</exception>
      <requires description="directoryName must not be null" csharp="directoryName != null" vb="directoryName &lt;&gt; Nothing">directoryName != null</requires>
      <requires description="directoryName must not be empty" csharp="directoryName.Length &gt; 0" vb="directoryName.Length &gt; 0">directoryName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.IAbsoluteFilePath.GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
      <summary>
            Compute this file as relative from <paramref name="pivotDirectory" />. If this file is "C:\Dir1\Dir2\File.txt" and <paramref name="pivotDirectory" /> is "C:\Dir1\Dir3", the returned relative file path is "..\Dir2\File.txt".
            </summary>
      <remarks>
            This file nor <paramref name="pivotDirectory" /> need to exist for this operation to complete properly.
            </remarks>
      <param name="pivotDirectory">The pivot directory from which the relative path is computed.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="pivotDirectory" /> is not on the same drive as this file's drive.</exception>
      <exception cref="T:System.InvalidOperationException">This file directory path is empty.</exception>
      <returns>A new relative file path representing this file relative to <paramref name="pivotDirectory" />.</returns>
      <requires description="pivotDirectory must not be null" csharp="pivotDirectory != null" vb="pivotDirectory &lt;&gt; Nothing">pivotDirectory != null</requires>
      <requires description="pivotDirectory must not be empty" csharp="!pivotDirectory.IsEmpty" vb="Not pivotDirectory.IsEmpty">!pivotDirectory.IsEmpty</requires>
    </member>
    <member name="M:NDepend.Path.IAbsoluteFilePath.UpdateExtension(System.String)">
      <summary>
            Returns a new absolute file path representing this file with its file name extension updated to <paramref name="newExtension" />.
            </summary>
      <remarks>
            The returned file nor this file need to exist for this operation to complete properly.
            </remarks>
      <param name="newExtension">The new file extension. It must begin with a dot followed by one or many characters.</param>
      <exception cref="T:System.InvalidOperationException">This absolute file path is empty.</exception>
      <requires description="newExtension must not be null" csharp="newExtension != null" vb="newExtension &lt;&gt; Nothing">newExtension != null</requires>
      <requires description="newExtension must have at least two characters" csharp="newExtension.Length &gt;= 2" vb="newExtension.Length &gt;= 2">newExtension.Length &gt;= 2</requires>
      <requires description="newExtension first character must be a dot" csharp="newExtension.Chars[0] == '.'" vb="newExtension.Chars[0] = '.'">newExtension.Chars[0] == '.'</requires>
    </member>
    <member name="P:NDepend.Path.IAbsoluteFilePath.FileInfo">
      <summary>
            Returns a FileInfo object corresponding to this absolute file path.
            </summary>
      <exception cref="T:System.IO.FileNotFoundException">This absolute directory path doesn't refer to an existing directory.</exception>
      <seealso cref="P:NDepend.Path.IAbsolutePath.Exists" />
    </member>
    <member name="P:NDepend.Path.IAbsoluteFilePath.ParentDirectoryPath">
      <summary>
            Returns a new absolute directory path representing the parent directory of this file.
            </summary>
      <remarks>
            This file nor its parent directory need to exist for this operation to complete properly.
            </remarks>
      <exception cref="T:System.InvalidOperationException">This absolute file path is empty.</exception>
    </member>
    <member name="T:NDepend.Path.IRelativeFilePath">
      <summary>
            Represents a relative file path.
            </summary>
      <remarks>
            The extension method <see cref="M:NDepend.Path.PathHelpers.ToRelativeFilePath(System.String)" /> can be called to create a new IRelativeFilePath object from a string.
            </remarks>
    </member>
    <member name="M:NDepend.Path.IRelativeFilePath.GetBrotherFileWithName(System.String)">
      <summary>
            Returns a new relative file path refering to a file with name <paramref name="fileName" />, located in the same directory as this file.
            </summary>
      <param name="fileName">The brother file name</param>
      <exception cref="T:System.InvalidOperationException">This relative file path is empty.</exception>
      <requires description="fileName must not be null" csharp="fileName != null" vb="fileName &lt;&gt; Nothing">fileName != null</requires>
      <requires description="fileName must not be empty" csharp="fileName.Length &gt; 0" vb="fileName.Length &gt; 0">fileName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.IRelativeFilePath.GetBrotherDirectoryWithName(System.String)">
      <summary>
            Returns a new relative directory path representing a directory with name <paramref name="directoryName" />, located in the same directory as this file.
            </summary>
      <param name="directoryName">The brother directory name.</param>
      <exception cref="T:System.InvalidOperationException">This relative file path is empty.</exception>
      <requires description="directoryName must not be null" csharp="directoryName != null" vb="directoryName &lt;&gt; Nothing">directoryName != null</requires>
      <requires description="directoryName must not be empty" csharp="directoryName.Length &gt; 0" vb="directoryName.Length &gt; 0">directoryName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.IRelativeFilePath.UpdateExtension(System.String)">
      <summary>
            Returns a new relative file path representing this file with its file name extension updated to <paramref name="newExtension" />.
            </summary>
      <param name="newExtension">The new file extension. It must begin with a dot followed by one or many characters.</param>
      <exception cref="T:System.InvalidOperationException">This relative file path is empty.</exception>
      <requires description="newExtension must not be null" csharp="newExtension != null" vb="newExtension &lt;&gt; Nothing">newExtension != null</requires>
      <requires description="newExtension must have at least two characters" csharp="newExtension.Length &gt;= 2" vb="newExtension.Length &gt;= 2">newExtension.Length &gt;= 2</requires>
      <requires description="newExtension first character must be a dot" csharp="newExtension.Chars[0] == '.'" vb="newExtension.Chars[0] = '.'">newExtension.Chars[0] == '.'</requires>
    </member>
    <member name="M:NDepend.Path.IRelativeFilePath.GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
      <summary>
            Resolve this relative file from <paramref name="pivotDirectory" />. If this file is "..\Dir2\File.txt" and <paramref name="pivotDirectory" /> is "C:\Dir1\Dir3", the returned absolute file is "C:\Dir1\Dir2\File.txt".
            </summary>
      <remarks>
            The returned file nor <paramref name="pivotDirectory" /> need to exist for this operation to complete properly.
            </remarks>
      <param name="pivotDirectory">The pivot directory from which the absolute path is computed.</param>
      <exception cref="T:System.InvalidOperationException">This relative file path is empty.</exception>
      <exception cref="T:System.ArgumentException">
            An absolute path cannot be resolved from <paramref name="pivotDirectory" />. 
            This can happen for example if <paramref name="pivotDirectory" /> is "C:\Dir1" and this relative file path is "..\..\Dir2\File.txt".
            </exception>
      <returns>A new absolute file path representing this relative file resolved from <paramref name="pivotDirectory" />.</returns>
      <requires description="pivotDirectory must not be null" csharp="pivotDirectory != null" vb="pivotDirectory &lt;&gt; Nothing">pivotDirectory != null</requires>
      <requires description="pivotDirectory must not be empty" csharp="!pivotDirectory.IsEmpty" vb="Not pivotDirectory.IsEmpty">!pivotDirectory.IsEmpty</requires>
    </member>
    <member name="T:NDepend.Path.PathHelpers">
      <summary>
            Contains extensions methods to obtain a path object from a string and to check that a string indeed represents a valid path. Contains also fields representing empty paths.
            </summary>
    </member>
    <member name="F:NDepend.Path.PathHelpers.EmptyAbsoluteDirectoryPath">
      <summary>
            Represents the empty absolute directory path. This field is read-only.
            </summary>
    </member>
    <member name="F:NDepend.Path.PathHelpers.EmptyRelativeDirectoryPath">
      <summary>
            Represents the empty relative directory path. This field is read-only.
            </summary>
    </member>
    <member name="F:NDepend.Path.PathHelpers.EmptyAbsoluteFilePath">
      <summary>
            Represents the empty file absolute path. This field is read-only.
            </summary>
    </member>
    <member name="F:NDepend.Path.PathHelpers.EmptyRelativeFilePath">
      <summary>
            Represents the empty relative file path. This field is read-only.
            </summary>
    </member>
    <member name="M:NDepend.Path.PathHelpers.ToAbsoluteFilePath(System.String)">
      <summary>
            Returns a new <see cref="T:NDepend.Path.IAbsoluteFilePath" /> object from this string.
            </summary>
      <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The method <see cref="M:NDepend.Path.PathHelpers.IsValidAbsoluteFilePath(System.String)" /> can be called to enfore <paramref name="pathString" /> validity before calling this method, and avoid any exception.
            </remarks>
      <param name="pathString">Represents the path.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="pathString" /> is null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="pathString" /> is empty or doesn't represents a valid absolute file path.</exception>
      <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Path.PathHelpers.ToRelativeFilePath(System.String)">
      <summary>
            Returns a new <see cref="T:NDepend.Path.IRelativeFilePath" /> object from this string.
            </summary>
      <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The method <see cref="M:NDepend.Path.PathHelpers.IsValidRelativeFilePath(System.String)" /> can be called to enfore <paramref name="pathString" /> validity before calling this method, and avoid any exception.
            </remarks>
      <param name="pathString">Represents the path.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="pathString" /> is null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="pathString" /> is empty or doesn't represents a valid relative file path.</exception>
      <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Path.PathHelpers.ToAbsoluteDirectoryPath(System.String)">
      <summary>
            Returns a new <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" /> object from this string.
            </summary>
      <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The method <see cref="M:NDepend.Path.PathHelpers.IsValidAbsoluteDirectoryPath(System.String)" /> can be called to enfore <paramref name="pathString" /> validity before calling this method, and avoid any exception.
            </remarks>
      <param name="pathString">Represents the path.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="pathString" /> is null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="pathString" /> is empty or doesn't represents a valid absolute directory path.</exception>
      <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Path.PathHelpers.ToRelativeDirectoryPath(System.String)">
      <summary>
            Returns a new <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" /> object from this string.
            </summary>
      <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The method <see cref="M:NDepend.Path.PathHelpers.IsValidRelativeDirectoryPath(System.String)" /> can be called to enfore <paramref name="pathString" /> validity before calling this method, and avoid any exception.
            </remarks>
      <param name="pathString">Represents the path.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="pathString" /> is null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="pathString" /> is empty or doesn't represents a valid relative directory path.</exception>
      <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Path.PathHelpers.ToDirectoryPath(System.String)">
      <summary>
            Returns a new <see cref="T:NDepend.Path.IDirectoryPath" /> object from this string.
            </summary>
      <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The method <see cref="M:NDepend.Path.PathHelpers.IsValidDirectoryPath(System.String)" /> can be called to enfore <paramref name="pathString" /> validity before calling this method, and avoid any exception.
            </remarks>
      <param name="pathString">Represents the path.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="pathString" /> is null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="pathString" /> is empty or doesn't represents a valid relative or absolute directory path.</exception>
      <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Path.PathHelpers.ToFilePath(System.String)">
      <summary>
            Returns a new <see cref="T:NDepend.Path.IFilePath" /> object object from this string.
            </summary>
      <remarks>
            The path represented by this string doesn't need to exist for this operation to complete properly.
            The method <see cref="M:NDepend.Path.PathHelpers.IsValidFilePath(System.String)" /> can be called to enfore <paramref name="pathString" /> validity before calling this method, and avoid any exception.
            </remarks>
      <param name="pathString">Represents the path.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="pathString" /> is null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="pathString" /> is empty or doesn't represents a valid relative or absolute file path.</exception>
      <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Path.PathHelpers.IsValidFilePath(System.String)">
      <summary>
            Determine whether this string is a valid file path or not.
            </summary>
      <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToFilePath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IFilePath" />.
            Notice that this method can return true even if the path represented by this string doesn't exist.
            </remarks>
      <param name="pathString">This string from which is determined the path validity.</param>
      <returns>
            true if this string represents a valid relative or absolute file path, otherwise false.
            </returns>
    </member>
    <member name="M:NDepend.Path.PathHelpers.IsValidFilePath(System.String,System.String@)">
      <summary>
            Determine whether this string is a valid file path or not.
            </summary>
      <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToFilePath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IFilePath" />.
            Notice that this method can return true even if the path represented by this string doesn't exist.
            </remarks>
      <param name="pathString">This string from which is determined the path validity.</param>
      <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
      <returns>
            true if this string represents a valid relative or absolute file path, otherwise false.
            </returns>
    </member>
    <member name="M:NDepend.Path.PathHelpers.IsValidDirectoryPath(System.String)">
      <summary>
            Determine whether this string is a valid directory path or not.
            </summary>
      <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToDirectoryPath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IDirectoryPath" />.
            Notice that this method can return true even if the path represented by this string doesn't exist.
            </remarks>
      <param name="pathString">This string from which is determined the path validity.</param>
      <returns>
            true if this string represents a valid relative or absolute directory path, otherwise false.
            </returns>
    </member>
    <member name="M:NDepend.Path.PathHelpers.IsValidDirectoryPath(System.String,System.String@)">
      <summary>
            Determine whether this string is a valid directory path or not.
            </summary>
      <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToDirectoryPath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IDirectoryPath" />.
            Notice that this method can return true even if the path represented by this string doesn't exist.
            </remarks>
      <param name="pathString">This string from which is determined the path validity.</param>
      <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
      <returns>
            true if this string represents a valid relative or absolute directory path, otherwise false.
            </returns>
    </member>
    <member name="M:NDepend.Path.PathHelpers.IsValidAbsoluteDirectoryPath(System.String)">
      <summary>
            Determine whether this string is a valid absolute directory path or not.
            </summary>
      <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToAbsoluteDirectoryPath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" />.
            Notice that this method can return true even if the path represented by this string doesn't exist.
            </remarks>
      <param name="pathString">This string from which is determined the path validity.</param>
      <returns>
            true if this string represents a valid absolute path, otherwise false.
            </returns>
    </member>
    <member name="M:NDepend.Path.PathHelpers.IsValidAbsoluteDirectoryPath(System.String,System.String@)">
      <summary>
            Determine whether this string is a valid absolute directory path or not.
            </summary>
      <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToAbsoluteDirectoryPath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IAbsoluteDirectoryPath" />.
            Notice that this method can return true even if the path represented by this string doesn't exist.
            </remarks>
      <param name="pathString">This string from which is determined the path validity.</param>
      <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
      <returns>
            true if this string represents a valid absolute path, otherwise false.
            </returns>
    </member>
    <member name="M:NDepend.Path.PathHelpers.IsValidRelativeDirectoryPath(System.String)">
      <summary>
            Determine whether this string is a valid relative directory path or not.
            </summary>
      <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToRelativeDirectoryPath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IRelativeDirectoryPath" />.
            </remarks>
      <param name="pathString">This string from which is determined the path validity.</param>
      <returns>
            true if this string represents a valid relative path, otherwise false.
            </returns>
    </member>
    <member name="M:NDepend.Path.PathHelpers.IsValidRelativeDirectoryPath(System.String,System.String@)">
      <summary>
            Determine whether this string is a valid relative directory path or not.
            </summary>
      <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToRelativeDirectoryPath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IRelativeDirectoryPath" />.
            </remarks>
      <param name="pathString">This string from which is determined the path validity.</param>
      <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
      <returns>
            true if this string represents a valid relative path, otherwise false.
            </returns>
    </member>
    <member name="M:NDepend.Path.PathHelpers.IsValidAbsoluteFilePath(System.String)">
      <summary>
            Determine whether this string is a valid file absolute path or not.
            </summary>
      <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToAbsoluteFilePath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IAbsoluteFilePath" />.
            Notice that this method can return true even if the path represented by this string doesn't exist.
            </remarks>
      <param name="pathString">This string from which is determined the path validity.</param>
      <returns>
            true if this string represents a valid absolute file path, otherwise false.
            </returns>
    </member>
    <member name="M:NDepend.Path.PathHelpers.IsValidAbsoluteFilePath(System.String,System.String@)">
      <summary>
            Determine whether this string is a valid file absolute path or not.
            </summary>
      <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToAbsoluteFilePath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IAbsoluteFilePath" />.
            Notice that this method can return true even if the path represented by this string doesn't exist.
            </remarks>
      <param name="pathString">This string from which is determined the path validity.</param>
      <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
      <returns>
            true if this string represents a valid absolute file path, otherwise false.
            </returns>
    </member>
    <member name="M:NDepend.Path.PathHelpers.IsValidRelativeFilePath(System.String)">
      <summary>
            Determine whether this string is a valid relative file path or not.
            </summary>
      <remarks>
            If this method returns true, the extension method <see cref="M:NDepend.Path.PathHelpers.ToRelativeFilePath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IRelativeFilePath" />.
            </remarks>
      <param name="pathString">This string from which is determined the path validity.</param>
      <returns>
            true if this string represents a valid relative file path, otherwise false.
            </returns>
    </member>
    <member name="M:NDepend.Path.PathHelpers.IsValidRelativeFilePath(System.String,System.String@)">
      <summary>
            Determine whether this string is a valid relative file path or not.
            </summary>
      <remarks>
            If this method returns true <see cref="M:NDepend.Path.PathHelpers.ToRelativeFilePath(System.String)" /> can be safely invoked on this string to obtain a <see cref="T:NDepend.Path.IRelativeFilePath" />.
            </remarks>
      <param name="pathString">this string</param>
      <param name="failureReason">If false is returned, failureReason contains the plain english description of the failure.</param>
      <returns>
            true if this string represents a valid relative file path, otherwise false.
            </returns>
    </member>
    <member name="M:NDepend.Path.PathHelpers.IsNullOrEmpty(NDepend.Path.IPath)">
      <summary>
            Indicates whether the specified path is null or an empty path.
            </summary>
      <returns>
            true if this path is null or empty, otherwise false.
            </returns>
    </member>
    <member name="P:NDepend.Path.PathHelpers.ForbiddenCharInPath">
      <summary>
            An array of char forbidden in string representing path.
            Use this string.IndexOfAny(char[]) method to detect the presence of any of this char in a string.
            </summary>
      <getter>
        <ensures description="returned array is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.Path.PathMode">
      <summary>
            Defines a path mode, absolute or relative.
            </summary>
      <remarks>
            Since the a PathMode value can be variable, this enumeration can favor a generic way of coding in certain situations, by replacing calls to <see cref="P:NDepend.Path.IPath.IsAbsolutePath" /> and <see cref="P:NDepend.Path.IPath.IsRelativePath" /> by calls to <see cref="M:NDepend.Path.IPath.HasThisPathMode(NDepend.Path.PathMode)" />.
            </remarks>
    </member>
    <member name="F:NDepend.Path.PathMode.Absolute">
      <summary>
            Represents absolute path.
            </summary>
    </member>
    <member name="F:NDepend.Path.PathMode.Relative">
      <summary>
            Represents relative path.
            </summary>
    </member>
    <member name="T:NDepend.Project.CoverageFileMergeMode">
      <summary>
            When NDepend loads several coverage files to extract coverage information, the enumeration <see cref="T:NDepend.Project.CoverageFileMergeMode" /> indicates for each file how to combine coverage data.
            </summary>
      <remarks>
            For each method with a body, coverage data are represented through an array of bit of length <see cref="T:NDepend.CodeModel.ICodeContainer" />.<see cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCode" />.<br />
            Each coverage file determines such an array of bits for each method with a body.<br />
            Values of <see cref="T:NDepend.Project.CoverageFileMergeMode" /> indicates for each coverage file loaded, how to combine these arrays of bits.<br />
            The default value is <see cref="F:NDepend.Project.CoverageFileMergeMode.Or" /> since most of the time, the user wants an addiditive combination of multiple coverage data obtained from multiple coverage files.
            </remarks>
      <seealso cref="P:NDepend.Project.IProjectCoverage.Item(NDepend.Path.IFilePath)" />
    </member>
    <member name="F:NDepend.Project.CoverageFileMergeMode.Or">
      <summary>Or</summary>
    </member>
    <member name="F:NDepend.Project.CoverageFileMergeMode.And">
      <summary>And</summary>
    </member>
    <member name="F:NDepend.Project.CoverageFileMergeMode.XOr">
      <summary>XOr</summary>
    </member>
    <member name="F:NDepend.Project.CoverageFileMergeMode.None">
      <summary>None</summary>
    </member>
    <member name="T:NDepend.Project.IAssemblyResolvingError">
      <summary>
            Represents an application or third-party assembly resolving error, obtained when trying to resolve assemblies with the method <see cref="T:NDepend.Project.IProjectCodeToAnalyze" />.<see cref="M:NDepend.Project.IProjectCodeToAnalyze.Resolve(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@,System.Collections.Generic.ICollection{NDepend.Project.IAssemblyResolvingError}@,System.Collections.Generic.ICollection{NDepend.Project.IAssemblyResolvingError}@)" />.
            </summary>
      <remarks>
            A <see cref="T:NDepend.Project.IAssemblyResolvingError" /> objects can correspond to resolving error situations like:<br />
            - no assembly file with the name <see cref="P:NDepend.Project.IAssemblyResolvingError.AssemblyName" /> found in the set of directories <see cref="T:NDepend.Project.IProjectCodeToAnalyze" />.<see cref="P:NDepend.Project.IProjectCodeToAnalyze.DirectoriesAbsolute" />.<br />
            - several different assemblies files with the name <see cref="P:NDepend.Project.IAssemblyResolvingError.AssemblyName" /> found in the set of directories provided <see cref="T:NDepend.Project.IProjectCodeToAnalyze" />.<see cref="P:NDepend.Project.IProjectCodeToAnalyze.DirectoriesAbsolute" />.<br />
            - one assembly file with the name <see cref="P:NDepend.Project.IAssemblyResolvingError.AssemblyName" /> found but it is a corrupted assembly main module file.<br /></remarks>
    </member>
    <member name="P:NDepend.Project.IAssemblyResolvingError.AssemblyName">
      <summary>
            The assembly main module file name on which the resolving error occured.
            </summary>
      <getter>
        <ensures description="returned assembly name is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned assembly name is not empty" csharp="result.Length &gt; 0" vb="result.Length &gt; 0">result.Length &gt; 0</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IAssemblyResolvingError.ErrorDescription">
      <summary>
            The plain english description of the resolving error.
            </summary>
      <getter>
        <ensures description="returned resolving error description is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned resolving error description is not empty" csharp="result.Length &gt; 0" vb="result.Length &gt; 0">result.Length &gt; 0</ensures>
      </getter>
    </member>
    <member name="T:NDepend.Project.IProject">
      <summary>
            Represents an NDepend project, with all its settings readable and writable.
            </summary>
      <remarks>
        <see cref="T:NDepend.Project.IProjectManager" /> presents methods to create, load and save an NDepend project.
            </remarks>
    </member>
    <member name="M:NDepend.Project.IProject.GetProjectRef(System.DateTime)">
      <summary>
            Gets a reference to this NDepend project, with <see cref="T:NDepend.Project.IProjectRef" />.<see cref="P:NDepend.Project.IProjectRef.DateLastTouched" /> equals to <paramref name="dateLastTouched" />.
            </summary>
      <param name="dateLastTouched">The <see cref="T:NDepend.Project.IProjectRef" />.<see cref="P:NDepend.Project.IProjectRef.DateLastTouched" /> of the returned NDepend project reference.</param>
      <ensures description="returned project reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:NDepend.Project.IProject.Properties">
      <summary>
            Represents this NDepend project main properties.
            </summary>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProject.CodeToAnalyze">
      <summary>
            Represents this NDepend project assemblies to analyze.
            </summary>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProject.Report">
      <summary>
            Represents settings of this NDepend project concerning report.
            </summary>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProject.BaselineDuringAnalysis">
      <summary>
            Represents settings of this NDepend project concerning the baseline eventually used during analysis.
            </summary>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProject.BaselineInUI">
      <summary>
            Represents settings of this NDepend project concerning the baseline eventually used in NDepend user interface (VisualNDepend or VisualStudio addin).
            </summary>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProject.Coverage">
      <summary>
            Represents settings of this NDepend project concerning code coverage file(s) to load to obtain code coverage metrics.
            </summary>
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" />
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />
      <seealso cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" />
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProject.DisabledWarnings">
      <summary>
            Represents the collection of analysis warnings disabled, of this NDepend project.
            </summary>
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProject.SourceFilesRebasing">
      <summary>
            Represents this NDepend project source files rebasing settings.
            </summary>
      <remarks>
            SourceFilesRebasing is useful if the analysis results are produced on a machine, but used from another machine, where source file are nested in a different root directory.<br />
            Hence source files rebasing settings are used to rebase source files paths.
            </remarks>
      <seealso cref="P:NDepend.CodeModel.ICodeElement.SourceDecls" />
      <seealso cref="P:NDepend.CodeModel.ICodeElement.SourceFileDeclAvailable" />
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProject.CodeQueries">
      <summary>
            Represents this NDepend project code queries and code rules.
            </summary>
      <seealso cref="N:NDepend.CodeQuery" />
      <getter>
        <ensures description="returned reference is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="E:NDepend.Project.IProject.SettingsChanged">
      <summary>
            This event is triggered each time some settings of this NDepend project are changed.
            </summary>
      <remarks>The settings changed are listed through the <see cref="T:NDepend.Project.ProjectSettings" /> flags.</remarks>
    </member>
    <member name="T:NDepend.Project.BaselineProjectMode">
      <summary>
            Represents a value that determines if a <see cref="T:NDepend.Project.IProjectBaseline" /> comparison doesn't occur, occurs with a previous analyis result of this NDepend project or occurs with a previous analyis result of another NDepend project.
            </summary>
      <remarks>
        <see cref="T:NDepend.Project.BaselineProjectMode" />.<see cref="F:NDepend.Project.BaselineProjectMode.DontCompare" />    : don't do comparison when doing a new analysis.<br /><see cref="T:NDepend.Project.BaselineProjectMode" />.<see cref="F:NDepend.Project.BaselineProjectMode.CurrentProject" /> : do a comparison with a previous analysis of the current project.<br /><see cref="T:NDepend.Project.BaselineProjectMode" />.<see cref="F:NDepend.Project.BaselineProjectMode.AnotherProject" /> : do a comparison with a previous analysis of another project.
            </remarks>
    </member>
    <member name="F:NDepend.Project.BaselineProjectMode.DontCompare">
      <summary>DontCompare</summary>
    </member>
    <member name="F:NDepend.Project.BaselineProjectMode.CurrentProject">
      <summary>CurrentProject</summary>
    </member>
    <member name="F:NDepend.Project.BaselineProjectMode.AnotherProject">
      <summary>AnotherProject</summary>
    </member>
    <member name="T:NDepend.Project.BaselineAnalysisResultMode">
      <summary>
            Represents a value that determines for a <see cref="T:NDepend.Project.IProjectBaseline" />, with which analysis result the comparison occurs..
            </summary>
      <remarks>
        <see cref="T:NDepend.Project.BaselineAnalysisResultMode" />.<see cref="F:NDepend.Project.BaselineAnalysisResultMode.MostRecentAnalysisResultAvailable" /> : compare with the most recent analysis result available.<br /><see cref="T:NDepend.Project.BaselineAnalysisResultMode" />.<see cref="F:NDepend.Project.BaselineAnalysisResultMode.NDaysAgoAnalysisResult" />            : compare with an analysis result made N days ago. If no analysis result found, then try to find the closest analysis result.<br /><see cref="T:NDepend.Project.BaselineAnalysisResultMode" />.<see cref="F:NDepend.Project.BaselineAnalysisResultMode.ParticularAnalysisResult" />          : compare with a particular analysis result.
            </remarks>
    </member>
    <member name="F:NDepend.Project.BaselineAnalysisResultMode.MostRecentAnalysisResultAvailable">
      <summary>MostRecentAnalysisResultAvailable</summary>
    </member>
    <member name="F:NDepend.Project.BaselineAnalysisResultMode.NDaysAgoAnalysisResult">
      <summary>NDaysAgoAnalysisResult</summary>
    </member>
    <member name="F:NDepend.Project.BaselineAnalysisResultMode.ParticularAnalysisResult">
      <summary>ParticularAnalysisResult</summary>
    </member>
    <member name="T:NDepend.Project.IProjectBaseline">
      <summary>
            Represents baseline settings of an NDepend project. It can be the settings for <see cref="P:NDepend.Project.IProject.BaselineInUI" /> or <see cref="P:NDepend.Project.IProject.BaselineDuringAnalysis" />.
            </summary>
    </member>
    <member name="M:NDepend.Project.IProjectBaseline.GetBaselineSettingsDescription">
      <summary>
            Returns this baseline settings plain english description.
            </summary>
      <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:NDepend.Project.IProjectBaseline.KeepHistoric">
      <summary>
            Get or sets a boolean setting that determines if an analysis result file gets duplicated and stored at analysis end time.
            </summary>
      <remarks>
            When the property is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.KeepHistoric" /> activated.<br />
            Notice that the tickBox in the panel: Project Properties &gt; Analysis &gt; Keep Historic Analysis Results corresponds to project.<see cref="P:NDepend.Project.IProject.BaselineDuringAnalysis" />.<see cref="P:NDepend.Project.IProjectBaseline.KeepHistoric" />.<br />
            Hence project.<see cref="P:NDepend.Project.IProject.BaselineInUI" />.<see cref="P:NDepend.Project.IProjectBaseline.KeepHistoric" /> is useless.
            </remarks>
    </member>
    <member name="P:NDepend.Project.IProjectBaseline.ProjectMode">
      <summary>
            Gets or sets a value that determines if the comparison doesn't occur, occurs with a previous analyis result of this NDepend project or occurs with a previous analyis result of another NDepend project.
            </summary>
      <remarks>
            Specified values can be:<br /><see cref="P:NDepend.Project.IProjectBaseline.ProjectMode" />.<see cref="F:NDepend.Project.BaselineProjectMode.DontCompare" />    : don't do comparison when doing a new analysis.<br /><see cref="P:NDepend.Project.IProjectBaseline.ProjectMode" />.<see cref="F:NDepend.Project.BaselineProjectMode.CurrentProject" /> : do a comparison with a previous analysis of the current project.<br /><see cref="P:NDepend.Project.IProjectBaseline.ProjectMode" />.<see cref="F:NDepend.Project.BaselineProjectMode.AnotherProject" /> : do a comparison with a previous analysis of another project.
            </remarks>
    </member>
    <member name="P:NDepend.Project.IProjectBaseline.AnalysisResultMode">
      <summary>
            Gets or sets a value that determines with which analysis result the comparison occurs.
            </summary>
      <remarks>
            The <see cref="P:NDepend.Project.IProjectBaseline.AnalysisResultMode" /> value is only used when <see cref="P:NDepend.Project.IProjectBaseline.ProjectMode" /> is different than <see cref="F:NDepend.Project.BaselineProjectMode.DontCompare" />.<br />
            Specified values can be:<br /><see cref="T:NDepend.Project.BaselineAnalysisResultMode" />.<see cref="F:NDepend.Project.BaselineAnalysisResultMode.MostRecentAnalysisResultAvailable" /> : compare with the most recent analysis result available.<br /><see cref="T:NDepend.Project.BaselineAnalysisResultMode" />.<see cref="F:NDepend.Project.BaselineAnalysisResultMode.NDaysAgoAnalysisResult" />            : compare with an analysis result made N days ago. If no analysis result found, then try to find the closest analysis result.<br /><see cref="T:NDepend.Project.BaselineAnalysisResultMode" />.<see cref="F:NDepend.Project.BaselineAnalysisResultMode.ParticularAnalysisResult" />          : compare with a particular analysis result.
            </remarks>
    </member>
    <member name="P:NDepend.Project.IProjectBaseline.AnalysisResultCreatedNDaysAgo">
      <summary>
            Gets or sets the number of days ago, used when this baseline's <see cref="P:NDepend.Project.IProjectBaseline.AnalysisResultMode" /> is set to <see cref="T:NDepend.Project.BaselineAnalysisResultMode" />.<see cref="F:NDepend.Project.BaselineAnalysisResultMode.NDaysAgoAnalysisResult" />.
            </summary>
    </member>
    <member name="P:NDepend.Project.IProjectBaseline.OtherProjectFilePath">
      <summary>
            Gets or sets the other NDepend project file path, used when this baseline's <see cref="P:NDepend.Project.IProjectBaseline.ProjectMode" /> is set to <see cref="T:NDepend.Project.BaselineProjectMode" />.<see cref="F:NDepend.Project.BaselineProjectMode.AnotherProject" />.
            </summary>
      <remarks>
            If the returned path is a relative path (<see cref="T:NDepend.Path.IFilePath" />.<see cref="P:NDepend.Path.IPath.IsRelativePath" />), the path is relative to the current NDepend project file path (<see cref="T:NDepend.Project.IProjectProperties" />.<see cref="P:NDepend.Project.IProjectProperties.FilePath" />.<see cref="P:NDepend.Path.IAbsoluteFilePath.ParentDirectoryPath" />).<br />
            An empty value for this property is represented by an empty file path.<br />
            If this property is set with a null value, an empty file path will be set instead.
            </remarks>
      <getter>
        <ensures description="returned file path can be empty but not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProjectBaseline.ParticularAnalysisResultFilePath">
      <summary>
            Gets or sets the <see cref="T:NDepend.Analysis.IAnalysisResultRef" />.<see cref="P:NDepend.Analysis.IAnalysisResultRef.AnalysisResultFilePath" /> used when this baseline's <see cref="P:NDepend.Project.IProjectBaseline.AnalysisResultMode" /> is set to <see cref="T:NDepend.Project.BaselineAnalysisResultMode" />.<see cref="F:NDepend.Project.BaselineAnalysisResultMode.ParticularAnalysisResult" />.
            </summary>
      <remarks>
            If the returned path is a relative path (<see cref="T:NDepend.Path.IFilePath" />.<see cref="P:NDepend.Path.IPath.IsRelativePath" />), the path is relative to the current NDepend project file path (<see cref="T:NDepend.Project.IProjectProperties" />.<see cref="P:NDepend.Project.IProjectProperties.FilePath" />.<see cref="P:NDepend.Path.IAbsoluteFilePath.ParentDirectoryPath" />).<br />
            An empty value for this property is represented by an empty file path.<br />
            If this property is set with a null value, an empty file path will be set instead.
            </remarks>
      <getter>
        <ensures description="returned file path can be empty but not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.Project.IProjectBaselineContract">
      <summary>
            Represents baseline settings of an NDepend project.
            </summary>
    </member>
    <member name="T:NDepend.Project.IProjectCodeToAnalyze">
      <summary>
            Represents application and third-party assemblies to analyze, of an NDepend project.
            </summary>
      <remarks>
            Assemblies are referenced by names.<br /> 
            A collection of directories is provided.<br />
            At assemblies resolving time, assemblies are resolved by names in directories provided. Some <see cref="T:NDepend.Project.IAssemblyResolvingError" /> can then occur.
            </remarks>
    </member>
    <member name="M:NDepend.Project.IProjectCodeToAnalyze.SetApplicationAssemblies(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath})">
      <summary>
            Set the collection of application assemblies to analyze. 
            </summary>
      <remarks>
            This method resets the <see cref="T:NDepend.Project.IProjectCodeToAnalyze" /> state for this project.<br />
            Third-party assemblies are infered from application assemblies.<br />
            Directories (absolute or relative to the NDepend project file path) are infered as well.<br />
            .NET Framework directories are also infered.
            </remarks>
      <param name="assembliesPath">The collection of absolute file paths of the application assemblies to analyze.</param>
      <exception cref="T:NDepend.Project.ProjectException">
            Directories containg application assemblies cannot be accepted.<br />
            Typically this situation happens when the project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" /> is set to <see cref="T:NDepend.Path.PathMode" />.<see cref="F:NDepend.Path.PathMode.Relative" />, and one or several assemblies files are not on the same drive as the project file.
            </exception>
      <requires description="inputed collection of file paths must not be null" csharp="assembliesPath != null" vb="assembliesPath &lt;&gt; Nothing">assembliesPath != null</requires>
    </member>
    <member name="M:NDepend.Project.IProjectCodeToAnalyze.Resolve(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@,System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@,System.Collections.Generic.ICollection{NDepend.Project.IAssemblyResolvingError}@,System.Collections.Generic.ICollection{NDepend.Project.IAssemblyResolvingError}@)">
      <summary>
            Tries resolve application and third-party assemblies paths, and if some are not resolved, returns corresponding <see cref="T:NDepend.Project.IAssemblyResolvingError" /> objects.
            </summary>
      <remarks>
            The result of this resolving action is not cached and each time calling this method can take a few tenths of second.
            </remarks>
      <param name="applicationAssemblies">Paths to application assemblies files resolved.</param>
      <param name="thirdPartyAssemblies">Paths to third-party assemblies files resolved.</param>
      <param name="applicationAssembliesError">A collection of <see cref="T:NDepend.Project.IAssemblyResolvingError" /> objects, one for each application assemblies files unresolved.</param>
      <param name="thirdPartyAssembliesError">A collection of <see cref="T:NDepend.Project.IAssemblyResolvingError" /> objects, one for each third-party assemblies files unresolved.</param>
      <returns>Returns true if no assembly resolving error is found, otherwise returns false.</returns>
      <ensures description="returned collection of paths can be empty but not null" csharp="applicationAssemblies != null" vb="applicationAssemblies &lt;&gt; Nothing">applicationAssemblies != null</ensures>
      <ensures description="returned collection of paths can be empty but not null" csharp="thirdPartyAssemblies != null" vb="thirdPartyAssemblies &lt;&gt; Nothing">thirdPartyAssemblies != null</ensures>
      <ensures description="returned collection of resolving errors can be empty but not null" csharp="applicationAssembliesError != null" vb="applicationAssembliesError &lt;&gt; Nothing">applicationAssembliesError != null</ensures>
      <ensures description="returned collection of resolving errors can be empty but not null" csharp="thirdPartyAssembliesError != null" vb="thirdPartyAssembliesError &lt;&gt; Nothing">thirdPartyAssembliesError != null</ensures>
    </member>
    <member name="P:NDepend.Project.IProjectCodeToAnalyze.ApplicationAssembliesNames">
      <summary>
            Gets the collection of application assemblies files names.
            </summary>
      <remarks>The collection returned is a clone. Hence modifying the returned collection won't modify the original collection.</remarks>
      <getter>
        <ensures description="returned collection of names can be empty but not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProjectCodeToAnalyze.ThirdPartyAssembliesNames">
      <summary>
            Gets the collection of third-party assemblies files names.
            </summary>
      <remarks>The collection returned is a clone. Hence modifying the returned collection won't modify the original collection.</remarks>
      <getter>
        <ensures description="returned collection of names can be empty but not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProjectCodeToAnalyze.Directories">
      <summary>
            Gets the collection of directories paths where to search for assemblies.
            </summary>
      <remarks>
            Directories paths are all absolute or all relative to the path of the NDepend project file (except .NET Framework directories that are always absolute).<br />
            The absolute or relative nature of directories can be determined through project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" />.<br />
            The collection returned is a clone. Hence modifying the returned collection won't modify the original collection.
            </remarks>
      <getter>
        <ensures description="returned collection of paths can be empty but not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProjectCodeToAnalyze.DirectoriesAbsolute">
      <summary>
            Gets the collection of absolute directories paths where to search for assemblies.
            </summary>
      <remarks>
            Returned directories corresponds to <see cref="P:NDepend.Project.IProjectCodeToAnalyze.Directories" /> if project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" /> is equal to <see cref="T:NDepend.Path.PathMode" />.<see cref="F:NDepend.Path.PathMode.Absolute" />.<br />
            If project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" /> is equal to <see cref="T:NDepend.Path.PathMode" />.<see cref="F:NDepend.Path.PathMode.Relative" />, absolute directories get resolved from the project file parent directory path.<br />
            In this situation, if a relative directory cannot be resolved to absolute (like for example "..\..\Dir0" cannot be resolved from "C:\Dir1\Project.ndproj"), it doesn't appears in the returned collection of paths.
            </remarks>
      <getter>
        <ensures description="returned collection of paths can be empty but not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:NDepend.Project.IProjectCoverage">
      <summary>
            Represents settings of an NDepend project concerning code coverage file(s) to load to obtain code coverage metrics.
            </summary>
      <seealso cref="P:NDepend.CodeQuery.IQueryCompiledSuccess.RelyOnCodeCoverageData" />
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" />
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeCovered" />
      <seealso cref="P:NDepend.CodeModel.ICodeContainer.NbLinesOfCodeNotCovered" />
      <seealso cref="P:NDepend.CodeModel.IMethod.PercentageBranchCoverage" />
      <seealso cref="P:NDepend.CodeModel.ICodeBase.CoverageDataAvailable" />
      <seealso cref="T:NDepend.Project.IProjectCoverage" />
    </member>
    <member name="M:NDepend.Project.IProjectCoverage.AddCoverageFile(NDepend.Path.IFilePath)">
      <summary>
            Adds the coverage file path.
            </summary>
      <remarks>
            The list can't contains duplicate path or empty path.
            If the path is added, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Coverage" /> activated.<br /></remarks>
      <returns>
            When adding a duplicate or an empty path, the method does nothing and returns false.<br />
            When adding a relative path while the project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" /> is equal to <see cref="T:NDepend.Path.PathMode" />.<see cref="F:NDepend.Path.PathMode.Absolute" />, the method does nothing and returns false.<br />
            When adding an absolute path while the project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" /> is equal to <see cref="T:NDepend.Path.PathMode" />.<see cref="F:NDepend.Path.PathMode.Relative" />, the method does nothing and returns false.<br /> 
            Returns true only if the path is correctly added.
            </returns>
      <param name="coverageFilePath">The coverage file path to add.</param>
      <requires description="the file path must not be null" csharp="coverageFilePath != null" vb="coverageFilePath &lt;&gt; Nothing">coverageFilePath != null</requires>
    </member>
    <member name="M:NDepend.Project.IProjectCoverage.RemoveCoverageFile(NDepend.Path.IFilePath)">
      <summary>
            Removes the <paramref name="coverageFilePath" /> from the collection of coverage files.
            </summary>
      <remarks>
            If the path is removed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Coverage" /> activated.<br /></remarks>
      <returns>
            If the path is not found, the method does nothing and returns false.<br />
            Returns true only if the path is correctly removed.
            </returns>
      <param name="coverageFilePath">The coverage file path to remove.</param>
      <requires description="the file path must not be null" csharp="coverageFilePath != null" vb="coverageFilePath &lt;&gt; Nothing">coverageFilePath != null</requires>
    </member>
    <member name="M:NDepend.Project.IProjectCoverage.GetCoverageDescription">
      <summary>
            Returns a plain english description of the coverage files.
            </summary>
      <ensures description="returned string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures description="returned string is not empty" csharp="result.Length &gt; 0" vb="result.Length &gt; 0">result.Length &gt; 0</ensures>
    </member>
    <member name="P:NDepend.Project.IProjectCoverage.CoverageFiles">
      <summary>
            Gets the collection of coverages files paths.
            </summary>
      <remarks>
            The collection returned is a clone. Hence modifying the returned collection won't modify the original collection.<br />
            Use <see cref="M:NDepend.Project.IProjectCoverage.AddCoverageFile(NDepend.Path.IFilePath)" /> and <see cref="M:NDepend.Project.IProjectCoverage.RemoveCoverageFile(NDepend.Path.IFilePath)" /> methods to modify the collection of coverages files paths.<br />
            Coverage file paths are all absolute or all relative to the path of the NDepend project file.<br />
            The absolute or relative nature of directories can be determined through project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" />.
            </remarks>
      <getter>
        <ensures description="returned collection of paths can be empty but not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProjectCoverage.Item(NDepend.Path.IFilePath)">
      <summary>
            Gets or sets the <see cref="T:NDepend.Project.CoverageFileMergeMode" /> value corresponding to the coverage file path inputed.
            </summary>
      <param name="coverageFilePath">The coverage file path from which to get or set the <see cref="T:NDepend.Project.CoverageFileMergeMode" /> value.</param>
      <remarks>
            If no coverage file path correspond to <paramref name="coverageFilePath" />:<br />
            - the getter returns <see cref="T:NDepend.Project.CoverageFileMergeMode" />.<see cref="F:NDepend.Project.CoverageFileMergeMode.None" />.<br />
            - the setter does nothing.<br />
            If the setter modifies a state, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Coverage" /> activated.
            </remarks>
      <getter>
        <requires description="the file path must not be null" csharp="coverageFilePath != null" vb="coverageFilePath &lt;&gt; Nothing">coverageFilePath != null</requires>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProjectCoverage.UncoverableAttribute">
      <summary>Gets or sets the full name string of the uncoverable attribute.</summary>
      <remarks>
            Through this option, the user can define an attribute that tags uncoverage methods, types or assemblies.<br />
            NDepend will then take care of this attribute and compute coverage ratio adequately.<br />
            For example, if all methods of a type are 100% covered by tests except a method that calls a blocking method such as MessageBox.Show(), this method can be tagged with the uncoverable attributes and as a result, the type.<see cref="P:NDepend.CodeModel.ICodeContainer.PercentageCoverage" /> ratio is artificially maintained to 100%.<br />
            The NDepend.API offers the attribute class <see cref="T:NDepend.Attributes.UncoverableByTestAttribute" /> for default uncoverable attribute, but you can define your own uncoverable attribute and set this property adequately.<br />
            The name of the uncoverable attribute must be formatted "{namespace}.{typeAttribute}". For example: "NDepend.Attributes.UncoverableByTestAttribute"
            </remarks>
      <seealso cref="T:NDepend.Attributes.UncoverableByTestAttribute" />
      <getter>
        <ensures description="returned string can be empty but not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
      <setter>
        <requires description="the uncoverable attribute string must not be null" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      </setter>
    </member>
    <member name="T:NDepend.Project.IProjectManager">
      <summary>
            Exposes base operations on NDepend project, including load/save/create/get most recent... A IProjectManager object can be obtained from the property <see cref="T:NDepend.NDependServicesProvider" />.<see cref="P:NDepend.NDependServicesProvider.ProjectManager" />.
            </summary>
    </member>
    <member name="M:NDepend.Project.IProjectManager.LoadProject(NDepend.Path.IAbsoluteFilePath)">
      <summary>
            Loads a NDepend project, a <see cref="T:NDepend.Project.IProject" /> object, from the path of the project file.
            </summary>
      <param name="projectFilePath">The path of the project file.</param>
      <returns>The <see cref="T:NDepend.Project.IProject" /> object.</returns>
      <exception cref="T:NDepend.Project.ProjectException">The project cannot be loaded, the exception message describes the failure reason.</exception>
      <requires description="The path must not be null" csharp="projectFilePath != null" vb="projectFilePath &lt;&gt; Nothing">projectFilePath != null</requires>
      <requires description="The path must not be empty" csharp="!projectFilePath.IsEmpty" vb="Not projectFilePath.IsEmpty">!projectFilePath.IsEmpty</requires>
    </member>
    <member name="M:NDepend.Project.IProjectManager.SaveProject(NDepend.Project.IProject)">
      <summary>
            Saves a NDepend project to the project file defined by project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.FilePath" />.
            </summary>
      <param name="project">The project object to save.</param>
      <exception cref="T:NDepend.Project.ProjectException">The project cannot be saved, the exception message describes the failure reason.</exception>
      <requires description="The project object must not be null" csharp="project != null" vb="project &lt;&gt; Nothing">project != null</requires>
    </member>
    <member name="M:NDepend.Project.IProjectManager.GetMostRecentlyUsedProjects">
      <summary>
            Gets a collection of NDepend projects references object representing most recently used NDepend projects.
            </summary>
      <ensures description="returned collection can be empty but not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Project.IProjectManager.CanSwitchToPathMode(NDepend.Project.IProject,NDepend.Path.PathMode,System.String@)">
      <summary>
            Gets a value indicating whether <paramref name="project" />.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" /> can be set to the <paramref name="pathMode" /> value, <see cref="F:NDepend.Path.PathMode.Absolute" /> or <see cref="F:NDepend.Path.PathMode.Relative" />.
            </summary>
      <param name="project">The project to test.</param>
      <param name="pathMode">The <see cref="T:NDepend.Path.PathMode" /> specified.</param>
      <param name="reasonCantSwitch">If <paramref name="project" />.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" /> can't be set to the specified <paramref name="pathMode" /> value, contains a plain-english description of the cause.</param>
      <returns>true if <paramref name="project" />.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" /> can be set to the specified <paramref name="pathMode" /> value, otherwise returns false.</returns>
      <seealso cref="T:NDepend.Path.PathMode" />
      <seealso cref="P:NDepend.Project.IProjectProperties.PathMode" />
      <requires description="The project object must not be null" csharp="project != null" vb="project &lt;&gt; Nothing">project != null</requires>
    </member>
    <member name="M:NDepend.Project.IProjectManager.CreateBlankProject(NDepend.Path.IAbsoluteFilePath,System.String)">
      <summary>
            Creates a new blank project. This method doesn't create the project file, the method <see cref="M:NDepend.Project.IProjectManager.SaveProject(NDepend.Project.IProject)" /> can be called for that.
            </summary>
      <remarks>
            The <paramref name="projectFilePath" /> is needed because if some paths are added to the project with project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" /> set to <see cref="F:NDepend.Path.PathMode.Relative" />, they have to be relative to the path of the project file.<br />
            Once the project object is created, the project file is then accessible through project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.FilePath" />.
            </remarks>
      <param name="projectFilePath">The absolute path to the project file, a project cannot be initialized without a valid project file path.</param>
      <param name="projectName">The initial name of the project.</param>
      <returns>The blank project object.</returns>
      <requires description="The path must not be null" csharp="projectFilePath != null" vb="projectFilePath &lt;&gt; Nothing">projectFilePath != null</requires>
      <requires description="The path must not be empty" csharp="!projectFilePath.IsEmpty" vb="Not projectFilePath.IsEmpty">!projectFilePath.IsEmpty</requires>
      <requires description="The string must not be null" csharp="projectName != null" vb="projectName &lt;&gt; Nothing">projectName != null</requires>
      <requires description="The string must not be empty" csharp="projectName.Length &gt; 0" vb="projectName.Length &gt; 0">projectName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Project.IProjectManager.CreateTemporaryProject(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},NDepend.Project.TemporaryProjectMode)">
      <summary>
            Creates a new temporary project. Calling this method creates the temporary project file in a temporary directory.
            </summary>
      <remarks>
            By working with temporary projects, you can create and experiment with a project without specifying a disk location or a project name.<br />
            Tree temporary projects can coexist corresponding to the three <see cref="T:NDepend.Project.TemporaryProjectMode" /> values, <see cref="F:NDepend.Project.TemporaryProjectMode.Temporary" />, <see cref="F:NDepend.Project.TemporaryProjectMode.TemporaryNewer" /> and <see cref="F:NDepend.Project.TemporaryProjectMode.TemporaryOlder" />.<br />
            Be aware that calling this method erases the current temporary project corresponding to <paramref name="temporaryProjectMode" />.
            </remarks>
      <param name="applicationAssemblies">Application assemblies file paths to analyze.</param>
      <param name="temporaryProjectMode">The temporary project mode: <see cref="F:NDepend.Project.TemporaryProjectMode.Temporary" />, <see cref="F:NDepend.Project.TemporaryProjectMode.TemporaryNewer" /> or <see cref="F:NDepend.Project.TemporaryProjectMode.TemporaryOlder" />.</param>
      <returns>The project object initialized.</returns>
      <exception cref="T:NDepend.Project.ProjectException">Problem with creating a temporary project.</exception>
      <seealso cref="P:NDepend.Project.IProjectProperties.TemporaryProjectMode" />
      <requires description="The collection of paths must not be null" csharp="applicationAssemblies != null" vb="applicationAssemblies &lt;&gt; Nothing">applicationAssemblies != null</requires>
      <requires description="temporaryProjectMode must be different than TemporaryProjectMode.None" csharp="temporaryProjectMode != (decimal)0" vb="temporaryProjectMode &lt;&gt; ((NDepend.Project.TemporaryProjectMode)0)">temporaryProjectMode != (decimal)0</requires>
    </member>
    <member name="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)">
      <summary>
            Shows a dialog that allows the user select a set of assemblies files.
            </summary>
      <returns>true if the user clicked OK, false if the user clicked Cancel.</returns>
      <param name="applicationAssemblies">Application assemblies file paths choosen</param>
      <exception cref="T:System.Threading.ThreadStateException">This operation needs the current thread to be a STA thread. To do so, just tag your Main() method with the [STAThread] attribute.</exception>
      <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
      <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogChooseAnExistingProject(NDepend.Project.IProject@)" />
      <seealso cref="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.ShowDialogSelectVisualStudioSolutionsOrProjects(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
      <seealso cref="M:NDepend.Analysis.IAnalysisManager.ShowDialogBuildComparison(NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@,NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@)" />
      <ensures description="returned applicationAssemblies is not null if this method returns true" csharp="result ⇒ applicationAssemblies != null" vb="result Implies applicationAssemblies &lt;&gt; Nothing">!result || applicationAssemblies != null</ensures>
    </member>
    <member name="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)">
      <summary>
            Shows a dialog that allows the user select a set of assemblies files.
            </summary>
      <param name="applicationAssembliesIn">A collection of file paths to the assemblies that the dialog initially shows to the user.</param>
      <param name="applicationAssembliesOut">Application assemblies file paths choosen</param>
      <returns>true if the user clicked OK, false if the user clicked Cancel.</returns>
      <exception cref="T:System.Threading.ThreadStateException">This operation needs the current thread to be a STA thread. To do so, just tag your Main() method with the [STAThread] attribute.</exception>
      <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
      <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogChooseAnExistingProject(NDepend.Project.IProject@)" />
      <seealso cref="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.ShowDialogSelectVisualStudioSolutionsOrProjects(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
      <seealso cref="M:NDepend.Analysis.IAnalysisManager.ShowDialogBuildComparison(NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@,NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@)" />
      <requires description="The collection of paths must not be null" csharp="applicationAssembliesIn != null" vb="applicationAssembliesIn &lt;&gt; Nothing">applicationAssembliesIn != null</requires>
      <ensures description="returned applicationAssembliesOut is not null if this method returns true" csharp="result ⇒ applicationAssembliesOut != null" vb="result Implies applicationAssembliesOut &lt;&gt; Nothing">!result || applicationAssembliesOut != null</ensures>
    </member>
    <member name="M:NDepend.Project.IProjectManager.ShowDialogChooseAnExistingProject(NDepend.Project.IProject@)">
      <summary>
            Shows a dialog that allows the user select an existing NDepend project.
            </summary>
      <param name="project">The project choosen.</param>
      <returns>true if the user clicked OK, false if the user clicked Cancel</returns>
      <exception cref="T:System.Threading.ThreadStateException">This operation needs the current thread to be a STA thread. To do so, just tag your Main() method with the [STAThread] attribute.</exception>
      <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
      <seealso cref="M:NDepend.Project.IProjectManager.ShowDialogSelectAssemblies(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
      <seealso cref="M:NDepend.DotNet.VisualStudio.IVisualStudioManager.ShowDialogSelectVisualStudioSolutionsOrProjects(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath}@)" />
      <seealso cref="M:NDepend.Analysis.IAnalysisManager.ShowDialogBuildComparison(NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@,NDepend.Project.IProject@,NDepend.Analysis.IAnalysisResultRef@)" />
      <ensures description="returned project is not null if this method returns true" csharp="result ⇒ project != null" vb="result Implies project &lt;&gt; Nothing">!result || project != null</ensures>
    </member>
    <member name="T:NDepend.Project.TemporaryProjectMode">
      <summary>
            Specifies if a project is temporary or not. Three temporary projects can co-exist. <see cref="F:NDepend.Project.TemporaryProjectMode.TemporaryNewer" /> and <see cref="F:NDepend.Project.TemporaryProjectMode.TemporaryOlder" /> values are useful if you wish to compare two temporary projects.
            </summary>
    </member>
    <member name="F:NDepend.Project.TemporaryProjectMode.None">
      <summary>None</summary>
    </member>
    <member name="F:NDepend.Project.TemporaryProjectMode.Temporary">
      <summary>Temporary</summary>
    </member>
    <member name="F:NDepend.Project.TemporaryProjectMode.TemporaryOlder">
      <summary>TemporaryOlder</summary>
    </member>
    <member name="F:NDepend.Project.TemporaryProjectMode.TemporaryNewer">
      <summary>TemporaryNewer</summary>
    </member>
    <member name="T:NDepend.Project.IProjectProperties">
      <summary>
            Represents main properties of an NDepend project.
            </summary>
    </member>
    <member name="P:NDepend.Project.IProjectProperties.Name">
      <summary>
            Gets or sets the name of the NDepend project.
            </summary>
      <remarks>
            When the name is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.Name" /> activated.<br /></remarks>
      <getter>
        <ensures description="returned project name string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned project name string is not empty nor only spaces characters" csharp="result.Trim().Length &gt; 0" vb="result.Trim().Length &gt; 0">result.Trim().Length &gt; 0</ensures>
      </getter>
      <setter>
        <requires description="project name string cannot be null" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
        <requires description="project name string cannot be empty or only spaces characters" csharp="value.Trim().Length &gt; 0" vb="value.Trim().Length &gt; 0">value.Trim().Length &gt; 0</requires>
      </setter>
    </member>
    <member name="P:NDepend.Project.IProjectProperties.OutputDir">
      <summary>
            Gets or sets the output directory path of the NDepend project, the path where all analysis results will be stored.
            </summary>
      <remarks>
            If you try to set a relative directory while the project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" /> is equal to <see cref="P:NDepend.Project.IProjectProperties.PathMode" />.<see cref="F:NDepend.Path.PathMode.Absolute" />, the setter does nothing and returns.<br />
            If you try to set an absolute directory while the project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" /> is equal to <see cref="P:NDepend.Project.IProjectProperties.PathMode" />.<see cref="F:NDepend.Path.PathMode.Relative" />, the setter does nothing and returns.<br />
            When the output directory is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.OutputDirectory" /> activated.<br /></remarks>
      <getter>
        <ensures description="returned path is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned path is not empty" csharp="!result.IsEmpty" vb="Not result.IsEmpty">!result.IsEmpty</ensures>
      </getter>
      <setter>
        <requires description="project output directory path cannot be null" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
        <requires description="project output directory path cannot be empty" csharp="!value.IsEmpty" vb="Not value.IsEmpty">!value.IsEmpty</requires>
      </setter>
    </member>
    <member name="P:NDepend.Project.IProjectProperties.FilePath">
      <summary>
            Gets or sets the NDepend project file path.
            </summary>
      <remarks>
            It is not recommended to change the project file path if project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" /> is equal to <see cref="P:NDepend.Project.IProjectProperties.PathMode" />.<see cref="F:NDepend.Path.PathMode.Relative" />.<br />
            Indeed, in such situation most of directories and files referenced by the project are relative to the <see cref="P:NDepend.Project.IProjectProperties.FilePath" />.<br />
            When the file path is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.FilePath" /> activated.<br /></remarks>
      <getter>
        <ensures description="returned path is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned path is not empty" csharp="!result.IsEmpty" vb="Not result.IsEmpty">!result.IsEmpty</ensures>
      </getter>
      <setter>
        <requires description="project file path cannot be null" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
        <requires description="project file path cannot be empty" csharp="!value.IsEmpty" vb="Not value.IsEmpty">!value.IsEmpty</requires>
      </setter>
    </member>
    <member name="P:NDepend.Project.IProjectProperties.PathMode">
      <summary>
            Gets or sets the path mode of the project to absolute or relative.
            </summary>
      <remarks>
            If project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" /> is equal to <see cref="P:NDepend.Project.IProjectProperties.PathMode" />.<see cref="F:NDepend.Path.PathMode.Relative" />, it means that most of directories and files referenced by the project are relative to the project.<see cref="P:NDepend.Project.IProject.Properties" /><see cref="P:NDepend.Project.IProjectProperties.FilePath" />.<br />
            Following paths are impacted: <br />
            - project.<see cref="P:NDepend.Project.IProject.CodeToAnalyze" />.<see cref="P:NDepend.Project.IProjectCodeToAnalyze.Directories" /><br />
            - project.<see cref="P:NDepend.Project.IProject.Coverage" />.<see cref="P:NDepend.Project.IProjectCoverage.CoverageFiles" /><br />
            - project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.OutputDir" /><br />
            - project.<see cref="P:NDepend.Project.IProject.Report" />.<see cref="P:NDepend.Project.IProjectReport.ReportFilePath" /><br />
            When the path mode is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.PathMode" /> activated.<br />
            If the path mode cannot be changed, the setter do nothing and returns.<br />
            To know if the path mode can be changed before calling the path mode setter, call the method <see cref="T:NDepend.Project.IProjectManager" />.<see cref="M:NDepend.Project.IProjectManager.CanSwitchToPathMode(NDepend.Project.IProject,NDepend.Path.PathMode,System.String@)" /><br />.
            </remarks>
      <seealso cref="M:NDepend.Project.IProjectManager.CanSwitchToPathMode(NDepend.Project.IProject,NDepend.Path.PathMode,System.String@)" />
      <seealso cref="P:NDepend.Project.IProjectCodeToAnalyze.Directories" />
      <seealso cref="P:NDepend.Project.IProjectCoverage.CoverageFiles" />
      <seealso cref="P:NDepend.Project.IProjectReport.ReportFilePath" />
      <seealso cref="P:NDepend.Project.IProjectProperties.OutputDir" />
    </member>
    <member name="P:NDepend.Project.IProjectProperties.TemporaryProjectMode">
      <summary>
            Gets a value indicating whether this project is a temporary project or not.
            </summary>
      <remarks>
            By working with temporary projects, you can create and experiment with a project without specifying a disk location or a project name.<br /></remarks>
      <seealso cref="M:NDepend.Project.IProjectManager.CreateTemporaryProject(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},NDepend.Project.TemporaryProjectMode)" />
    </member>
    <member name="P:NDepend.Project.IProjectProperties.KeepXmlFiles">
      <summary>
            Gets or sets a boolean value indicating whether at the end of an analysis, the XML files used to generate the report through a XSL transformation, are kept or not.
            </summary>
      <remarks>
            When the property is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.KeepXmlFiles" /> activated.<br /></remarks>
    </member>
    <member name="T:NDepend.Project.IProjectCodeQueries">
      <summary>
            Represents this NDepend project code queries and code rules.
            </summary>
      <seealso cref="N:NDepend.CodeQuery" />
    </member>
    <member name="M:NDepend.Project.IProjectCodeQueries.SetDefaultCodeQueries">
      <summary>
            Set the set of default code rules and queries for this NDepend project.
            </summary>
    </member>
    <member name="P:NDepend.Project.IProjectCodeQueries.CodeQueriesSet">
      <summary>
            Gets or sets the set of code rules and queries for this NDepend project.
            </summary>
      <remarks>
            If this NDepend project file exists, the set of code rules and queries data is loaded from and saved to the project file, each time this property getter or setter is invoked.<br />
            If this NDepend project file doesn't exist, the set of code rules and queries data is loaded from and saved to, in memory.<br />
            (property getter only) If this NDepend project file XML content is corrupted, the set of default queries is returned.
            </remarks>
      <exception cref="T:System.IO.IOException">(property setter only) The project file exists but cannot be written.</exception>
      <getter>
        <ensures description="returned set of code rules and queries is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
      <setter>
        <requires description="inputed set of code rules and queries must not be null" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      </setter>
    </member>
    <member name="T:NDepend.Project.IProjectSourceFilesRebasing">
      <summary>
            Represents an NDepend project's analysis time source files rebasing settings.
            </summary>
      <remarks>
        <see cref="T:NDepend.Project.IProjectSourceFilesRebasing" /> settings are useful if the source code compilation occurs on a machine, but NDepend analysis is executed on another machine, where source files are nested in a different root directory.<br />
            Hence source files rebasing settings are used to rebase source files paths at analysis time.
            </remarks>
    </member>
    <member name="P:NDepend.Project.IProjectSourceFilesRebasing.FromPath">
      <summary>
            Gets or sets the deeper folder that contains all source files of the application at compile time. An empty path means that the analysis time rebasing possibility is not used.
            </summary>
      <getter>
        <ensures description="returned path is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
      <setter>
        <requires description="path cannot be null" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      </setter>
    </member>
    <member name="P:NDepend.Project.IProjectSourceFilesRebasing.ToPath">
      <summary>
            Gets or sets the deeper folder that contains all source files of the application during NDepend analysis time. An empty path means that the analysis time rebasing possibility is not used.
            </summary>
      <getter>
        <ensures description="returned path is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
      <setter>
        <requires description="path cannot be null" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      </setter>
    </member>
    <member name="T:NDepend.Project.IProjectRef">
      <summary>
            Represents a reference to a NDepend project.
            </summary>
    </member>
    <member name="M:NDepend.Project.IProjectRef.Load">
      <summary>
            Loads a project from this project reference.
            </summary>
      <returns>The project loaded.</returns>
      <exception cref="T:NDepend.Project.ProjectException">The project cannot be loaded, the exception message describes the failure reason.</exception>
      <ensures description="returned project is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:NDepend.Project.IProjectRef.ProjectName">
      <summary>
            Gets the NDepend project name.
            </summary>
      <getter>
        <ensures description="returned project name string is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned project name string is not empty nor only spaces characters" csharp="result.Trim().Length &gt; 0" vb="result.Trim().Length &gt; 0">result.Trim().Length &gt; 0</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProjectRef.ProjectFilePath">
      <summary>
            Gets the NDepend project file path.
            </summary>
      <getter>
        <ensures description="returned path is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned path is not empty" csharp="!result.IsEmpty" vb="Not result.IsEmpty">!result.IsEmpty</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProjectRef.DateLastTouched">
      <summary>
            Gets the date representing the last time the project has been used through NDepend user interface.
            </summary>
    </member>
    <member name="P:NDepend.Project.IProjectRef.TemporaryProjectMode">
      <summary>
            Gets a value indicating whether this project is a temporary project or not.
            </summary>
      <remarks>
            By working with temporary projects, you can create and experiment with a project without specifying a disk location or a project name.<br /></remarks>
      <seealso cref="M:NDepend.Project.IProjectManager.CreateTemporaryProject(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},NDepend.Project.TemporaryProjectMode)" />
    </member>
    <member name="T:NDepend.Project.ReportFormat">
      <summary>
            Represents the report format option.
            </summary>
    </member>
    <member name="F:NDepend.Project.ReportFormat.Standard">
      <summary>Standard</summary>
    </member>
    <member name="F:NDepend.Project.ReportFormat.StandardOldStyle">
      <summary>StandardOldStyle</summary>
    </member>
    <member name="F:NDepend.Project.ReportFormat.CustomXsl">
      <summary>CustomXsl</summary>
    </member>
    <member name="F:NDepend.Project.ReportFormat.Default">
      <summary>Default</summary>
    </member>
    <member name="T:NDepend.Project.ReportSections">
      <summary>
            Represents an array of flags that indicates a sub set of possible report sections.
            </summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.ApplicationMetrics">
      <summary>ApplicationMetrics</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.AssembliesMetrics">
      <summary>AssembliesMetrics</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.TreemapMetricView">
      <summary>TreemapMetricView</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.AssembliesAbstractnessVSInstability">
      <summary>AssembliesAbstractnessVSInstability</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.AssembliesDependencies">
      <summary>AssembliesDependencies</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.AssembliesDependencyGraph">
      <summary>AssembliesDependencyGraph</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.AssembliesDependencyMatrix">
      <summary>AssembliesDependencyMatrix</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.AssembliesBuildOrder">
      <summary>AssembliesBuildOrder</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.AnalysisLog">
      <summary>AnalysisLog</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.CodeRules">
      <summary>CodeRules</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.CodeQueries">
      <summary>CodeQueries</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.TypesMetrics">
      <summary>TypesMetrics</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.TypesDependencies">
      <summary>TypesDependencies</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.NamespacesMetrics">
      <summary>NamespacesMetrics</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.NamespacesDependencies">
      <summary>NamespacesDependencies</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.None">
      <summary>None</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.All">
      <summary>All</summary>
    </member>
    <member name="F:NDepend.Project.ReportSections.Default">
      <summary>Default</summary>
    </member>
    <member name="T:NDepend.Project.ReportOptionsFlags">
      <summary>
            Represents an array of flags that indicates various boolean report options.
            </summary>
    </member>
    <member name="F:NDepend.Project.ReportOptionsFlags.None">
      <summary>None</summary>
    </member>
    <member name="F:NDepend.Project.ReportOptionsFlags.ValueUsedWhenNoOptionFlagsFoundInXML">
      <summary>ValueUsedWhenNoOptionFlagsFoundInXML</summary>
    </member>
    <member name="F:NDepend.Project.ReportOptionsFlags.HideTierAssembliesInGraph">
      <summary>HideTierAssembliesInGraph</summary>
    </member>
    <member name="F:NDepend.Project.ReportOptionsFlags.GraphLayoutDirectionTopToBottom">
      <summary>GraphLayoutDirectionTopToBottom</summary>
    </member>
    <member name="F:NDepend.Project.ReportOptionsFlags.HideTypesMetricsOnLargeApp">
      <summary>HideTypesMetricsOnLargeApp</summary>
    </member>
    <member name="F:NDepend.Project.ReportOptionsFlags.HideTypesDependenciesOnLargeApp">
      <summary>HideTypesDependenciesOnLargeApp</summary>
    </member>
    <member name="F:NDepend.Project.ReportOptionsFlags.DontShowTooManyCodeRulesMatchedItems">
      <summary>DontShowTooManyCodeRulesMatchedItems</summary>
    </member>
    <member name="F:NDepend.Project.ReportOptionsFlags.HideNamespacesMetricsOnLargeApp">
      <summary>HideNamespacesMetricsOnLargeApp</summary>
    </member>
    <member name="F:NDepend.Project.ReportOptionsFlags.HideNamespacesDependenciesOnLargeApp">
      <summary>HideNamespacesDependenciesOnLargeApp</summary>
    </member>
    <member name="F:NDepend.Project.ReportOptionsFlags.AllowBreakLongLine">
      <summary>AllowBreakLongLine</summary>
    </member>
    <member name="F:NDepend.Project.ReportOptionsFlags.Default">
      <summary>Default</summary>
    </member>
    <member name="T:NDepend.Project.IProjectReport">
      <summary>
            Represents report settings of an NDepend project.
            </summary>
    </member>
    <member name="P:NDepend.Project.IProjectReport.ReportFilePath">
      <summary>
            Gets the report file path in project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.OutputDir" />.
            </summary>
      <getter>
        <ensures description="returned path is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures description="returned path is not empty" csharp="!result.IsEmpty" vb="Not result.IsEmpty">!result.IsEmpty</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Project.IProjectReport.ReportFormat">
      <summary>
            Gets or sets a value that determines the report format.
            </summary>
      <remarks>
            When this value is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.ReportFormat" /> activated.<br /></remarks>
    </member>
    <member name="P:NDepend.Project.IProjectReport.ReportSectionsEnabled">
      <summary>
            Gets or sets an array of flags that indicates enabled report sections.
            </summary>
      <remarks>
            This <see cref="P:NDepend.Project.IProjectReport.ReportSectionsEnabled" /> value is useless if <see cref="P:NDepend.Project.IProjectReport.ReportFormat" /> is equal to <see cref="F:NDepend.Project.ReportFormat.StandardOldStyle" />.<br />
            When this value is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.ReportSectionsEnabled" /> activated.<br /></remarks>
    </member>
    <member name="P:NDepend.Project.IProjectReport.ReportXslPath">
      <summary>
            Gets or sets the path to the report XSL file. A null or empty value for this path means that the user wants to use the default Xsl sheet to build report.
            </summary>
      <remarks>
            If you try to set a relative file path while the project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" /> is equal to <see cref="T:NDepend.Path.PathMode" />.<see cref="F:NDepend.Path.PathMode.Absolute" />, the setter does nothing and returns.<br />
            If you try to set an absolute file path while the project.<see cref="P:NDepend.Project.IProject.Properties" />.<see cref="P:NDepend.Project.IProjectProperties.PathMode" /> is equal to <see cref="T:NDepend.Path.PathMode" />.<see cref="F:NDepend.Path.PathMode.Relative" />, the setter does nothing and returns.<br />
            When the report XSL file path is changed, the event <see cref="T:NDepend.Project.IProject" />.<see cref="E:NDepend.Project.IProject.SettingsChanged" /> is triggered with the flag <see cref="T:NDepend.Project.ProjectSettings" />.<see cref="F:NDepend.Project.ProjectSettings.ReportXslPath" /> activated.<br /></remarks>
    </member>
    <member name="P:NDepend.Project.IProjectReport.ReportOptionsFlags">
      <summary>
            Gets or sets an array of flags that indicates various boolean report options.
            </summary>
    </member>
    <member name="T:NDepend.Project.IProjectDisabledWarnings">
      <summary>
            Represents the collection of analysis time warnings disabled, of an NDepend project.
            </summary>
      <remarks>
            Disabling some warnings is useful to avoid being warned again and again with recurring warnings at analysis time.
            </remarks>
    </member>
    <member name="P:NDepend.Project.IProjectDisabledWarnings.WarningsDisabled">
      <summary>
            Get or set the set of warnings disabled for this project.
            </summary>
      <remarks>
            If the project file exists, this data is loaded from and saved in the project file.<br />
            (getter only) If the project file is corrupted, an empty collection is returned.
            </remarks>
      <exception cref="T:System.IO.IOException">(setter only) The project file cannot be written.</exception>
      <getter>
        <ensures description="returned collection is not null" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
      <setter>
        <requires description="inputed collection must not be null" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      </setter>
    </member>
    <member name="T:NDepend.Project.ProjectException">
      <summary>
            The exception that is thrown when a project related operation fails.
            </summary>
      <remarks>
            Methods potentially throwing this exception are: <br />
            IProjectCodeToAnalyze.<see cref="M:NDepend.Project.IProjectCodeToAnalyze.SetApplicationAssemblies(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath})" /><br />
            IProjectManager.<see cref="M:NDepend.Project.IProjectManager.LoadProject(NDepend.Path.IAbsoluteFilePath)" /><br />
            IProjectManager.<see cref="M:NDepend.Project.IProjectManager.SaveProject(NDepend.Project.IProject)" /><br />
            IProjectManager.<see cref="M:NDepend.Project.IProjectManager.CreateTemporaryProject(System.Collections.Generic.ICollection{NDepend.Path.IAbsoluteFilePath},NDepend.Project.TemporaryProjectMode)" /><br />
            IProjectRef.<see cref="M:NDepend.Project.IProjectRef.Load" /><br /></remarks>
    </member>
    <member name="M:NDepend.Project.ProjectException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NDepend.Project.ProjectException" /> class with a specified error message.
            </summary>
      <param name="message">A message that describes the error.</param>
    </member>
    <member name="T:NDepend.Project.ProjectSettings">
      <summary>
            Represents a bit array of an NDepend project settings.
            </summary>
      <remarks>This bit array enumeration is useful to know which settings of an NDepend project have been changed through the event <see cref="E:NDepend.Project.IProject.SettingsChanged" />.</remarks>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.None">
      <summary>None</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.ApplicationComponents">
      <summary>ApplicationComponents</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.ThirdPartyComponents">
      <summary>ThirdPartyComponents</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.Directories">
      <summary>Directories</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.Name">
      <summary>Name</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.OutputDirectory">
      <summary>OutputDirectory</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.FilePath">
      <summary>FilePath</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.PathMode">
      <summary>PathMode</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.KeepXmlFiles">
      <summary>KeepXmlFiles</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.ReportXslPath">
      <summary>ReportXslPath</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.ReportFormat">
      <summary>ReportFormat</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.ReportSectionsEnabled">
      <summary>ReportSectionsEnabled</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.ReportOptionFlags">
      <summary>ReportOptionFlags</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.ReportOldStyleSectionsOrdered">
      <summary>ReportOldStyleSectionsOrdered</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.ReportOldStyleSectionsEnabled">
      <summary>ReportOldStyleSectionsEnabled</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.WarningsDisabled">
      <summary>WarningsDisabled</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.KeepHistoric">
      <summary>KeepHistoric</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.BuildComparisonProjectMode">
      <summary>BuildComparisonProjectMode</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.BuildComparisonAnalysisMode">
      <summary>BuildComparisonAnalysisMode</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.BuildComparisonMadeNDaysAgo">
      <summary>BuildComparisonMadeNDaysAgo</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.BaselineOtherProjectFilePath">
      <summary>BaselineOtherProjectFilePath</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.BaselineParticularAnalysisResultFilePath">
      <summary>BaselineParticularAnalysisResultFilePath</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.CodeQueryRawXml">
      <summary>CodeQueryRawXml</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.Coverage">
      <summary>Coverage</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.RebasingFromPath">
      <summary>RebasingFromPath</summary>
    </member>
    <member name="F:NDepend.Project.ProjectSettings.RebasingToPath">
      <summary>RebasingToPath</summary>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.DicoLookup`2.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.DicoLookup`2.Grouping.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:NDepend.Helpers.ExtensionMethodsEnumerable.DicoLookup`2.Grouping.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="P:NDepend.Helpers.ExtensionMethodsEnumerable.DicoLookup`2.Count">
      <getter>
        <ensures inheritedFrom="M:System.Linq.ILookup`2.get_Count" inheritedFromTypeName="ILookup" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Helpers.ExtensionMethodsEnumerable.DicoLookup`2.Item(`0)">
      <getter>
        <ensures inheritedFrom="M:System.Linq.ILookup`2.get_Item(`0)" inheritedFromTypeName="ILookup" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:NDepend.Path.PathHelpers.PathBase.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Path.PathHelpers.AbsoluteDirectoryPath.GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
      <requires description="pivotDirectory must not be null" inheritedFrom="M:NDepend.Path.IAbsoluteDirectoryPath.GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IAbsoluteDirectoryPath" csharp="pivotDirectory != null" vb="pivotDirectory &lt;&gt; Nothing">pivotDirectory != null</requires>
      <requires description="pivotDirectory must not be empty" inheritedFrom="M:NDepend.Path.IAbsoluteDirectoryPath.GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IAbsoluteDirectoryPath" csharp="!pivotDirectory.IsEmpty" vb="Not pivotDirectory.IsEmpty">!pivotDirectory.IsEmpty</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.AbsoluteDirectoryPath.NDepend#Path#IAbsolutePath#GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
      <requires description="pivotDirectory must not be null" inheritedFrom="M:NDepend.Path.IAbsolutePath.GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IAbsolutePath" csharp="pivotDirectory != null" vb="pivotDirectory &lt;&gt; Nothing">pivotDirectory != null</requires>
      <requires description="pivotDirectory must not be empty" inheritedFrom="M:NDepend.Path.IAbsolutePath.GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IAbsolutePath" csharp="!pivotDirectory.IsEmpty" vb="Not pivotDirectory.IsEmpty">!pivotDirectory.IsEmpty</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.AbsoluteDirectoryPath.GetBrotherFileWithName(System.String)">
      <requires description="fileName must not be null" inheritedFrom="M:NDepend.Path.IAbsoluteDirectoryPath.GetBrotherFileWithName(System.String)" inheritedFromTypeName="IAbsoluteDirectoryPath" csharp="fileName != null" vb="fileName &lt;&gt; Nothing">fileName != null</requires>
      <requires description="fileName must not be empty" inheritedFrom="M:NDepend.Path.IAbsoluteDirectoryPath.GetBrotherFileWithName(System.String)" inheritedFromTypeName="IAbsoluteDirectoryPath" csharp="fileName.Length &gt; 0" vb="fileName.Length &gt; 0">fileName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.AbsoluteDirectoryPath.GetBrotherDirectoryWithName(System.String)">
      <requires description="directoryName must not be null" inheritedFrom="M:NDepend.Path.IAbsoluteDirectoryPath.GetBrotherDirectoryWithName(System.String)" inheritedFromTypeName="IAbsoluteDirectoryPath" csharp="directoryName != null" vb="directoryName &lt;&gt; Nothing">directoryName != null</requires>
      <requires description="directoryName must not be empty" inheritedFrom="M:NDepend.Path.IAbsoluteDirectoryPath.GetBrotherDirectoryWithName(System.String)" inheritedFromTypeName="IAbsoluteDirectoryPath" csharp="directoryName.Length &gt; 0" vb="directoryName.Length &gt; 0">directoryName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.AbsoluteDirectoryPath.GetChildFileWithName(System.String)">
      <requires description="fileName must not be null" inheritedFrom="M:NDepend.Path.IAbsoluteDirectoryPath.GetChildFileWithName(System.String)" inheritedFromTypeName="IAbsoluteDirectoryPath" csharp="fileName != null" vb="fileName &lt;&gt; Nothing">fileName != null</requires>
      <requires description="fileName must not be empty" inheritedFrom="M:NDepend.Path.IAbsoluteDirectoryPath.GetChildFileWithName(System.String)" inheritedFromTypeName="IAbsoluteDirectoryPath" csharp="fileName.Length &gt; 0" vb="fileName.Length &gt; 0">fileName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.AbsoluteDirectoryPath.GetChildDirectoryWithName(System.String)">
      <requires description="directoryName must not be null" inheritedFrom="M:NDepend.Path.IAbsoluteDirectoryPath.GetChildDirectoryWithName(System.String)" inheritedFromTypeName="IAbsoluteDirectoryPath" csharp="directoryName != null" vb="directoryName &lt;&gt; Nothing">directoryName != null</requires>
      <requires description="directoryName must not be empty" inheritedFrom="M:NDepend.Path.IAbsoluteDirectoryPath.GetChildDirectoryWithName(System.String)" inheritedFromTypeName="IAbsoluteDirectoryPath" csharp="directoryName.Length &gt; 0" vb="directoryName.Length &gt; 0">directoryName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.AbsoluteDirectoryPath.IsChildDirectoryOf(NDepend.Path.IAbsoluteDirectoryPath)">
      <requires description="parentDir must not be null" inheritedFrom="M:NDepend.Path.IAbsoluteDirectoryPath.IsChildDirectoryOf(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IAbsoluteDirectoryPath" csharp="parentDirectory != null" vb="parentDirectory &lt;&gt; Nothing">parentDirectory != null</requires>
      <requires description="parentDir must not be empty" inheritedFrom="M:NDepend.Path.IAbsoluteDirectoryPath.IsChildDirectoryOf(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IAbsoluteDirectoryPath" csharp="!parentDirectory.IsEmpty" vb="Not parentDirectory.IsEmpty">!parentDirectory.IsEmpty</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.RelativeDirectoryPath.GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
      <requires description="pivotDirectory is null" inheritedFrom="M:NDepend.Path.IRelativeDirectoryPath.GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IRelativeDirectoryPath" csharp="pivotDirectory != null" vb="pivotDirectory &lt;&gt; Nothing">pivotDirectory != null</requires>
      <requires description="pivotDirectory must not be empty" inheritedFrom="M:NDepend.Path.IRelativeDirectoryPath.GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IRelativeDirectoryPath" csharp="!pivotDirectory.IsEmpty" vb="Not pivotDirectory.IsEmpty">!pivotDirectory.IsEmpty</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.RelativeDirectoryPath.NDepend#Path#IRelativePath#GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
      <requires description="pivotDirectory must not be null" inheritedFrom="M:NDepend.Path.IRelativePath.GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IRelativePath" csharp="pivotDirectory != null" vb="pivotDirectory &lt;&gt; Nothing">pivotDirectory != null</requires>
      <requires description="pivotDirectory must not be empty" inheritedFrom="M:NDepend.Path.IRelativePath.GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IRelativePath" csharp="!pivotDirectory.IsEmpty" vb="Not pivotDirectory.IsEmpty">!pivotDirectory.IsEmpty</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.RelativeDirectoryPath.GetBrotherFileWithName(System.String)">
      <requires description="fileName is null" inheritedFrom="M:NDepend.Path.IRelativeDirectoryPath.GetBrotherFileWithName(System.String)" inheritedFromTypeName="IRelativeDirectoryPath" csharp="fileName != null" vb="fileName &lt;&gt; Nothing">fileName != null</requires>
      <requires description="fileName must not be empty" inheritedFrom="M:NDepend.Path.IRelativeDirectoryPath.GetBrotherFileWithName(System.String)" inheritedFromTypeName="IRelativeDirectoryPath" csharp="fileName.Length &gt; 0" vb="fileName.Length &gt; 0">fileName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.RelativeDirectoryPath.GetBrotherDirectoryWithName(System.String)">
      <requires description="directoryName is null" inheritedFrom="M:NDepend.Path.IRelativeDirectoryPath.GetBrotherDirectoryWithName(System.String)" inheritedFromTypeName="IRelativeDirectoryPath" csharp="directoryName != null" vb="directoryName &lt;&gt; Nothing">directoryName != null</requires>
      <requires description="directoryName must not be empty" inheritedFrom="M:NDepend.Path.IRelativeDirectoryPath.GetBrotherDirectoryWithName(System.String)" inheritedFromTypeName="IRelativeDirectoryPath" csharp="directoryName.Length &gt; 0" vb="directoryName.Length &gt; 0">directoryName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.RelativeDirectoryPath.GetChildFileWithName(System.String)">
      <requires description="fileName is null" inheritedFrom="M:NDepend.Path.IRelativeDirectoryPath.GetChildFileWithName(System.String)" inheritedFromTypeName="IRelativeDirectoryPath" csharp="fileName != null" vb="fileName &lt;&gt; Nothing">fileName != null</requires>
      <requires description="fileName must not be empty" inheritedFrom="M:NDepend.Path.IRelativeDirectoryPath.GetChildFileWithName(System.String)" inheritedFromTypeName="IRelativeDirectoryPath" csharp="fileName.Length &gt; 0" vb="fileName.Length &gt; 0">fileName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.RelativeDirectoryPath.GetChildDirectoryWithName(System.String)">
      <requires description="directoryName is null" inheritedFrom="M:NDepend.Path.IRelativeDirectoryPath.GetChildDirectoryWithName(System.String)" inheritedFromTypeName="IRelativeDirectoryPath" csharp="directoryName != null" vb="directoryName &lt;&gt; Nothing">directoryName != null</requires>
      <requires description="directoryName must not be empty" inheritedFrom="M:NDepend.Path.IRelativeDirectoryPath.GetChildDirectoryWithName(System.String)" inheritedFromTypeName="IRelativeDirectoryPath" csharp="directoryName.Length &gt; 0" vb="directoryName.Length &gt; 0">directoryName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.Drive.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Path.PathHelpers.FilePath.HasExtension(System.String)">
      <requires description="extension must not be null" inheritedFrom="M:NDepend.Path.IFilePath.HasExtension(System.String)" inheritedFromTypeName="IFilePath" csharp="extension != null" vb="extension &lt;&gt; Nothing">extension != null</requires>
      <requires description="extension must have at least two characters" inheritedFrom="M:NDepend.Path.IFilePath.HasExtension(System.String)" inheritedFromTypeName="IFilePath" csharp="extension.Length &gt;= 2" vb="extension.Length &gt;= 2">extension.Length &gt;= 2</requires>
      <requires description="extension first character must be a dot" inheritedFrom="M:NDepend.Path.IFilePath.HasExtension(System.String)" inheritedFromTypeName="IFilePath" csharp="extension.Chars[0] == '.'" vb="extension.Chars[0] = '.'">extension.Chars[0] == '.'</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.AbsoluteFilePath.GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
      <requires description="pivotDirectory must not be null" inheritedFrom="M:NDepend.Path.IAbsoluteFilePath.GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IAbsoluteFilePath" csharp="pivotDirectory != null" vb="pivotDirectory &lt;&gt; Nothing">pivotDirectory != null</requires>
      <requires description="pivotDirectory must not be empty" inheritedFrom="M:NDepend.Path.IAbsoluteFilePath.GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IAbsoluteFilePath" csharp="!pivotDirectory.IsEmpty" vb="Not pivotDirectory.IsEmpty">!pivotDirectory.IsEmpty</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.AbsoluteFilePath.NDepend#Path#IAbsolutePath#GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
      <requires description="pivotDirectory must not be null" inheritedFrom="M:NDepend.Path.IAbsolutePath.GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IAbsolutePath" csharp="pivotDirectory != null" vb="pivotDirectory &lt;&gt; Nothing">pivotDirectory != null</requires>
      <requires description="pivotDirectory must not be empty" inheritedFrom="M:NDepend.Path.IAbsolutePath.GetRelativePathFrom(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IAbsolutePath" csharp="!pivotDirectory.IsEmpty" vb="Not pivotDirectory.IsEmpty">!pivotDirectory.IsEmpty</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.AbsoluteFilePath.GetBrotherFileWithName(System.String)">
      <requires description="fileName must not be null" inheritedFrom="M:NDepend.Path.IAbsoluteFilePath.GetBrotherFileWithName(System.String)" inheritedFromTypeName="IAbsoluteFilePath" csharp="fileName != null" vb="fileName &lt;&gt; Nothing">fileName != null</requires>
      <requires description="fileName must not be empty" inheritedFrom="M:NDepend.Path.IAbsoluteFilePath.GetBrotherFileWithName(System.String)" inheritedFromTypeName="IAbsoluteFilePath" csharp="fileName.Length &gt; 0" vb="fileName.Length &gt; 0">fileName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.AbsoluteFilePath.GetBrotherDirectoryWithName(System.String)">
      <requires description="directoryName must not be null" inheritedFrom="M:NDepend.Path.IAbsoluteFilePath.GetBrotherDirectoryWithName(System.String)" inheritedFromTypeName="IAbsoluteFilePath" csharp="directoryName != null" vb="directoryName &lt;&gt; Nothing">directoryName != null</requires>
      <requires description="directoryName must not be empty" inheritedFrom="M:NDepend.Path.IAbsoluteFilePath.GetBrotherDirectoryWithName(System.String)" inheritedFromTypeName="IAbsoluteFilePath" csharp="directoryName.Length &gt; 0" vb="directoryName.Length &gt; 0">directoryName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.AbsoluteFilePath.UpdateExtension(System.String)">
      <requires description="newExtension must not be null" inheritedFrom="M:NDepend.Path.IAbsoluteFilePath.UpdateExtension(System.String)" inheritedFromTypeName="IAbsoluteFilePath" csharp="newExtension != null" vb="newExtension &lt;&gt; Nothing">newExtension != null</requires>
      <requires description="newExtension must have at least two characters" inheritedFrom="M:NDepend.Path.IAbsoluteFilePath.UpdateExtension(System.String)" inheritedFromTypeName="IAbsoluteFilePath" csharp="newExtension.Length &gt;= 2" vb="newExtension.Length &gt;= 2">newExtension.Length &gt;= 2</requires>
      <requires description="newExtension first character must be a dot" inheritedFrom="M:NDepend.Path.IAbsoluteFilePath.UpdateExtension(System.String)" inheritedFromTypeName="IAbsoluteFilePath" csharp="newExtension.Chars[0] == '.'" vb="newExtension.Chars[0] = '.'">newExtension.Chars[0] == '.'</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.RelativeFilePath.GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
      <requires description="pivotDirectory must not be null" inheritedFrom="M:NDepend.Path.IRelativeFilePath.GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IRelativeFilePath" csharp="pivotDirectory != null" vb="pivotDirectory &lt;&gt; Nothing">pivotDirectory != null</requires>
      <requires description="pivotDirectory must not be empty" inheritedFrom="M:NDepend.Path.IRelativeFilePath.GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IRelativeFilePath" csharp="!pivotDirectory.IsEmpty" vb="Not pivotDirectory.IsEmpty">!pivotDirectory.IsEmpty</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.RelativeFilePath.NDepend#Path#IRelativePath#GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)">
      <requires description="pivotDirectory must not be null" inheritedFrom="M:NDepend.Path.IRelativePath.GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IRelativePath" csharp="pivotDirectory != null" vb="pivotDirectory &lt;&gt; Nothing">pivotDirectory != null</requires>
      <requires description="pivotDirectory must not be empty" inheritedFrom="M:NDepend.Path.IRelativePath.GetAbsolutePathFrom(NDepend.Path.IAbsoluteDirectoryPath)" inheritedFromTypeName="IRelativePath" csharp="!pivotDirectory.IsEmpty" vb="Not pivotDirectory.IsEmpty">!pivotDirectory.IsEmpty</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.RelativeFilePath.GetBrotherFileWithName(System.String)">
      <requires description="fileName must not be null" inheritedFrom="M:NDepend.Path.IRelativeFilePath.GetBrotherFileWithName(System.String)" inheritedFromTypeName="IRelativeFilePath" csharp="fileName != null" vb="fileName &lt;&gt; Nothing">fileName != null</requires>
      <requires description="fileName must not be empty" inheritedFrom="M:NDepend.Path.IRelativeFilePath.GetBrotherFileWithName(System.String)" inheritedFromTypeName="IRelativeFilePath" csharp="fileName.Length &gt; 0" vb="fileName.Length &gt; 0">fileName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.RelativeFilePath.GetBrotherDirectoryWithName(System.String)">
      <requires description="directoryName must not be null" inheritedFrom="M:NDepend.Path.IRelativeFilePath.GetBrotherDirectoryWithName(System.String)" inheritedFromTypeName="IRelativeFilePath" csharp="directoryName != null" vb="directoryName &lt;&gt; Nothing">directoryName != null</requires>
      <requires description="directoryName must not be empty" inheritedFrom="M:NDepend.Path.IRelativeFilePath.GetBrotherDirectoryWithName(System.String)" inheritedFromTypeName="IRelativeFilePath" csharp="directoryName.Length &gt; 0" vb="directoryName.Length &gt; 0">directoryName.Length &gt; 0</requires>
    </member>
    <member name="M:NDepend.Path.PathHelpers.RelativeFilePath.UpdateExtension(System.String)">
      <requires description="newExtension must not be null" inheritedFrom="M:NDepend.Path.IRelativeFilePath.UpdateExtension(System.String)" inheritedFromTypeName="IRelativeFilePath" csharp="newExtension != null" vb="newExtension &lt;&gt; Nothing">newExtension != null</requires>
      <requires description="newExtension must have at least two characters" inheritedFrom="M:NDepend.Path.IRelativeFilePath.UpdateExtension(System.String)" inheritedFromTypeName="IRelativeFilePath" csharp="newExtension.Length &gt;= 2" vb="newExtension.Length &gt;= 2">newExtension.Length &gt;= 2</requires>
      <requires description="newExtension first character must be a dot" inheritedFrom="M:NDepend.Path.IRelativeFilePath.UpdateExtension(System.String)" inheritedFromTypeName="IRelativeFilePath" csharp="newExtension.Chars[0] == '.'" vb="newExtension.Chars[0] = '.'">newExtension.Chars[0] == '.'</requires>
    </member>
    <member name="M:NDepend.Reserved.Linq.CodeQueryExpressionVisitor.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Reserved.Linq.QueryableImpl`1.System#Linq#IQueryable#get_Expression">
      <ensures inheritedFrom="M:System.Linq.IQueryable.get_Expression" inheritedFromTypeName="IQueryable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Reserved.Linq.QueryableImpl`1.System#Linq#IQueryable#get_ElementType">
      <ensures inheritedFrom="M:System.Linq.IQueryable.get_ElementType" inheritedFromTypeName="IQueryable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Reserved.Linq.QueryableImpl`1.System#Linq#IQueryable#get_Provider">
      <ensures inheritedFrom="M:System.Linq.IQueryable.get_Provider" inheritedFromTypeName="IQueryable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:NDepend.Reserved.Linq.QueryableImpl`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="P:NDepend.Reserved.Linq.QueryableImpl`1.System#Linq#IQueryable#Expression">
      <getter>
        <ensures inheritedFrom="M:System.Linq.IQueryable.get_Expression" inheritedFromTypeName="IQueryable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Reserved.Linq.QueryableImpl`1.System#Linq#IQueryable#ElementType">
      <getter>
        <ensures inheritedFrom="M:System.Linq.IQueryable.get_ElementType" inheritedFromTypeName="IQueryable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:NDepend.Reserved.Linq.QueryableImpl`1.System#Linq#IQueryable#Provider">
      <getter>
        <ensures inheritedFrom="M:System.Linq.IQueryable.get_Provider" inheritedFromTypeName="IQueryable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
  </members>
</doc>